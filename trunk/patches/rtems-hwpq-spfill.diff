diff -X dontdiff -upr rtems-base/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S
--- rtems-base/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S	2011-02-03 13:48:06.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S	2011-01-10 12:53:46.000000000 -0500
@@ -178,11 +178,11 @@ _take_mmu:
 	stxa %g0, [%g1] ASI_DMMU_DEMAP			
 	membar #Sync
 */
-#define SET_TLB_TAG(xVMA, r1, context) \
-	set xVMA | (context << TLB_TAG_ACCESS_CONTEXT_SHIFT), %r1
+#define SET_TLB_TAG(r1, context) \
+	set VMA | (context << TLB_TAG_ACCESS_CONTEXT_SHIFT), %r1
 
 	! write DTLB tag
-	SET_TLB_TAG(0x4000, g1, MEM_CONTEXT_KERNEL)
+	SET_TLB_TAG(g1, MEM_CONTEXT_KERNEL)
 	stxa %g1, [VA_DMMU_TAG_ACCESS] %asi			
 	membar #Sync
 
@@ -204,8 +204,8 @@ _take_mmu:
 	
 	! write DTLB data and install the kernel mapping
 	SET_TLB_DATA(g1, g2, TTE_L | TTE_W)	! use non-global mapping
-	stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG
-  membar #Sync
+	stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG		
+	membar #Sync
 
 	/*
 	 * Because we cannot use global mappings (because we want to have
@@ -271,7 +271,7 @@ _take_mmu:
 	flush %g5
 */
 	! write ITLB tag of context 0
-	SET_TLB_TAG(0x4000, g1, MEM_CONTEXT_KERNEL)
+	SET_TLB_TAG(g1, MEM_CONTEXT_KERNEL)
 	mov VA_DMMU_TAG_ACCESS, %g2
 	stxa %g1, [%g2] ASI_IMMU
 	flush %g5
@@ -280,18 +280,6 @@ _take_mmu:
 	SET_TLB_DATA(g1, g2, TTE_L)		! use non-global mapping
 	stxa %g1, [%g0] ASI_ITLB_DATA_IN_REG		
 	flush %g5
-
-  ! GAB: add more mappings for dmmu
-  SET_TLB_TAG(0x404000, g1, MEM_CONTEXT_KERNEL)
-  stxa %g1, [VA_DMMU_TAG_ACCESS] %asi
-  membar #Sync
-  set 0x400000, %g1
-  add %g1, %l5, %l5
-  SET_TLB_DATA(g1, g2, TTE_L | TTE_W)
-  stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG
-  membar #Sync
-
-
 /*
 	! enter nucleus - using context 0
 	wrpr %g0, 1, %tl
diff -X dontdiff -upr rtems-base/c/src/lib/libbsp/sparc64/shared/start/start.S rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/start/start.S
--- rtems-base/c/src/lib/libbsp/sparc64/shared/start/start.S	2011-02-03 12:53:24.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/start/start.S	2011-01-10 12:53:46.000000000 -0500
@@ -123,10 +123,6 @@ setstack:
 	set SYM(StackStart), %sp
 	add %sp, -STACK_BIAS, %sp
 
-  /* BSP-specific pre-bootcard initializations */
-  call SYM(_BSP_init)
-  nop
-
 	setx ofw_cif, %l0, %l1
  
 	call ofw_init		! initialize OpenFirmware
@@ -135,6 +131,10 @@ setstack:
   call bootstrap
   nop
 
+  /* BSP-specific pre-bootcard initializations */
+  call SYM(_BSP_init)
+  nop
+
   /* Set up ISR handler for interrupt enable/disable */
 	setx SYM(syscall), %l0, %o1
 	setx param_space, %l0, %o2
diff -X dontdiff -upr rtems-base/c/src/lib/libbsp/sparc64/shared/startup/linkcmds rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/linkcmds
--- rtems-base/c/src/lib/libbsp/sparc64/shared/startup/linkcmds	2011-02-03 13:39:18.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/linkcmds	2011-01-10 12:53:46.000000000 -0500
@@ -13,8 +13,8 @@
  * Declare some sizes.
  */
 RamBase = DEFINED(RamBase) ? RamBase : 0x0;
-RamSize = DEFINED(RamSize) ? RamSize : 6M; /* 3.5M */
-/*HeapSize = DEFINED(HeapSize) ? HeapSize : 1M;*/
+RamSize = DEFINED(RamSize) ? RamSize : 4M;
+HeapSize = DEFINED(HeapSize) ? HeapSize : 2M;
 StackSize = DEFINED(StackSize) ? StackSize : 256K;
 
 RAM_END = RamBase + RamSize;
@@ -25,7 +25,7 @@ ENTRY(start)
 
 MEMORY
         {
-	        ram : ORIGIN = 0x0, LENGTH = 8M
+	        ram : ORIGIN = 0x0, LENGTH = 256M
 	}
 
 
@@ -194,9 +194,7 @@ SECTIONS
     __end = .;
 
     . = RAM_END;
-    . += StackSize;
-
-/*    . = ALIGN (16);*/
+    . = ALIGN (16);
      PROVIDE (StackStart = .);
 
   } > ram
diff -X dontdiff -upr rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h rtems-hwpq-dev/cpukit/score/cpu/sparc64/rtems/score/sparc64.h
--- rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2011-01-10 12:22:39.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2011-02-13 14:07:26.000000000 -0500
@@ -182,7 +182,9 @@ extern "C" {
  *  1   First
  *  2   Enqueue
  *  3   Extract
+ *  4   SetRange
  *
+ * The upper 12 bits specify the queue id.
  */
 
 #define HWDS_FIRST( _queue, _ptr ) \
@@ -220,28 +222,68 @@ extern "C" {
     ); \
   } while (0)
 
+// TODO: Create an interface / wrapper for this.
+#define HWDS_SETRANGE( _queue, _base_addr, _bounds ) \
+  do { \
+    __asm__ __volatile__ ( \
+      "sll  %0, 20, %%l0\n\t" \
+      "sll  %2, 4, %%l1\n\t" \
+      "or   %%l0, %%l1, %%l0\n\t" \
+      "or   %%l0, 4, %%l0\n\t" \
+      "impdep2  %1, %%l0, %%g0" \
+      : \
+      : "r" (_queue), "r" (_base_addr), "r" (_bounds)\
+      : "l0" \
+        ); \
+  } while (0)
+
+#define HWDS_SPILL( _queue ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %0, 20, %%l0\n\t" \
+        "or   %%l0, 5, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %%g0" \
+        : \
+        : "r" (_queue) \
+        : "l0" \
+        ); \
+  } while (0)
+
+#define HWDS_FILL( _queue ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %0, 20, %%l0\n\t" \
+        "or   %%l0, 6, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %%g0" \
+        : \
+        : "r" (_queue) \
+        : "l0" \
+        ); \
+  } while (0)
+
 // TODO: Implement HWDS_FIND
 #define HWDS_FIND( _queue, _ptr, _result ) \
   do { \
-    __asm__ __volatile__ { \
+    __asm__ __volatile__ ( \
       "nop" \
       : \
       : \
       : \
-    }; \
+        ); \
   } while (0)
 
 // TODO: Implement HWDS_NEXT
 #define HWDS_NEXT( _queue, _ptr, _result ) \
   do { \
-    __asm__ __volatile__ { \
+    __asm__ __volatile__ ( \
       "nop" \
       : \
       : \
       : \
-    }; \
+        ); \
   } while (0)
 
+/**************************** DEPRECATED *********************************/
 // probably could do some type checking.
 #define HWDS1_FIRST( _ptr ) \
   do { \
diff -X dontdiff -upr rtems-base/cpukit/score/include/rtems/score/scheduler.h rtems-hwpq-dev/cpukit/score/include/rtems/score/scheduler.h
--- rtems-base/cpukit/score/include/rtems/score/scheduler.h	2010-12-13 17:40:29.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/include/rtems/score/scheduler.h	2011-01-10 15:26:20.000000000 -0500
@@ -24,6 +24,8 @@
 #include <rtems/score/prioritybitmap.h>
 #include <rtems/score/rbtree.h>
 
+//#define USING_HWPQ
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -X dontdiff -upr rtems-base/cpukit/score/inline/rtems/score/scheduleredf.inl rtems-hwpq-dev/cpukit/score/inline/rtems/score/scheduleredf.inl
--- rtems-base/cpukit/score/inline/rtems/score/scheduleredf.inl	2010-12-12 18:52:39.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/inline/rtems/score/scheduleredf.inl	2011-01-10 12:53:39.000000000 -0500
@@ -102,6 +102,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, sched->deadline.value, the_thread);
+#else
   /* first add the_thread to red-black tree */
   tmp_node = _RBTree_Insert_unprotected(
                &the_scheduler->Ready_queues.edf->edf_rbtree, 
@@ -182,6 +185,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
       tmp_sched->last_duplicate,
       &the_thread->Object.Node
   );
+#endif
 }
 
 /*
@@ -216,9 +220,13 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, sched->deadline.value, the_thread);
+#else
   /* TODO: re-write periodic tasks enqueue with lifo to break deadline ties? */
   _Scheduler_edf_Ready_queue_enqueue(the_thread);
   return;
+#endif
 }
 
 /*
@@ -256,6 +264,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_EXTRACT( 1, the_thread );
+#else
   if ( !(_RBTree_Is_node_off_rbtree( &sched->deadline )) ) {
     _RBTree_Extract_unprotected(
         &the_scheduler->Ready_queues.edf->edf_rbtree,
@@ -307,6 +318,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     _Chain_Initialize_empty( &the_scheduler->Ready_queues.edf->deadline_queue );
   else
     _Chain_Extract_unprotected( &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -325,10 +337,17 @@ RTEMS_INLINE_ROUTINE Thread_Control *_Sc
   Scheduler_Control       *the_scheduler
 )
 {
+#if defined(USING_HWPQ)
+  Thread_Control *t = NULL;
+  HWDS_FIRST( 1, t );
+  if (t)
+    return t;
+#else
   /* when there are periodic jobs to run, schedule them first */
   if ( !_Chain_Is_empty(&the_scheduler->Ready_queues.edf->deadline_queue ) )
     return (Thread_Control *) 
       _Chain_First(&the_scheduler->Ready_queues.edf->deadline_queue);
+#endif
 
   /* otherwise schedule aperiodic jobs as background tasks */
 
diff -X dontdiff -upr rtems-base/cpukit/score/inline/rtems/score/schedulerpriority.inl rtems-hwpq-dev/cpukit/score/inline/rtems/score/schedulerpriority.inl
--- rtems-base/cpukit/score/inline/rtems/score/schedulerpriority.inl	2010-12-13 17:38:47.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/inline/rtems/score/schedulerpriority.inl	2011-01-10 12:53:39.000000000 -0500
@@ -64,10 +64,14 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control                  *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, the_thread->current_priority, the_thread );
+#else
   _Priority_bit_map_Add( &the_thread->scheduler.priority->Priority_map );
   
   _Chain_Append_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -89,10 +93,14 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control                   *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, the_thread->current_priority, the_thread );
+#else
   _Priority_bit_map_Add( &the_thread->scheduler.priority->Priority_map );
 
   _Chain_Prepend_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -113,6 +121,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control        *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_EXTRACT( 1, the_thread);
+#else
   Chain_Control         *ready  = the_thread->scheduler.priority->ready_chain;
 
   if ( _Chain_Has_only_one_node( ready ) ) {
@@ -120,6 +131,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
     _Priority_bit_map_Remove( &the_thread->scheduler.priority->Priority_map );
   } else
     _Chain_Extract_unprotected( &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -138,12 +150,18 @@ RTEMS_INLINE_ROUTINE Thread_Control *_Sc
   Chain_Control       *the_ready_queue
 )
 {
+#if defined(USING_HWPQ)
+  Thread_Control *t = NULL;
+  HWDS_FIRST(1, t);
+  return t;
+#else
   Priority_Control index = _Priority_bit_map_Get_highest();
 
   if ( !_Chain_Is_empty( &the_ready_queue[ index ] ) )
     return (Thread_Control *) _Chain_First( &the_ready_queue[ index ] );
 
   return NULL;
+#endif
 }
 
 /*
@@ -164,6 +182,10 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control            *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  _Scheduler_priority_Ready_queue_extract(the_thread);
+  _Scheduler_priority_Ready_queue_enqueue(the_thread);
+#else
   if ( !_Chain_Has_only_one_node(
         the_thread->scheduler.priority->ready_chain
         ) ) {
@@ -172,6 +194,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
     _Chain_Append_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
   }
+#endif
 }
 
 /*
diff -X dontdiff -upr rtems-base/testsuites/configure.ac rtems-hwpq-dev/testsuites/configure.ac
--- rtems-base/testsuites/configure.ac	2011-02-01 12:13:41.000000000 -0500
+++ rtems-hwpq-dev/testsuites/configure.ac	2011-01-10 12:53:36.000000000 -0500
@@ -29,10 +29,8 @@ RTEMS_CHECK_CPUOPTS([RTEMS_NETWORKING])
 case $enable_tests in
 yes | samples )
   AC_CONFIG_SUBDIRS(samples)
-#  AC_CONFIG_SUBDIRS(gabtests)
+  AC_CONFIG_SUBDIRS(gabtests)
   AC_CONFIG_SUBDIRS(mibench)
-  AC_CONFIG_SUBDIRS(heapbench)
-  AC_CONFIG_SUBDIRS(disbench)
   ;;
 esac
 
Only in rtems-base/testsuites: disbench
diff -X dontdiff -upr rtems-base/testsuites/gabtests/dijkstra00/system.h rtems-hwpq-dev/testsuites/gabtests/dijkstra00/system.h
--- rtems-base/testsuites/gabtests/dijkstra00/system.h	2010-12-31 12:47:21.000000000 -0500
+++ rtems-hwpq-dev/testsuites/gabtests/dijkstra00/system.h	2011-01-10 12:53:38.000000000 -0500
@@ -92,7 +92,7 @@ rtems_task Tasks_Periodic(
 
 /* system */
 #define CONFIGURE_MICROSECONDS_PER_TICK 1000
-//#define CONFIGURE_SCHEDULER_EDF
+#define CONFIGURE_SCHEDULER_EDF
 
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
diff -X dontdiff -upr rtems-base/testsuites/gabtests/dijkstra01/dijkstra.c rtems-hwpq-dev/testsuites/gabtests/dijkstra01/dijkstra.c
--- rtems-base/testsuites/gabtests/dijkstra01/dijkstra.c	2011-01-04 10:56:13.000000000 -0500
+++ rtems-hwpq-dev/testsuites/gabtests/dijkstra01/dijkstra.c	2011-01-10 12:53:38.000000000 -0500
@@ -44,16 +44,16 @@ static int iCost, iDist;
 
 static void print_path (NODE *rgnNodes, int chNode)
 {
-   /* Recursion is bad. for now print the path backwards*/
+  /* Recursion is bad. for now print the path backwards*/
   while(chNode != NONE) {
     printf(" %d", chNode);
     chNode = rgnNodes[chNode].iPrev;
   }
 #if 0
   if (rgnNodes[chNode].iPrev != NONE)
-    {
-      print_path(rgnNodes, rgnNodes[chNode].iPrev);
-    }
+  {
+    print_path(rgnNodes, rgnNodes[chNode].iPrev);
+  }
   printf (" %d", chNode);
   fflush(stdout);
 #endif
@@ -66,25 +66,36 @@ static void enqueue (int iNode, int iDis
   QITEM *qLast = qHead;
 
   if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      MAGIC_BREAKPOINT;
-      while(1);
-    }
+  {
+    fprintf(stderr, "Out of memory.\n");
+    MAGIC_BREAKPOINT;
+    while(1);
+  }
   qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
 
+  // GAB: instead of tail-queueing, sort entries as a 
+  // priority queue by the iDist.
   if (!qLast)
-    {
-      qHead = qNew;
-    }
+  {
+    qHead = qNew;
+  }
+  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
+  {
+    qHead = qNew;
+    qNew->qNext = qLast;
+  }
   else
-    {
-      while (qLast->qNext) qLast = qLast->qNext;
-      qLast->qNext = qNew;
+  {
+    // already handled head case, find the Q element to insert qNew after.
+    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
+      qLast = qLast->qNext;
     }
+    qNew->qNext = qLast->qNext;
+    qLast->qNext = qNew;
+  }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
@@ -95,15 +106,15 @@ static void dequeue (int *piNode, int *p
   QITEM *qKill = qHead;
 
   if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
-      g_qCount--;
-    }
+  {
+    //                 ASSERT(g_qCount);
+    *piNode = qHead->iNode;
+    *piDist = qHead->iDist;
+    *piPrev = qHead->iPrev;
+    qHead = qHead->qNext;
+    free(qKill);
+    g_qCount--;
+  }
 }
 
 
@@ -117,42 +128,42 @@ static int dijkstra(int chStart, int chE
   int i = 0;
 
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+  }
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
-
-      enqueue (chStart, 0, NONE);
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
+
+    enqueue (chStart, 0, NONE);
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+  }
   return 0;
 }
 
@@ -176,7 +187,7 @@ int dijkstra_setup( ) {
     for (j=0;j<NUM_NODES;j++) {
       /* make it more sparce */
       fscanf(fp,"%d",&k);
-			AdjMatrix[i][j]= k;
+      AdjMatrix[i][j]= k;
     }
   }
 
@@ -185,7 +196,7 @@ int dijkstra_setup( ) {
 
 rtems_task Tasks_Dijkstra(
     rtems_task_argument argument
-)
+    )
 {
   uint32_t          i = 0;
   uint32_t          j = NUM_NODES/2;
@@ -202,8 +213,8 @@ rtems_task Tasks_Dijkstra(
   /* finds 10 shortest paths between nodes */
   for ( ; i<20; ++i,++j) {
     printf("Computing at %d, %d\n",i,j);
-			j = (j % NUM_NODES);
-      dijkstra(i,j);
+    j = (j % NUM_NODES);
+    dijkstra(i,j);
   }
   printf("Done\n");
 
@@ -211,13 +222,13 @@ rtems_task Tasks_Dijkstra(
   status = rtems_semaphore_obtain( tasks_complete_sem, 
       RTEMS_DEFAULT_OPTIONS, 0 );
   directive_failed( status, "rtems_semaphore_obtain" );
-    tasks_completed++;
-      printf("Done\n");
+  tasks_completed++;
+  printf("Done\n");
 
-    if ( NUM_APERIODIC_TASKS == tasks_completed ) {
-      MAGIC_BREAKPOINT;
-      rtems_test_exit( 0 );
-    }
+  if ( NUM_APERIODIC_TASKS == tasks_completed ) {
+    MAGIC_BREAKPOINT;
+    rtems_test_exit( 0 );
+  }
   status = rtems_semaphore_release( tasks_complete_sem );
   directive_failed( status, "rtems_semaphore_release" );
 
Only in rtems-base/testsuites: heapbench
Only in rtems-base/testsuites/mibench: basicmath_large
Only in rtems-base/testsuites/mibench: basicmath_small
Only in rtems-base/testsuites/mibench: bitcount_large
Only in rtems-base/testsuites/mibench: bitcount_small
diff -X dontdiff -upr rtems-base/testsuites/mibench/configure.ac rtems-hwpq-dev/testsuites/mibench/configure.ac
--- rtems-base/testsuites/mibench/configure.ac	2011-01-30 19:12:15.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/configure.ac	2011-02-13 13:15:14.000000000 -0500
@@ -4,7 +4,7 @@
 
 AC_PREREQ(2.60)
 AC_INIT([rtems-c-src-tests-mibench],[_RTEMS_VERSION],[http://www.rtems.org/bugzilla])
-AC_CONFIG_SRCDIR([crc])
+AC_CONFIG_SRCDIR([sha_small])
 RTEMS_TOP([../..],[..])
 
 RTEMS_CANONICAL_TARGET_CPU
@@ -60,29 +60,20 @@ AM_CONDITIONAL(LIBCHIP,[test "$RTEMS_BSP
 
 # Explicitly list all Makefiles here
 AC_CONFIG_FILES([Makefile
-basicmath_large/Makefile
-basicmath_small/Makefile
-bitcount_large/Makefile
-bitcount_small/Makefile
-crc/Makefile
-dijkstra/Makefile
-fft_large/Makefile
-fft_small/Makefile
-fftinv_large/Makefile
-fftinv_small/Makefile
-patricia_small/Makefile
-qsort_small/Makefile
-rijndael_small/Makefile
 sha_small/Makefile
-stringsearch_large/Makefile
-stringsearch_small/Makefile
+sha_large/Makefile
 susan_smoothing/Makefile
-susan_corners/Makefile
-susan_edges/Makefile
+crc/Makefile
+dijkstra/Makefile
+dijkstra_large_sort_HWPQ/Makefile
+dijkstra_large_sort_OSPQ/Makefile
+dijkstra_small_sort_HWPQ/Makefile
+dijkstra_small_sort_HWPQ_spill/Makefile
+dijkstra_small_sort_OSPQ/Makefile
+dijkstra_small_sort/Makefile
+dijkstra_large_sort/Makefile
+dijkstra_small_heap/Makefile
+dijkstra_large_heap/Makefile
+dijkstra_small_3_heap/Makefile
 ])
-#dijkstra_small_sort/Makefile
-#dijkstra_large_sort/Makefile
-#dijkstra_small_sort_HWPQ/Makefile
-#dijkstra_large_sort_HWPQ/Makefile
-
 AC_OUTPUT
Only in rtems-base/testsuites/mibench/crc/files: small.pcm
diff -X dontdiff -upr rtems-base/testsuites/mibench/crc/init.c rtems-hwpq-dev/testsuites/mibench/crc/init.c
--- rtems-base/testsuites/mibench/crc/init.c	2011-02-01 15:29:43.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/crc/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -35,7 +35,7 @@ rtems_task Init(
 {
   
 
-  char in_file[20] = "/small.pcm";
+  char in_file[20] = "/image.img";
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
Only in rtems-base/testsuites/mibench/crc: LICENSE
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra/init.c
--- rtems-base/testsuites/mibench/dijkstra/init.c	2010-12-14 10:11:41.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -199,11 +199,13 @@ rtems_task Init(
     }
   }
 
+  asm volatile("break_start_opal:");
   /* finds 10 shortest paths between nodes */
   for (i=0,j=NUM_NODES/2;i<20;i++,j++) {
 			j=j%NUM_NODES;
       dijkstra(i,j);
   }
+  MAGIC_BREAKPOINT;
 
   printf( "*** end of dijkstra benchmark ***\n" );
   exit( 0 );
Only in rtems-base/testsuites/mibench/dijkstra: LICENSE
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_large_heap
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_large_sort/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_sort/init.c	2011-01-06 14:09:15.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/init.c	2011-01-11 16:16:03.000000000 -0500
@@ -17,29 +17,23 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  struct _NODE *qNext;
+  struct _NODE *qPrev;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
+typedef struct _NODE NODE;
 
+NODE *qHead = NULL;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,35 +41,45 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
-
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
+  int i = 0;
+  NODE *qLast = NULL;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    if (qNew->qNext) {
+      qNew->qNext->qPrev = qNew->qPrev;
+    }
+    if (qNew->qPrev) {
+      qNew->qPrev->qNext = qNew->qNext;
+    } else {
+      qHead = qNew->qNext;
     }
-  qNew->iNode = iNode;
+    g_qCount--;
+  }
+  
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
+  qNew->qPrev = NULL;
+  qNew->qFlag = 1;
 
+  qLast = qHead;
   // GAB: instead of tail-queueing, sort entries as a 
   // priority queue by the iDist.
   if (!qLast)
@@ -86,6 +90,7 @@ void enqueue (int iNode, int iDist, int 
   {
     qHead = qNew;
     qNew->qNext = qLast;
+    qLast->qPrev = qNew;
   }
   else
   {
@@ -94,30 +99,36 @@ void enqueue (int iNode, int iDist, int 
       qLast = qLast->qNext;
     }
     qNew->qNext = qLast->qNext;
+    qNew->qPrev = qLast;
+    if (qNew->qNext)
+      qNew->qNext->qPrev = qNew;
     qLast->qNext = qNew;
   }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = qHead;
+  NODE *qKill = qHead;
 
-    if (qHead)
+  if (qHead)
     {
       //                 ASSERT(g_qCount);
       *piNode = qHead->iNode;
       *piDist = qHead->iDist;
       *piPrev = qHead->iPrev;
       qHead = qHead->qNext;
-      free(qKill);
+      if (qHead)
+        qHead->qPrev = NULL;
+      qKill->qNext = NULL;
+      qKill->qPrev = NULL;
+      qKill->qFlag = 0;
+//      free(qKill);
       g_qCount--;
     }
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -125,18 +136,22 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i;
   for (ch = 0; ch < NUM_NODES; ch++)
     {
+      rgnNodes[ch].iNode = ch;
       rgnNodes[ch].iDist = NONE;
       rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].qPrev = NULL;
+      rgnNodes[ch].qNext = NULL;
+      rgnNodes[ch].qFlag = 0;
     }
 
   if (chStart == chEnd)
     {
+#if defined(GAB_PRINT)
       printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
     }
   else
     {
@@ -162,23 +177,22 @@ int dijkstra(int chStart, int chEnd)
 		}
 	    }
 	}
-
+#if defined(GAB_PRINT)
       printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
       printf("Path is: ");
       print_path(rgnNodes, chEnd);
       printf("\n");
+#endif
     }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -186,18 +200,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_large_sort/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/system.h
--- rtems-base/testsuites/mibench/dijkstra_large_sort/system.h	2011-01-10 13:12:25.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/system.h	2011-01-11 16:15:51.000000000 -0500
@@ -31,7 +31,8 @@ rtems_task Init(
 #include <bsp.h> /* for device driver prototypes */
 
 /* drivers */
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
 
 /* filesystem */
@@ -42,8 +43,9 @@ rtems_task Init(
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
 /* tasks */
-#define CONFIGURE_MAXIMUM_TASKS             4
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
-#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+//#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
 
 #include <rtems/confdefs.h>
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c	2011-01-10 11:55:50.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c	2011-01-11 16:43:00.000000000 -0500
@@ -17,29 +17,19 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
-
+typedef struct _NODE NODE;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,65 +37,40 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    HWDS_EXTRACT ( 4, qNew );
+    g_qCount--;
+  }
 
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
-    }
-  qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
-  qNew->qNext = NULL;
-
+  qNew->qFlag = 1;
   HWDS_ENQUEUE ( 4, iDist, qNew );
-  /*
-  // GAB: instead of tail-queueing, sort entries as a 
-  // priority queue by the iDist.
-  if (!qLast)
-  {
-    qHead = qNew;
-  }
-  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
-  {
-    qHead = qNew;
-    qNew->qNext = qLast;
-  }
-  else
-  {
-    // already handled head case, find the Q element to insert qNew after.
-    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
-      qLast = qLast->qNext;
-    }
-    qNew->qNext = qLast->qNext;
-    qLast->qNext = qNew;
-  }*/
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = NULL;// = qHead;
+  NODE *qKill = NULL;
 
   HWDS_FIRST( 4, qKill );
 
@@ -116,23 +81,11 @@ void dequeue (int *piNode, int *piDist, 
       *piDist = qKill->iDist;
       *piPrev = qKill->iPrev;
       HWDS_EXTRACT ( 4, qKill );
-      free(qKill);
-      g_qCount--;
-    }
-/*
-  if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
+      qKill->qFlag = 0;
       g_qCount--;
-    }*/
+    } 
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -140,60 +93,61 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i = 0;
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iNode = ch;
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+    rgnNodes[ch].qFlag = 0;
+  }
 
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+#if defined(GAB_PRINT)
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
 
-      enqueue (chStart, 0, NONE);
+    enqueue (chStart, 0, NONE);
 
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+#if defined(GAB_PRINT)
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+#endif
+  }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -201,18 +155,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_large_sort_OSPQ
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_small_3_heap
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_small_heap
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_small_sort/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort/init.c	2011-01-10 14:06:33.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort/init.c	2011-01-11 12:33:04.000000000 -0500
@@ -15,32 +15,25 @@
 
 #define CONFIGURE_INIT
 #include "system.h"
-
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  struct _NODE *qNext;
+  struct _NODE *qPrev;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
+typedef struct _NODE NODE;
 
+NODE *qHead = NULL;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -48,35 +41,45 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
-
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
+  int i = 0;
+  NODE *qLast = NULL;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    if (qNew->qNext) {
+      qNew->qNext->qPrev = qNew->qPrev;
+    }
+    if (qNew->qPrev) {
+      qNew->qPrev->qNext = qNew->qNext;
+    } else {
+      qHead = qNew->qNext;
     }
-  qNew->iNode = iNode;
+    g_qCount--;
+  }
+  
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
+  qNew->qPrev = NULL;
+  qNew->qFlag = 1;
 
+  qLast = qHead;
   // GAB: instead of tail-queueing, sort entries as a 
   // priority queue by the iDist.
   if (!qLast)
@@ -87,6 +90,7 @@ void enqueue (int iNode, int iDist, int 
   {
     qHead = qNew;
     qNew->qNext = qLast;
+    qLast->qPrev = qNew;
   }
   else
   {
@@ -95,30 +99,36 @@ void enqueue (int iNode, int iDist, int 
       qLast = qLast->qNext;
     }
     qNew->qNext = qLast->qNext;
+    qNew->qPrev = qLast;
+    if (qNew->qNext)
+      qNew->qNext->qPrev = qNew;
     qLast->qNext = qNew;
   }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = qHead;
+  NODE *qKill = qHead;
 
-    if (qHead)
+  if (qHead)
     {
       //                 ASSERT(g_qCount);
       *piNode = qHead->iNode;
       *piDist = qHead->iDist;
       *piPrev = qHead->iPrev;
       qHead = qHead->qNext;
-      free(qKill);
+      if (qHead)
+        qHead->qPrev = NULL;
+      qKill->qNext = NULL;
+      qKill->qPrev = NULL;
+      qKill->qFlag = 0;
+//      free(qKill);
       g_qCount--;
     }
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -126,18 +136,22 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i;
   for (ch = 0; ch < NUM_NODES; ch++)
     {
+      rgnNodes[ch].iNode = ch;
       rgnNodes[ch].iDist = NONE;
       rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].qPrev = NULL;
+      rgnNodes[ch].qNext = NULL;
+      rgnNodes[ch].qFlag = 0;
     }
 
   if (chStart == chEnd)
     {
-//      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#if defined(GAB_PRINT)
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
     }
   else
     {
@@ -163,24 +177,22 @@ int dijkstra(int chStart, int chEnd)
 		}
 	    }
 	}
-/*
+#if defined(GAB_PRINT)
       printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
       printf("Path is: ");
       print_path(rgnNodes, chEnd);
       printf("\n");
-*/
+#endif
     }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -188,18 +200,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c	2011-01-10 11:55:37.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c	2011-02-13 13:16:36.000000000 -0500
@@ -17,29 +17,19 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
-
+typedef struct _NODE NODE;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,65 +37,40 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    HWDS_EXTRACT ( 4, qNew );
+    g_qCount--;
+  }
 
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
-    }
-  qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
-  qNew->qNext = NULL;
-
+  qNew->qFlag = 1;
   HWDS_ENQUEUE ( 4, iDist, qNew );
-  /*
-  // GAB: instead of tail-queueing, sort entries as a 
-  // priority queue by the iDist.
-  if (!qLast)
-  {
-    qHead = qNew;
-  }
-  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
-  {
-    qHead = qNew;
-    qNew->qNext = qLast;
-  }
-  else
-  {
-    // already handled head case, find the Q element to insert qNew after.
-    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
-      qLast = qLast->qNext;
-    }
-    qNew->qNext = qLast->qNext;
-    qLast->qNext = qNew;
-  }*/
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = NULL;// = qHead;
+  NODE *qKill = NULL;
 
   HWDS_FIRST( 4, qKill );
 
@@ -116,23 +81,11 @@ void dequeue (int *piNode, int *piDist, 
       *piDist = qKill->iDist;
       *piPrev = qKill->iPrev;
       HWDS_EXTRACT ( 4, qKill );
-      free(qKill);
-      g_qCount--;
-    }
-/*
-  if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
+      qKill->qFlag = 0;
       g_qCount--;
-    }*/
+    } 
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -140,60 +93,61 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i = 0;
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iNode = ch;
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+    rgnNodes[ch].qFlag = 0;
+  }
 
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+#if defined(GAB_PRINT)
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
 
-      enqueue (chStart, 0, NONE);
+    enqueue (chStart, 0, NONE);
 
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+#if defined(GAB_PRINT)
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+#endif
+  }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -201,18 +155,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -upr rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h	2011-01-10 13:12:25.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h	2011-01-11 12:05:47.000000000 -0500
@@ -31,7 +31,8 @@ rtems_task Init(
 #include <bsp.h> /* for device driver prototypes */
 
 /* drivers */
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
 
 /* filesystem */
@@ -42,7 +43,8 @@ rtems_task Init(
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
 /* tasks */
-#define CONFIGURE_MAXIMUM_TASKS             4
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
 #define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
 
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_small_sort_HWPQ_spill
Only in rtems-hwpq-dev/testsuites/mibench: dijkstra_small_sort_OSPQ
Only in rtems-base/testsuites/mibench: fftinv_large
Only in rtems-base/testsuites/mibench: fftinv_small
Only in rtems-base/testsuites/mibench: fft_large
Only in rtems-base/testsuites/mibench: fft_small
diff -X dontdiff -upr rtems-base/testsuites/mibench/LICENSE rtems-hwpq-dev/testsuites/mibench/LICENSE
--- rtems-base/testsuites/mibench/LICENSE	2011-01-30 18:50:53.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/LICENSE	2011-01-10 12:53:36.000000000 -0500
@@ -1,2 +1 @@
-See the individual LICENSE files.
-
+MIBench is under GPL.
diff -X dontdiff -upr rtems-base/testsuites/mibench/Makefile.am rtems-hwpq-dev/testsuites/mibench/Makefile.am
--- rtems-base/testsuites/mibench/Makefile.am	2011-01-30 19:12:03.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/Makefile.am	2011-02-13 13:15:02.000000000 -0500
@@ -4,14 +4,13 @@
 
 ACLOCAL_AMFLAGS = -I ../aclocal
 
-SUBDIRS = basicmath_large basicmath_small bitcount_large bitcount_small \
-					crc dijkstra \
-					fft_small fft_large fftinv_small fftinv_large \
-					qsort_small rijndael_small sha_small \
-					stringsearch_large stringsearch_small \
-					susan_corners susan_edges susan_smoothing
-#	dijkstra_small_sort dijkstra_large_sort \
-#	dijkstra_small_sort_HWPQ dijkstra_large_sort_HWPQ
+SUBDIRS = sha_small sha_large crc dijkstra susan_smoothing \
+					dijkstra_large_sort_HWPQ dijkstra_large_sort_OSPQ \
+					dijkstra_small_sort_HWPQ dijkstra_small_sort_OSPQ \
+					dijkstra_small_sort_HWPQ_spill \
+					dijkstra_small_sort dijkstra_large_sort \
+					dijkstra_small_heap dijkstra_large_heap \
+					dijkstra_small_3_heap
 
 if MPTESTS
 endif
@@ -20,7 +19,6 @@ if CXXTESTS
 endif
 
 if NETTESTS
-SUBDIRS += patricia_small
 endif
 
 include $(top_srcdir)/../automake/subdirs.am
Only in rtems-base/testsuites/mibench: patricia_small
Only in rtems-base/testsuites/mibench: qsort_small
Only in rtems-base/testsuites/mibench: rijndael_small
Only in rtems-base/testsuites/mibench/sha_large: LICENSE
Only in rtems-base/testsuites/mibench/sha_small: LICENSE
diff -X dontdiff -upr rtems-base/testsuites/mibench/sha_small/sha.h rtems-hwpq-dev/testsuites/mibench/sha_small/sha.h
--- rtems-base/testsuites/mibench/sha_small/sha.h	2011-01-30 19:22:36.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/sha_small/sha.h	2011-01-10 12:53:36.000000000 -0500
@@ -7,7 +7,7 @@
 /* Useful defines & typedefs */
 
 typedef unsigned char BYTE;
-typedef unsigned int LONG;
+typedef unsigned long LONG;
 
 #define SHA_BLOCKSIZE		64
 #define SHA_DIGESTSIZE		20
Only in rtems-base/testsuites/mibench: stringsearch_large
Only in rtems-base/testsuites/mibench: stringsearch_small
Only in rtems-base/testsuites/mibench/susan_corners: init.c
Only in rtems-base/testsuites/mibench/susan_corners: LICENSE
diff -X dontdiff -upr rtems-base/testsuites/mibench/susan_corners/Makefile.am rtems-hwpq-dev/testsuites/mibench/susan_corners/Makefile.am
--- rtems-base/testsuites/mibench/susan_corners/Makefile.am	2011-01-30 13:55:22.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_corners/Makefile.am	2011-01-10 12:53:36.000000000 -0500
@@ -15,7 +15,6 @@ include $(top_srcdir)/../automake/compil
 include $(top_srcdir)/../automake/leaf.am
 
 susan_corners_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
-susan_corners_LDLIBS = -lm
 
 LINK_OBJS = $(susan_corners_OBJECTS) $(susan_corners_LDADD)
 LINK_LIBS = $(susan_corners_LDLIBS)
Only in rtems-hwpq-dev/testsuites/mibench/susan_corners: susan.c
Only in rtems-base/testsuites/mibench/susan_edges: init.c
Only in rtems-base/testsuites/mibench/susan_edges: LICENSE
diff -X dontdiff -upr rtems-base/testsuites/mibench/susan_edges/Makefile.am rtems-hwpq-dev/testsuites/mibench/susan_edges/Makefile.am
--- rtems-base/testsuites/mibench/susan_edges/Makefile.am	2011-01-30 13:55:21.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/Makefile.am	2011-01-10 12:53:36.000000000 -0500
@@ -15,7 +15,6 @@ include $(top_srcdir)/../automake/compil
 include $(top_srcdir)/../automake/leaf.am
 
 susan_edges_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
-susan_edges_LDLIBS = -lm
 
 LINK_OBJS = $(susan_edges_OBJECTS) $(susan_edges_LDADD)
 LINK_LIBS = $(susan_edges_LDLIBS)
diff -X dontdiff -upr rtems-base/testsuites/mibench/susan_edges/system.h rtems-hwpq-dev/testsuites/mibench/susan_edges/system.h
--- rtems-base/testsuites/mibench/susan_edges/system.h	2011-01-30 16:39:47.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/system.h	2011-01-10 12:53:36.000000000 -0500
@@ -39,6 +39,7 @@ rtems_task Init(
 #define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
 #define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
 
+
 /* tasks */
 #define CONFIGURE_MAXIMUM_TASKS             4
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
diff -X dontdiff -upr rtems-base/testsuites/mibench/susan_smoothing/init.c rtems-hwpq-dev/testsuites/mibench/susan_smoothing/init.c
--- rtems-base/testsuites/mibench/susan_smoothing/init.c	2011-02-01 15:05:48.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_smoothing/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -351,7 +351,7 @@ int getint(fd)
   {
     if (c=='#')    /* if we're at a comment, read to end of line */
       //fgets(dummy,9000,fd);
-      while(c != '\n' && i<100)
+      while(c != "\n" && i<56)
       	{
 			c = getc(fd);
 			//printf("%d",i);
@@ -438,7 +438,7 @@ FILE  *fd;
   if ((fd=fopen(filename,"w")) == NULL)
 #endif
     exit_error("Can't output image%s.\n",filename);
-  
+
   fprintf(fd,"P5\n");
   fprintf(fd,"%d %d\n",x_size,y_size);
   fprintf(fd,"255\n");
@@ -1972,7 +1972,6 @@ corner_list[n].info=7;
 
 /* }}} */
 /* {{{ main(argc, argv) */
-CORNER_LIST corner_list;
 
 main(argc, argv)
   int   argc;
@@ -1997,6 +1996,7 @@ int    *r,
        max_no_edges=2650,
        mode = 0, i,
        x_size, y_size;
+CORNER_LIST corner_list;
 
 /* }}} */
 
Only in rtems-base/testsuites/mibench/susan_smoothing: LICENSE
diff -X dontdiff -upr rtems-base/testsuites/samples/hello/init.c rtems-hwpq-dev/testsuites/samples/hello/init.c
--- rtems-base/testsuites/samples/hello/init.c	2010-12-13 17:38:47.000000000 -0500
+++ rtems-hwpq-dev/testsuites/samples/hello/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -29,9 +29,11 @@ rtems_task Init(
   rtems_task_argument ignored
 )
 {
+  asm volatile("break_start_opal:");
   printf( "\n\n*** HELLO WORLD TEST ***\n" );
   printf( "Hello World\n" );
   printf( "*** END OF HELLO WORLD TEST ***\n" );
+  MAGIC_BREAKPOINT;
   exit( 0 );
 }
 
