#summary Design of refactored scheduler infrastructure.
#labels Phase-Design

= Introduction =

This page provides the design of how the scheduler will be refactored as part of this project.

== Broad Goals ==

At a high-level, the RTEMS' scheduler should be modular and configurable to support the existing scheduling mechanisms and new scheduling mechanisms for uniproccessors and multiprocessors. Part of this modularity is captured by providing abstract NewReadyQueue and NewPriorityHandler interfaces.

== Supporting the Current Scheduler ==

This section describes how the existing scheduler mechanism can be improved.  This is in addition to changes made already to refactor the ready queue and priority handlers. 

The interface to the scheduling subsystem should be simply and concisely captured.  The necessary functions along the interface boundary include:
{{{

  _Scheduler_Schedule( void )

  _Scheduler_Yield( void )

  _Scheduler_Block( Thread_Control * )

  _Scheduler_Unblock( Thread_Control * )

}}}

_Note: The Scheduler Handler does not care why a thread is blocked or unblocked, thread state management is not the responsibility of the scheduler._

In addition to interface routines, the scheduler maintains the internal data structures necessary for making scheduling decisions. This includes primarily the ready queue structure(s).  In the original RTEMS scheduling mechanism, this was the `Chain_Control _Thread_Ready_chain`, which has been updated to the `Ready_queue_Control _Thread_Ready_queue` object.  Other variables that might be subsumed by the Scheduler Object include `_Thread_Executing` and `_Thread_Heir`, however these are transitioning to the per-cpu code base, so I will leave them alone for the time being.

=== Function Description ===

The functionality of these functions already exist in various RTEMS functions:
  * `_Scheduler_Schedule`: Scheduling decision logic, determines the next thread to run. In RTEMS, this is currently done by the `_Thread_Calculate_heir` function in thread.inl.
  * `_Scheduler_Yield`: When a thread has no work to do, it should yield the processor by calling this function, but would remain in the ready state.  In RTEMS, this is currently done by the `_Thread_Yield_processor` and `_Thread_Reset_timeslice`.
  * `_Scheduler_Block`: When a thread is removed from the ready state for whatever reason, it is considered blocked. In RTEMS, this is currently done by a few functions:
    * `_Thread_Suspend`
    * `_Thread_Set_state`
    * ~~`_Thread_Set_transient`~~
  * `_Scheduler_Unblock`: When a thread is readied, it is considered unblocked. In RTEMS, this is currently done by a few functions:
    * `_Thread_Ready`
    * `_Thread_Clear_state`
    * `_Thread_Resume`
    * `_Thread_Unblock`

=== Prototypes ===
Here are some prototypical implementations of these interface functions:
{{{

void _Scheduler_Schedule( void ) {
  /* Copy _Thread_Calculate_heir body here */
}

void _Scheduler_Yield( void ) {
  /* Copy _Thread_Yield_processor body here */
}

void _Scheduler_Block( Thread_Control *the_thread ) {
  _Ready_queue_Extract(&_Thread_Ready_queue, the_thread);
  
  /* Flash ISRs or similar mechanism for SMP?? */

  if ( _Thread_Is_heir( the_thread ) )
    _Scheduler_Schedule();

  if ( _Thread_Is_executing( the_thread ) )
    _Context_Switch_necessary = true;

  return;
}

void _Scheduler_Unblock( Thread_Control *the_thread ) {
  _Ready_queue_Enqueue( &_Thread_Ready_queue, the_thread );

  /* Flash ISRs or similar mechanism for SMP?? */

  _Scheduler_Schedule();

  /*
   *  If the thread that was unblocked is more important than the heir,
   *  then we have a new heir.  This may or may not result in a
   *  context switch.
   *
   *  Normal case:
   *    If the current thread is preemptible, then we need to do
   *    a context switch.
   *  Pseudo-ISR case:
   *    Even if the thread isn't preemptible, if the new heir is
   *    a pseudo-ISR system task, we need to do a context switch.
   */
  if ( !_Thread_Is_executing( heir ) ) {
    if ( _Thread_Executing->is_preemptible ||
         _Priority_Get_value(the_thread->current_priority) == 0 )
      _Context_Switch_necessary = true;
  }

  return;
}

}}}
_Note: One thing that needs to be determined is how to deal with opening up the scheduling critical section to allow for new threads to enter the scheduler._

_Note: Another concern is ports that can "dispatch from ISR", as this represents another scheduling point._

_Note: I have removed dispatch from the scheduler object. It seems better to isolate dispatch as a mechanism separate from the scheduler logic_

== Adding New Schedulers ==
To create a scheduler `Foo` follow these steps.

Create a new header file `include/rtems/score/schedulerfoo.h` and add all of the `_Scheduler_foo_XXX` prototypes to the header file.  Add this header to the `cpukit/score/Makefile.am`.

Then create `src/schedulerfoo.c` and define the `_Scheduler_foo_Initialize` routine to set the scheduler operations table for the `foo` scheduler.  The `priority` scheduler implementation is a good guide for creating new schedulers. Add this file to the `cpukit/score/Makefile.am`.

Select or create a Ready queue handler for `foo`.  Add an entry `Foo` to the Queues field of `Ready_queue_Control`. The `Foo` entry will be the data structure used to organize ready threads.  If a new ready queue handler is created, add the new header, inline file, and source files to the cpukit Makefile.am file.

Create a `Scheduler_foo_Per_thread` structure in scheduler.h. Add an entry `foo` of type `Scheduler_foo_Per_thread` to the scheduler field of `Thread_Control`. This structure is used to hold scheduler-specific data about individual threads. It is allocated and freed by the scheduler. It currently is only used when a thread changes priority.  However, more extensive use might be introduced in the future. If the per thread `scheduler` field is used by the `foo` scheduler, create appropriate `allocate`, `update`, and `free` routines.

Add a `_Scheduler_FOO` entry to the define macros in scheduler.h.  The `_Scheduler_XXX` entries are used as indices in an array, so ensure that the value of `_Scheduler_FOO` is unique and matches the location of `CONFIGURE_SCHEDULER_ENTRY_FOO` in the `_Scheduler_Table` array declared in the confdefs.h file (discussed later in this howto).

Add configure options for the `foo` scheduler in confdefs.h. Add or modify the following sections.

Add `foo` to be included if all schedulers are selected:
{{{
  /* enable all RTEMS-provided schedulers */
  #if defined(CONFIGURE_SCHEDULER_ALL)
    #define CONFIGURE_SCHEDULER_PRIORITY
    ...
    #define CONFIGURE_SCHEDULER_FOO
  #endif
}}}

Add a check for `foo` when checking for configured schedulers:
{{{
  /* If no scheduler is specified, the priority scheduler is default. */
  #if !defined(CONFIGURE_SCHEDULER_USER) && \
    !defined(CONFIGURE_SCHEDULER_PRIORITY) && \
    ... && \
    !defined(CONFIGURE_SCHEDULER_FOO)
      #define CONFIGURE_SCHEDULER_PRIORITY
      #define CONFIGURE_SCHEDULER_POLICY _Scheduler_PRIORITY
  #endif
}}}

Add a check to see if the `foo` scheduler should be included:
{{{
/* 
 * Check for priority scheduler next, as it is the default policy if there
 * is no CONFIGURE_SCHEDULER_POLICY set and no USER scheduler provided.
 */
#if defined(CONFIGURE_SCHEDULER_PRIORITY)
  #include <rtems/score/schedulerpriority.h>
  #define CONFIGURE_SCHEDULER_ENTRY_PRIORITY { _Scheduler_priority_Initialize }
  #if !defined(CONFIGURE_SCHEDULER_POLICY)
    #define CONFIGURE_SCHEDULER_POLICY _Scheduler_PRIORITY
  #endif
#endif

...

/* 
 * Check for foo scheduler
 */
#if defined(CONFIGURE_SCHEDULER_FOO)
  #include <rtems/score/schedulerfoo.h>
  #define CONFIGURE_SCHEDULER_ENTRY_FOO { _Scheduler_foo_Initialize }
  #if !defined(CONFIGURE_SCHEDULER_POLICY)
    #define CONFIGURE_SCHEDULER_POLICY _Scheduler_FOO
  #endif
#endif
}}}

Add an entry for the `foo` scheduler in the `_Scheduler_Table` array. Ensure that the entry position corresponds with the value of `_Scheduler_FOO`:
{{{
#ifdef CONFIGURE_INIT
  /* the table of available schedulers. */
  const Scheduler_Table_t _Scheduler_Table[] = {
    #if defined(CONFIGURE_SCHEDULER_USER) && \
        defined(CONFIGURE_SCHEDULER_ENTRY_USER)
      CONFIGURE_SCHEDULER_ENTRY_USER,
    #else
      CONFIGURE_SCHEDULER_NULL,
    #endif
    #if defined(CONFIGURE_SCHEDULER_PRIORITY) && \
        defined(CONFIGURE_SCHEDULER_ENTRY_PRIORITY)
      CONFIGURE_SCHEDULER_ENTRY_PRIORITY,
    #else
      CONFIGURE_SCHEDULER_NULL,
    #endif
    ...
    #if defined(CONFIGURE_SCHEDULER_FOO) && \
        defined(CONFIGURE_SCHEDULER_ENTRY_FOO)
      CONFIGURE_SCHEDULER_ENTRY_FOO,
    #else
      CONFIGURE_SCHEDULER_NULL,
    #endif
  };
#endif
}}}

Write a test case for the new scheduler.  A simple test case is to copy the `ticker` sample application and configure it to use the new scheduler by including `CONFIGURE_SCHEDULER_FOO` during application configuration.
