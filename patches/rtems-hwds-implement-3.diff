diff -uprN -X dontdiff rtems/cpukit/score/cpu/sparc64/rtems/score/sparc64.h rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h
--- rtems/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2010-11-16 18:22:47.000000000 -0500
+++ rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2011-01-10 12:22:39.000000000 -0500
@@ -17,7 +17,7 @@
  *  found in the file LICENSE in this distribution or at
  *  http://www.rtems.com/license/LICENSE.
  *
- *  $Id: sparc64.h,v 1.2 2010/11/16 23:22:47 joel Exp $
+ *  $Id: sparc64.h,v 1.1 2010/06/15 22:43:56 joel Exp $
  */
 
 #ifndef _RTEMS_SCORE_SPARC_H
@@ -145,6 +145,158 @@ extern "C" {
 
 #define STACK_BIAS (2047)
 
+/* Additions to support MAGIC Simics commands */
+#ifdef ASM
+#define MAGIC(n) \
+  sethi n, %g0
+
+#endif /* ASM */
+
+#ifndef ASM
+
+#define __MAGIC_CASSERT(p) do {                                 \
+         typedef int __check_magic_argument[(p) ? 1 : -1];       \
+} while (0)
+
+#define MAGIC(n) do {                                   \
+    __MAGIC_CASSERT((n) > 0 && (n) < (1U << 22));   \
+         __asm__ __volatile__ ("sethi " #n ", %g0");     \
+} while (0)
+
+#define MAGIC_FLUSH(n) do { \
+    __MAGIC_CASSERT((n) > 0 && (n) < (1U << 22));   \
+        __asm__ __volatile__ ("flushw"); \
+         __asm__ __volatile__ ("sethi " #n ", %g0");     \
+} while (0)
+
+
+#endif /* !ASM */
+#define MAGIC_BREAKPOINT MAGIC(0x40000)
+
+
+/*
+ * The following constants are used as the 4 lowest order bits of the 
+ * second register (rs2) passed to the impdep2 instruction in order
+ * to specify the type of HWDS instruction to execute:
+ *
+ *  1   First
+ *  2   Enqueue
+ *  3   Extract
+ *
+ */
+
+#define HWDS_FIRST( _queue, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %1, 20, %%l0\n\t" \
+        "or   %%l0, 1, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_ptr) \
+        : "r" (_queue) : "l0" ); \
+  } while (0)
+
+#define HWDS_ENQUEUE( _queue, _pri, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %0, 20, %%l0\n\t" \
+        "sll  %1, 4, %%l1\n\t" \
+        "or   %%l0, %%l1, %%l0\n\t" \
+        "or   %%l0, 2, %%l0\n\t" \
+        "impdep2  %2, %%l0, %%g0" \
+        : \
+        : "r" (_queue), "r" (_pri), "r" (_ptr) \
+        : "l0" ); \
+  } while (0)
+
+#define HWDS_EXTRACT( _queue, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %1, 20, %%l0\n\t" \
+        "or   %%l0, 3, %%l0\n\t" \
+        "impdep2  %0, %%l0, %%g0" \
+        : \
+        : "r" (_ptr), "r" (_queue) \
+        : "l0" \
+    ); \
+  } while (0)
+
+// TODO: Implement HWDS_FIND
+#define HWDS_FIND( _queue, _ptr, _result ) \
+  do { \
+    __asm__ __volatile__ { \
+      "nop" \
+      : \
+      : \
+      : \
+    }; \
+  } while (0)
+
+// TODO: Implement HWDS_NEXT
+#define HWDS_NEXT( _queue, _ptr, _result ) \
+  do { \
+    __asm__ __volatile__ { \
+      "nop" \
+      : \
+      : \
+      : \
+    }; \
+  } while (0)
+
+// probably could do some type checking.
+#define HWDS1_FIRST( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %%g0, 0, %0\n\t" : "=r" (_ptr) : "0" (_ptr) \
+    ); \
+  } while (0)
+
+#define HWDS1_ENQUEUE( _pri, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %0, 2, %%g0\n\t" \
+        "impdep2  %1, 3, %%g0\n\t" \
+        : "=r" (_pri), "=r" (_ptr) \
+        : "0" (_pri), "1" (_ptr) \
+    ); \
+  } while (0)
+
+// unsupported
+#define HWDS1_ENQUEUE_FIRST( _pri, _ptr ) HWDS1_ENQUEUE (_pri, _ptr)
+
+#define HWDS1_EXTRACT( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %0, 1, %%g0\n\t" : "=r" (_ptr) : "0" (_ptr) \
+    ); \
+  } while (0) 
+
+#define HWDS2_FIRST( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %%g0, (1<<11)|0, %0\n\t" : "=r" (_ptr) : "0" (_ptr) \
+    ); \
+  } while (0)
+
+#define HWDS2_ENQUEUE( _pri, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %0, (1<<11)|2, %%g0\n\t" \
+        "impdep2  %1, (1<<11)|3, %%g0\n\t" \
+        : "=r" (_pri), "=r" (_ptr) \
+        : "0" (_pri), "1" (_ptr) \
+    ); \
+  } while (0)
+
+// unsupported
+#define HWDS2_ENQUEUE_FIRST( _pri, _ptr ) HWDS2_ENQUEUE (_pri, _ptr)
+
+#define HWDS2_EXTRACT( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %0, (1<<11)|1, %%g0\n\t" : "=r" (_ptr) : "0" (_ptr) \
+    ); \
+  } while (0) 
+
 #ifdef ASM
 
 /* 
