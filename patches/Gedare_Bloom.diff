diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/posix/src/sched_yield.c rtems/cpukit/posix/src/sched_yield.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/posix/src/sched_yield.c	2007-12-13 11:52:21.000000000 -0500
+++ rtems/cpukit/posix/src/sched_yield.c	2010-07-08 13:33:01.000000000 -0400
@@ -19,6 +19,7 @@
 #include <errno.h>
 
 #include <rtems/system.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/tod.h>
 #include <rtems/score/thread.h>
 #include <rtems/seterr.h>
@@ -28,7 +29,7 @@
 int sched_yield( void )
 {
   _Thread_Disable_dispatch();
-    _Thread_Yield_processor();
+    _Scheduler_Yield();
   _Thread_Enable_dispatch();
   return 0;
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/include/rtems/rtems/periodic.h rtems/cpukit/rtems/include/rtems/rtems/periodic.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/include/rtems/rtems/periodic.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/include/rtems/rtems/periodic.h	2010-07-22 16:20:08.000000000 -0400
@@ -0,0 +1,248 @@
+/**
+ * @file rtems/rtems/periodic.h
+ *
+ *  This include file contains all the public constants, structures, and
+ *  prototypes associated with the Periodic Manager.  This manager
+ *  provides facilities to implement threads which execute in a periodic
+ *  fashion.
+ *
+ *  Directives provided are:
+ *
+ *     - create a periodic timer
+ *     - cancel a period
+ *     - delete a periodic timer
+ *     - conclude current and start the next period
+ *     - obtain status information on a period
+ */
+
+/*  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  Copyright (c) 2010 Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_RTEMS_PERIODIC_H
+#define _RTEMS_RTEMS_PERIODIC_H
+
+/**
+ *  @defgroup ClassicPeriodic Periodic Manager
+ *
+ *  @ingroup ClassicRTEMS
+ *
+ *  This encapsulates functionality related to the
+ *  Classic API Periodic Manager.
+ *
+ *  Statistics are kept for each period and can be obtained or printed via
+ *  API calls.  The statistics kept include minimum, maximum and average times
+ *  for both cpu usage and wall time.  The statistics indicate the execution time
+ *  used by the owning thread between successive calls to rtems_periodic_period.
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *  This is the public type used for the periodic timing
+ *  statistics.
+ */
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  #include <rtems/score/timespec.h>
+
+  typedef struct timespec rtems_periodic_period_time_t;
+#else
+  typedef uint32_t rtems_periodic_period_time_t;
+#endif
+
+#include <rtems/score/periodic.h>
+
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+
+#include <string.h>
+
+typedef Periodic_Period_states rtems_periodic_period_states;
+
+/**
+ *  The following defines the PUBLIC data structure that has the
+ *  statistics kept on each period instance.
+ *
+ *  @note The public structure uses struct timespec while the
+ *        internal one uses Timestamp_Control.
+ */
+typedef struct {
+  /** This field contains the number of periods executed. */
+  uint32_t     count;
+  /** This field contains the number of periods missed. */
+  uint32_t     missed_count;
+
+  /** This field contains the least amount of CPU time used in a period. */
+  rtems_thread_cpu_usage_t             min_cpu_time;
+  /** This field contains the highest amount of CPU time used in a period. */
+  rtems_thread_cpu_usage_t             max_cpu_time;
+  /** This field contains the total amount of wall time used in a period. */
+  rtems_thread_cpu_usage_t             total_cpu_time;
+
+  /** This field contains the least amount of wall time used in a period. */
+  rtems_periodic_period_time_t         min_wall_time;
+  /** This field contains the highest amount of wall time used in a period. */
+  rtems_periodic_period_time_t         max_wall_time;
+  /** This field contains the total amount of CPU time used in a period. */
+  rtems_periodic_period_time_t         total_wall_time;
+}  rtems_periodic_period_statistics;
+
+/**
+ *  The following defines the period status structure.
+ */
+typedef struct {
+  /** This is the Id of the thread using this period. */
+  rtems_id                             owner;
+
+  /** This is the current state of this period. */
+  rtems_periodic_period_states         state;
+
+  /**
+   *  This is the length of wall time that has passed since this period
+   *  was last initiated.  If the period is expired or has not been initiated,
+   *  then this field has no meaning.
+   */
+  rtems_periodic_period_time_t         since_last_period;
+
+  /**
+   *  This is the amount of CPU time that has been used since this period
+   *  was last initiated.  If the period is expired or has not been initiated,
+   *  then this field has no meaning.
+   */
+  rtems_thread_cpu_usage_t             executed_since_last_period;
+}  rtems_periodic_period_status;
+
+
+/**
+ *  @brief rtems_periodic_create
+ *
+ *  This routine implements the periodic_create directive.  The
+ *  period will have the name name.  It returns the id of the
+ *  created period in ID.
+ */
+rtems_status_code rtems_periodic_create(
+  rtems_name    name,
+  rtems_id     *id
+);
+
+/**
+ *  @brief rtems_periodic_ident
+ *
+ *  This routine implements the rtems_periodic_ident directive.
+ *  It returns the period ID associated with name.  If more than one period
+ *  is named name, then the period to which the ID belongs is arbitrary.
+ */
+rtems_status_code rtems_periodic_ident(
+  rtems_name    name,
+  rtems_id     *id
+);
+
+/**
+ *  @brief rtems_periodic_cancel
+ *
+ *  This routine implements the rtems_periodic_cancel directive.  This
+ *  directive stops the period associated with ID from continuing to
+ *  run.
+ */
+rtems_status_code rtems_periodic_cancel(
+  rtems_id   id
+);
+
+/**
+ *  @brief rtems_periodic_delete
+ *
+ *  This routine implements the rtems_periodic_delete directive.  The
+ *  period indicated by ID is deleted.
+ */
+rtems_status_code rtems_periodic_delete(
+  rtems_id   id
+);
+
+/**
+ *  @brief rtems_periodic_get_status
+ *
+ *  This routine implements the rtems_periodic_get_status directive.
+ *  Information about the period indicated by ID is returned.
+ *
+ */
+rtems_status_code rtems_periodic_get_status(
+  rtems_id                             id,
+  rtems_periodic_period_status  *status
+);
+
+/**
+ *  @brief rtems_periodic_get_statistics
+ *
+ *  This routine implements the rtems_periodic_get_statistics directive.
+ *  Statistics gathered from the use of this period are returned.
+ */
+rtems_status_code rtems_periodic_get_statistics(
+  rtems_id                                id,
+  rtems_periodic_period_statistics *statistics
+);
+
+/**
+ *  @brief rtems_periodic_reset_statistics
+ *
+ *  This routine allows a thread to reset the statistics information
+ *  on a specific period instance.
+ */
+rtems_status_code rtems_periodic_reset_statistics(
+  rtems_id                                 id
+);
+
+/**
+ *  @brief rtems_periodic_reset_all_statistics
+ *
+ *  This routine allows a thread to reset the statistics information
+ *  on ALL period instances.
+ */
+void rtems_periodic_reset_all_statistics( void );
+
+/**
+ *  @brief rtems_periodic_report_statistics
+ *
+ *  This routine allows a thread to print the statistics information
+ *  on ALL period instances which have non-zero counts using printk.
+ */
+void rtems_periodic_report_statistics_with_plugin(
+  void                  *context,
+  rtems_printk_plugin_t  print
+);
+
+/**
+ *  @brief rtems_periodic_report_statistics
+ *
+ *  This routine allows a thread to print the statistics information
+ *  on ALL period instances which have non-zero counts using printk.
+ */
+void rtems_periodic_report_statistics( void );
+
+/**
+ *  @brief rtems_periodic_period
+ *
+ *  This routine implements the rtems_periodic_period directive.  When
+ *  length is non-zero, this directive initiates the period associated with
+ *  ID from continuing for a period of length.  If length is zero, then
+ *  result is set to indicate the current state of the period.
+ */
+rtems_status_code rtems_periodic_period(
+  rtems_id        id,
+  rtems_interval  length
+);
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/include/rtems/rtems/ratemon.h rtems/cpukit/rtems/include/rtems/rtems/ratemon.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/include/rtems/rtems/ratemon.h	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/include/rtems/rtems/ratemon.h	2010-07-22 16:57:40.000000000 -0400
@@ -28,16 +28,6 @@
 #ifndef _RTEMS_RTEMS_RATEMON_H
 #define _RTEMS_RTEMS_RATEMON_H
 
-/**
- *  This constant is defined to extern most of the time when using
- *  this header file.  However by defining it to nothing, the data
- *  declared in this header file can be instantiated.  This is done
- *  in a single per manager file.
- */
-#ifndef RTEMS_RATEMON_EXTERN
-#define RTEMS_RATEMON_EXTERN extern
-#endif
-
 #include <rtems/bspIo.h>
 
 /**
@@ -59,220 +49,21 @@
 extern "C" {
 #endif
 
-/**
- *  This is the public type used for the rate monotonic timing
- *  statistics.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #include <rtems/score/timespec.h>
-
-  typedef struct timespec rtems_rate_monotonic_period_time_t;
-#else
-  typedef uint32_t rtems_rate_monotonic_period_time_t;
-#endif
-
-/**
- *  This is the internal type used for the rate monotonic timing
- *  statistics.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #include <rtems/score/timestamp.h>
-
-  typedef Timestamp_Control Rate_monotonic_Period_time_t;
-#else
-  typedef uint32_t Rate_monotonic_Period_time_t;
-#endif
-
-#include <rtems/score/object.h>
-#include <rtems/score/thread.h>
-#include <rtems/score/watchdog.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/status.h>
 #include <rtems/rtems/support.h>
 
+#include <rtems/score/periodic.h>
+
 #include <string.h>
 
+typedef rtems_periodic_period_states rtems_rate_monotonic_period_states; 
 
-/**
- *  The following enumerated type defines the states in which a
- *  period may be.
- */
-typedef enum {
-  /**
-   * This value indicates the period is off the watchdog chain,
-   * and has never been initialized.
-   */
-  RATE_MONOTONIC_INACTIVE,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * the owner is blocked waiting on it.
-   */
-  RATE_MONOTONIC_OWNER_IS_BLOCKING,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * running.  The owner should be executed or blocked waiting on
-   * another object.
-   */
-  RATE_MONOTONIC_ACTIVE,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * has expired.  The owner should be blocked waiting for the next period.
-   */
-  RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING,
-
-  /**
-   * This value indicates the period is off the watchdog chain, and
-   * has expired.  The owner is still executing and has taken too much
-   * all time to complete this iteration of the period.
-   */
-  RATE_MONOTONIC_EXPIRED
-}   rtems_rate_monotonic_period_states;
-
-/**
- *  The following constant is the interval passed to the rate_monontonic_period
- *  directive to obtain status information.
- */
-#define RTEMS_PERIOD_STATUS       WATCHDOG_NO_TIMEOUT
-
-/**
- *  The following defines the PUBLIC data structure that has the
- *  statistics kept on each period instance.
- *
- *  @note The public structure uses struct timespec while the
- *        internal one uses Timestamp_Control.
- */
-typedef struct {
-  /** This field contains the number of periods executed. */
-  uint32_t     count;
-  /** This field contains the number of periods missed. */
-  uint32_t     missed_count;
-
-  /** This field contains the least amount of CPU time used in a period. */
-  rtems_thread_cpu_usage_t             min_cpu_time;
-  /** This field contains the highest amount of CPU time used in a period. */
-  rtems_thread_cpu_usage_t             max_cpu_time;
-  /** This field contains the total amount of wall time used in a period. */
-  rtems_thread_cpu_usage_t             total_cpu_time;
-
-  /** This field contains the least amount of wall time used in a period. */
-  rtems_rate_monotonic_period_time_t   min_wall_time;
-  /** This field contains the highest amount of wall time used in a period. */
-  rtems_rate_monotonic_period_time_t   max_wall_time;
-  /** This field contains the total amount of CPU time used in a period. */
-  rtems_rate_monotonic_period_time_t   total_wall_time;
-}  rtems_rate_monotonic_period_statistics;
-
-/**
- *  The following defines the INTERNAL data structure that has the
- *  statistics kept on each period instance.
- */
-typedef struct {
-  /** This field contains the number of periods executed. */
-  uint32_t     count;
-  /** This field contains the number of periods missed. */
-  uint32_t     missed_count;
-
-  /** This field contains the least amount of CPU time used in a period. */
-  Thread_CPU_usage_t                   min_cpu_time;
-  /** This field contains the highest amount of CPU time used in a period. */
-  Thread_CPU_usage_t                   max_cpu_time;
-  /** This field contains the total amount of wall time used in a period. */
-  Thread_CPU_usage_t                   total_cpu_time;
-
-  /** This field contains the least amount of wall time used in a period. */
-  Rate_monotonic_Period_time_t         min_wall_time;
-  /** This field contains the highest amount of wall time used in a period. */
-  Rate_monotonic_Period_time_t         max_wall_time;
-  /** This field contains the total amount of CPU time used in a period. */
-  Rate_monotonic_Period_time_t         total_wall_time;
-}  Rate_monotonic_Statistics;
-
-/**
- *  The following defines the period status structure.
- */
-typedef struct {
-  /** This is the Id of the thread using this period. */
-  rtems_id                             owner;
-
-  /** This is the current state of this period. */
-  rtems_rate_monotonic_period_states   state;
-
-  /**
-   *  This is the length of wall time that has passed since this period
-   *  was last initiated.  If the period is expired or has not been initiated,
-   *  then this field has no meaning.
-   */
-  rtems_rate_monotonic_period_time_t   since_last_period;
-
-  /**
-   *  This is the amount of CPU time that has been used since this period
-   *  was last initiated.  If the period is expired or has not been initiated,
-   *  then this field has no meaning.
-   */
-  rtems_thread_cpu_usage_t             executed_since_last_period;
-}  rtems_rate_monotonic_period_status;
-
-/**
- *  The following structure defines the control block used to manage
- *  each period.
- */
-typedef struct {
-  /** This field is the object management portion of a Period instance. */
-  Objects_Control                         Object;
-
-  /** This is the timer used to provide the unblocking mechanism. */
-  Watchdog_Control                        Timer;
-
-  /** This field indicates the current state of the period. */
-  rtems_rate_monotonic_period_states      state;
-
-  /**
-   * This field contains the length of the next period to be
-   * executed.
-   */
-  uint32_t                                next_length;
-
-  /**
-   * This field contains a pointer to the TCB for the thread
-   * which owns and uses this period instance.
-   */
-  Thread_Control                         *owner;
-
-  /**
-   * This field contains the cpu usage value of the owning thread when
-   * the period was initiated.  It is used to compute the period's
-   * statistics.
-   */
-  Thread_CPU_usage_t                      cpu_usage_period_initiated;
-
-  /**
-   * This field contains the wall time value when the period
-   * was initiated.  It is used to compute the period's statistics.
-   */
-  Rate_monotonic_Period_time_t            time_period_initiated;
-
-  /**
-   * This field contains the statistics maintained for the period.
-   */
-  Rate_monotonic_Statistics               Statistics;
-}   Rate_monotonic_Control;
+typedef rtems_periodic_period_statistics rtems_rate_monotonic_period_statistics;
 
-/**
- *  @brief Rate Monotonic Period Class Management Structure
- *
- *  This instance of Objects_Information is used to manage the
- *  set of rate monotonic period instances.
- */
-RTEMS_RATEMON_EXTERN Objects_Information _Rate_monotonic_Information;
+typedef rtems_periodic_period_status rtems_rate_monotonic_period_status; 
 
-/**
- *  @brief Rate Monotonic Manager Initialization
- *
- *  This routine performs the initialization necessary for this manager.
- */
-void _Rate_monotonic_Manager_initialization(void);
+typedef Periodic_Control Rate_monotonic_Control;
 
 /**
  *  @brief rtems_rate_monotonic_create
@@ -393,115 +184,12 @@ rtems_status_code rtems_rate_monotonic_p
 );
 
 /**
- *  @brief _Rate_monotonic_Timeout
- *
- *  This routine is invoked when the period represented
- *  by ID expires.  If the thread which owns this period is blocked
- *  waiting for the period to expire, then it is readied and the
- *  period is restarted.  If the owning thread is not waiting for the
- *  period to expire, then the period is placed in the EXPIRED
- *  state and not restarted.
- */
-void _Rate_monotonic_Timeout(
-  rtems_id    id,
-  void       *ignored
-);
-
-/**
- *  @brief _Rate_monotonic_Get_status(
- *
- *  This routine is invoked to compute the elapsed wall time and cpu
- *  time for a period.
- *
- *  @param[in] the_period points to the period being operated upon.
- *  @param[out] wall_since_last_period is set to the wall time elapsed
- *              since the period was initiated.
- *  @param[out] cpu_since_last_period is set to the cpu time used by the
- *              owning thread since the period was initiated.
- *
- *  @return This routine returns true if the status can be determined
- *          and false otherwise.
- */
-bool _Rate_monotonic_Get_status(
-  Rate_monotonic_Control        *the_period,
-  Rate_monotonic_Period_time_t  *wall_since_last_period,
-  Thread_CPU_usage_t            *cpu_since_last_period
-);
-
-/**
- *  @brief _Rate_monotonic_Initiate_statistics(
- *
- *  This routine is invoked when a period is initiated via an explicit
- *  call to rtems_rate_monotonic_period for the period's first iteration
- *  or from _Rate_monotonic_Timeout for period iterations 2-n.
- *
- *  @param[in] the_period points to the period being operated upon.
- */
-void _Rate_monotonic_Initiate_statistics(
-  Rate_monotonic_Control *the_period
-);
-
-/**
- *  @brief _Rate_monotonic_Reset_wall_time_statistics
- *
- *  This method resets the statistics information for a period instance.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #define _Rate_monotonic_Reset_wall_time_statistics( _the_period ) \
-     do { \
-        /* set the minimums to a large value */ \
-        _Timestamp_Set( \
-          &(_the_period)->Statistics.min_wall_time, \
-          0x7fffffff, \
-          0x7fffffff \
-        ); \
-     } while (0)
-#else
-  #define _Rate_monotonic_Reset_wall_time_statistics( _the_period ) \
-     do { \
-        /* set the minimum to a large value */ \
-        (_the_period)->Statistics.min_wall_time = 0xffffffff; \
-     } while (0)
-#endif
-
-/**
- *  @brief Rate_monotonic_Reset_cpu_use_statistics
+ *  @brief Rate Monotonic Manager Initialization
  *
- *  This helper method resets the period CPU usage statistics structure.
+ *  This routine performs the initialization necessary for this manager.
  */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #define _Rate_monotonic_Reset_cpu_use_statistics( _the_period ) \
-     do { \
-        /* set the minimums to a large value */ \
-        _Timestamp_Set( \
-          &(_the_period)->Statistics.min_cpu_time, \
-          0x7fffffff, \
-          0x7fffffff \
-        ); \
-     } while (0)
-#else
-  #define _Rate_monotonic_Reset_cpu_use_statistics( _the_period ) \
-     do { \
-        /* set the minimum to a large value */ \
-        (_the_period)->Statistics.min_cpu_time = 0xffffffff; \
-     } while (0)
-#endif
+void _Rate_monotonic_Manager_initialization(void);
 
-/**
- *  @brief Rate_monotonic_Reset_statistics
- *
- *  This helper method resets the period wall time statistics structure.
- */
-#define _Rate_monotonic_Reset_statistics( _the_period ) \
-  do { \
-    memset( \
-      &(_the_period)->Statistics, \
-      0, \
-      sizeof( rtems_rate_monotonic_period_statistics ) \
-    ); \
-    _Rate_monotonic_Reset_cpu_use_statistics( _the_period ); \
-    _Rate_monotonic_Reset_wall_time_statistics( _the_period ); \
-  } while (0)
 
 #ifndef __RTEMS_APPLICATION__
 #include <rtems/rtems/ratemon.inl>
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/inline/rtems/rtems/ratemon.inl rtems/cpukit/rtems/inline/rtems/rtems/ratemon.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/inline/rtems/rtems/ratemon.inl	2008-09-04 13:43:18.000000000 -0400
+++ rtems/cpukit/rtems/inline/rtems/rtems/ratemon.inl	2010-07-22 15:58:29.000000000 -0400
@@ -27,99 +27,7 @@
  *  @{
  */
 
-/**
- *  @brief Rate_monotonic_Allocate
- *
- *  This function allocates a period control block from
- *  the inactive chain of free period control blocks.
- */
-RTEMS_INLINE_ROUTINE Rate_monotonic_Control *_Rate_monotonic_Allocate( void )
-{
-  return (Rate_monotonic_Control *)
-    _Objects_Allocate( &_Rate_monotonic_Information );
-}
-
-/**
- *  @brief Rate_monotonic_Free
- *
- *  This routine allocates a period control block from
- *  the inactive chain of free period control blocks.
- */
-RTEMS_INLINE_ROUTINE void _Rate_monotonic_Free (
-  Rate_monotonic_Control *the_period
-)
-{
-  _Objects_Free( &_Rate_monotonic_Information, &the_period->Object );
-}
-
-/**
- *  @brief Rate_monotonic_Get
- *
- *  This function maps period IDs to period control blocks.
- *  If ID corresponds to a local period, then it returns
- *  the_period control pointer which maps to ID and location
- *  is set to OBJECTS_LOCAL.  Otherwise, location is set
- *  to OBJECTS_ERROR and the_period is undefined.
- */
-RTEMS_INLINE_ROUTINE Rate_monotonic_Control *_Rate_monotonic_Get (
-  Objects_Id         id,
-  Objects_Locations *location
-)
-{
-  return (Rate_monotonic_Control *)
-    _Objects_Get( &_Rate_monotonic_Information, id, location );
-}
-
-/**
- *  @brief Rate_monotonic_Is_active
- *
- *  This function returns TRUE if the_period is in the ACTIVE state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_active (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_ACTIVE);
-}
-
-/**
- *  @brief Rate_monotonic_Is_inactive
- *
- *  This function returns TRUE if the_period is in the ACTIVE state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_inactive (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_INACTIVE);
-}
 
-/**
- *  @brief Rate_monotonic_Is_expired
- *
- *  This function returns TRUE if the_period is in the EXPIRED state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_expired (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_EXPIRED);
-}
-
-/**
- *  @brief Rate_monotonic_Is_null
- *
- *  This function returns TRUE if the_period is NULL and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_null (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period == NULL);
-}
 
 /**@}*/
 
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/Makefile.am rtems/cpukit/rtems/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/Makefile.am	2010-08-11 14:25:06.000000000 -0400
+++ rtems/cpukit/rtems/Makefile.am	2010-08-13 11:44:28.000000000 -0400
@@ -25,6 +25,7 @@ include_rtems_rtems_HEADERS = include/rt
     include/rtems/rtems/intr.h include/rtems/rtems/message.h \
     include/rtems/rtems/modes.h include/rtems/rtems/object.h \
     include/rtems/rtems/options.h include/rtems/rtems/part.h \
+		include/rtems/rtems/periodic.h \
     include/rtems/rtems/ratemon.h include/rtems/rtems/region.h \
     include/rtems/rtems/rtemsapi.h include/rtems/rtems/sem.h \
     include/rtems/rtems/signal.h include/rtems/rtems/status.h \
@@ -71,12 +72,19 @@ librtems_a_SOURCES += src/tasks.c src/ta
     src/taskvariableadd.c src/taskvariabledelete.c src/taskvariableget.c \
     src/taskvariable_invoke_dtor.c src/taskdata.c
 
+## PERIODIC_C_FILES
+librtems_a_SOURCES += src/periodiccancel.c src/periodicident.c \
+		src/periodiccreate.c src/periodicperiod.c src/periodicdelete.c \
+		src/periodicreportstatistics.c src/periodicgetstatistics.c \
+		src/periodicresetall.c src/periodicgetstatus.c \
+		src/periodicresetstatistics.c
+
 ## RATEMON_C_FILES
 librtems_a_SOURCES += src/ratemon.c src/ratemoncancel.c src/ratemoncreate.c \
     src/ratemondelete.c src/ratemongetstatus.c src/ratemongetstatistics.c \
     src/ratemonresetstatistics.c src/ratemonresetall.c \
     src/ratemonreportstatistics.c src/ratemonident.c \
-    src/ratemonperiod.c src/ratemontimeout.c src/ratemondata.c
+    src/ratemonperiod.c src/ratemondata.c
 
 ## INTR_C_FILES
 librtems_a_SOURCES += src/intrbody.c src/intrcatch.c
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/preinstall.am rtems/cpukit/rtems/preinstall.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/preinstall.am	2010-08-11 14:25:06.000000000 -0400
+++ rtems/cpukit/rtems/preinstall.am	2010-08-13 11:51:18.000000000 -0400
@@ -87,6 +87,10 @@ $(PROJECT_INCLUDE)/rtems/rtems/part.h: i
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/part.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/part.h
 
+$(PROJECT_INCLUDE)/rtems/rtems/periodic.h: include/rtems/rtems/periodic.h $(PROJECT_INCLUDE)/rtems/rtems/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/periodic.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/periodic.h
+
 $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h: include/rtems/rtems/ratemon.h $(PROJECT_INCLUDE)/rtems/rtems/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodiccancel.c rtems/cpukit/rtems/src/periodiccancel.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodiccancel.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodiccancel.c	2010-07-22 15:31:04.000000000 -0400
@@ -0,0 +1,68 @@
+/*
+ *  Periodic Manager -- Cancel a Period
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_cancel
+ *
+ *  This directive allows a thread to cancel a periodic timer.
+ *
+ *  Input parameters:
+ *    id - periodic id
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful and caller is not the owning thread
+ *    error code       - if unsuccessful
+ */
+
+rtems_status_code rtems_periodic_cancel(
+  rtems_id id
+)
+{
+  Periodic_Control *the_period;
+  Objects_Locations       location;
+
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      if ( !_Thread_Is_executing( the_period->owner ) ) {
+        _Thread_Enable_dispatch();
+        return RTEMS_NOT_OWNER_OF_RESOURCE;
+      }
+      (void) _Watchdog_Remove( &the_period->Timer );
+      the_period->state = PERIODIC_INACTIVE;
+      _Thread_Enable_dispatch();
+      return RTEMS_SUCCESSFUL;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodiccreate.c rtems/cpukit/rtems/src/periodiccreate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodiccreate.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodiccreate.c	2010-07-22 16:35:45.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ *  Periodic Manager -- Create a Period
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_create
+ *
+ *  This directive creates a periodic timer and performs
+ *  some initialization.
+ *
+ *  Input parameters:
+ *    name - name of period
+ *    id   - pointer to periodic id
+ *
+ *  Output parameters:
+ *    id               - periodic id
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ */
+
+rtems_status_code rtems_periodic_create(
+  rtems_name  name,
+  rtems_id   *id
+)
+{
+  Periodic_Control *the_period;
+
+  if ( !rtems_is_name_valid( name ) )
+    return RTEMS_INVALID_NAME;
+
+  if ( !id )
+    return RTEMS_INVALID_ADDRESS;
+
+  _Thread_Disable_dispatch();            /* to prevent deletion */
+
+  the_period = _Periodic_Allocate();
+
+  if ( !the_period ) {
+    _Thread_Enable_dispatch();
+    return RTEMS_TOO_MANY;
+  }
+
+  the_period->owner = _Thread_Executing;
+  the_period->state = PERIODIC_INACTIVE;
+
+  /* TODO: set periodic flag */
+
+  _Watchdog_Initialize( &the_period->Timer, NULL, 0, NULL );
+
+  _Periodic_Reset_statistics( the_period );
+
+  _Objects_Open(
+    &_Periodic_Information,
+    &the_period->Object,
+    (Objects_Name) name
+  );
+
+  *id = the_period->Object.id;
+  _Thread_Enable_dispatch();
+  return RTEMS_SUCCESSFUL;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicdelete.c rtems/cpukit/rtems/src/periodicdelete.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicdelete.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicdelete.c	2010-07-22 15:19:00.000000000 -0400
@@ -0,0 +1,67 @@
+/*
+ *  Periodic Manager -- Delete a Period
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_delete
+ *
+ *  This directive allows a thread to delete a periodic timer.
+ *
+ *  Input parameters:
+ *    id - periodic id
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ */
+
+rtems_status_code rtems_periodic_delete(
+  rtems_id id
+)
+{
+  Periodic_Control *the_period;
+  Objects_Locations       location;
+
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      _Objects_Close( &_Periodic_Information, &the_period->Object );
+      (void) _Watchdog_Remove( &the_period->Timer );
+      the_period->state = PERIODIC_INACTIVE;
+      _Periodic_Free( the_period );
+      _Thread_Enable_dispatch();
+      return RTEMS_SUCCESSFUL;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:            /* should never return this */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicgetstatistics.c rtems/cpukit/rtems/src/periodicgetstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicgetstatistics.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicgetstatistics.c	2010-07-22 15:17:17.000000000 -0400
@@ -0,0 +1,92 @@
+/*
+ *  Periodic Manager -- Get Statistics
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_get_statistics
+ *
+ *  This directive allows a thread to obtain statistics information on a
+ *  period.
+ *
+ *  Input parameters:
+ *    id         - periodic id
+ *    statistics - pointer to statistics control block
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ *
+ */
+
+rtems_status_code rtems_periodic_get_statistics(
+  rtems_id                                id,
+  rtems_periodic_period_statistics *statistics
+)
+{
+  Objects_Locations                        location;
+  Periodic_Control                  *the_period;
+  rtems_periodic_period_statistics  *dst;
+  Periodic_Statistics               *src;
+
+  if ( !statistics )
+    return RTEMS_INVALID_ADDRESS;
+
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      dst = statistics;
+      src = &the_period->Statistics;
+      dst->count        = src->count;
+      dst->missed_count = src->missed_count;
+      #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+        _Timestamp_To_timespec( &src->min_cpu_time,   &dst->min_cpu_time );
+        _Timestamp_To_timespec( &src->max_cpu_time,   &dst->max_cpu_time );
+        _Timestamp_To_timespec( &src->total_cpu_time, &dst->total_cpu_time );
+        _Timestamp_To_timespec( &src->min_wall_time,   &dst->min_wall_time );
+        _Timestamp_To_timespec( &src->max_wall_time,   &dst->max_wall_time );
+        _Timestamp_To_timespec( &src->total_wall_time, &dst->total_wall_time );
+      #else
+        dst->min_cpu_time    = src->min_cpu_time;
+        dst->max_cpu_time    = src->max_cpu_time;
+        dst->total_cpu_time  = src->total_cpu_time;
+        dst->min_wall_time   = src->min_wall_time;
+        dst->max_wall_time   = src->max_wall_time;
+        dst->total_wall_time = src->total_wall_time;
+      #endif
+
+      _Thread_Enable_dispatch();
+      return RTEMS_SUCCESSFUL;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:            /* should never return this */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicgetstatus.c rtems/cpukit/rtems/src/periodicgetstatus.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicgetstatus.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicgetstatus.c	2010-07-22 15:18:45.000000000 -0400
@@ -0,0 +1,119 @@
+/*
+ *  Periodic Manager -- Get Status
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  #include <rtems/score/timespec.h>
+#endif
+
+/*PAGE
+ *
+ *  rtems_periodic_get_status
+ *
+ *  This directive allows a thread to obtain status information on a
+ *  period.
+ *
+ *  Input parameters:
+ *    id     - periodic id
+ *    status - pointer to status control block
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ *
+ */
+
+rtems_status_code rtems_periodic_get_status(
+  rtems_id                            id,
+  rtems_periodic_period_status *status
+)
+{
+  Thread_CPU_usage_t             executed;
+  Objects_Locations              location;
+  Periodic_Period_time_t   since_last_period;
+  Periodic_Control        *the_period;
+  bool                           valid_status;
+
+  if ( !status )
+    return RTEMS_INVALID_ADDRESS;
+
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      status->owner = the_period->owner->Object.id;
+      status->state = the_period->state;
+
+      /*
+       *  If the period is inactive, there is no information.
+       */
+      if ( status->state == PERIODIC_INACTIVE ) {
+        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          _Timespec_Set_to_zero( &status->since_last_period );
+          _Timespec_Set_to_zero( &status->executed_since_last_period );
+        #else
+          status->since_last_period = 0;
+          status->executed_since_last_period = 0;
+        #endif
+
+      } else {
+
+        /*
+         *  Grab the current status.
+         */
+        valid_status =
+          _Periodic_Get_status(
+            the_period, &since_last_period, &executed
+          );
+        if (!valid_status) {
+          _Thread_Enable_dispatch();
+          return RTEMS_NOT_DEFINED;
+        }
+
+        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          _Timestamp_To_timespec(
+            &since_last_period, &status->since_last_period
+          );
+          _Timestamp_To_timespec(
+            &executed, &status->executed_since_last_period
+          );
+        #else
+          status->since_last_period = since_last_period;
+          status->executed_since_last_period = executed;
+        #endif
+      }
+
+      _Thread_Enable_dispatch();
+      return RTEMS_SUCCESSFUL;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:            /* should never return this */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicident.c rtems/cpukit/rtems/src/periodicident.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicident.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicident.c	2010-07-22 15:19:42.000000000 -0400
@@ -0,0 +1,59 @@
+/*
+ *  Periodic Manager -- Name to Id Lookup
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_ident
+ *
+ *  This directive returns the system ID associated with
+ *  the periodic period name.
+ *
+ *  Input parameters:
+ *    name - user defined period name
+ *    id   - pointer to period id
+ *
+ *  Output parameters:
+ *    *id              - region id
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ */
+
+rtems_status_code rtems_periodic_ident(
+  rtems_name  name,
+  rtems_id   *id
+)
+{
+  Objects_Name_or_id_lookup_errors  status;
+
+  status = _Objects_Name_to_id_u32(
+    &_Periodic_Information,
+    name,
+    OBJECTS_SEARCH_LOCAL_NODE,
+    id
+  );
+
+  return _Status_Object_name_errors_to_status[ status ];
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicperiod.c rtems/cpukit/rtems/src/periodicperiod.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicperiod.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicperiod.c	2010-07-29 12:38:45.000000000 -0400
@@ -0,0 +1,182 @@
+/*
+ *  Periodic Manager - Period Blocking
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/periodic.h>
+#include <rtems/score/scheduleredf.h>
+#include <rtems/score/thread.h>
+
+
+/*PAGE
+ *
+ *  rtems_periodic_period
+ *
+ *  This directive allows a thread to manipulate a periodic timer.
+ *
+ *  Input parameters:
+ *    id     - periodic id
+ *    length - length of period (in ticks)
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ */
+
+rtems_status_code rtems_periodic_period(
+  rtems_id       id,
+  rtems_interval length
+)
+{
+  Periodic_Control              *the_period;
+  Objects_Locations                    location;
+  rtems_status_code                    return_value;
+  rtems_periodic_period_states   local_state;
+  ISR_Level                            level;
+
+  the_period = _Periodic_Get( id, &location );
+
+  switch ( location ) {
+    case OBJECTS_LOCAL:
+      if ( !_Thread_Is_executing( the_period->owner ) ) {
+        _Thread_Enable_dispatch();
+        return RTEMS_NOT_OWNER_OF_RESOURCE;
+      }
+
+      if ( length == RTEMS_PERIOD_STATUS ) {
+        switch ( the_period->state ) {
+          case PERIODIC_INACTIVE:
+            return_value = RTEMS_NOT_DEFINED;
+            break;
+          case PERIODIC_EXPIRED:
+          case PERIODIC_EXPIRED_WHILE_BLOCKING:
+            return_value = RTEMS_TIMEOUT;
+            break;
+          case PERIODIC_ACTIVE:
+          default:              /* unreached -- only to remove warnings */
+            return_value = RTEMS_SUCCESSFUL;
+            break;
+        }
+        _Thread_Enable_dispatch();
+        return( return_value );
+      }
+
+      _ISR_Disable( level );
+      if ( the_period->state == PERIODIC_INACTIVE ) {
+
+        _ISR_Enable( level );
+
+        /*
+         *  Baseline statistics information for the beginning of a period.
+         */
+        _Periodic_Initiate_statistics( the_period );
+
+        the_period->state = PERIODIC_ACTIVE;
+        _Watchdog_Initialize(
+            &the_period->Timer,
+            _Periodic_Timeout,
+            id,
+            NULL
+            );
+
+        the_period->next_length = length;
+
+        _Watchdog_Insert_ticks( &the_period->Timer, length );
+        _Thread_Enable_dispatch();
+        return RTEMS_SUCCESSFUL;
+      }
+
+      if ( the_period->state == PERIODIC_ACTIVE ) {
+        /*
+         *  Update statistics from the concluding period.
+         */
+        _Periodic_Update_statistics( the_period );
+
+        /* TODO: scheduler-specific job completion call-out */
+
+        /*
+         *  This tells the _Periodic_Timeout that this task is
+         *  in the process of blocking on the period and that we
+         *  may be changing the length of the next period.
+         */
+        the_period->state = PERIODIC_OWNER_IS_BLOCKING;
+        the_period->next_length = length;
+
+        _ISR_Enable( level );
+
+        _Thread_Executing->Wait.id = the_period->Object.id;
+        _Thread_Set_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
+
+        /*
+         *  Did the watchdog timer expire while we were actually blocking
+         *  on it?
+         */
+        _ISR_Disable( level );
+        local_state = the_period->state;
+        the_period->state = PERIODIC_ACTIVE;
+        _ISR_Enable( level );
+
+        /*
+         *  If it did, then we want to unblock ourself and continue as
+         *  if nothing happen.  The period was reset in the timeout routine.
+         */
+        if ( local_state == PERIODIC_EXPIRED_WHILE_BLOCKING )
+          _Thread_Clear_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
+
+        _Thread_Enable_dispatch();
+        return RTEMS_SUCCESSFUL;
+      }
+
+      if ( the_period->state == PERIODIC_EXPIRED ) {
+        /*
+         *  Update statistics from the concluding period
+         */
+        _Periodic_Update_statistics( the_period );
+
+        /* TODO: scheduler-specific job release call-out */
+        _Scheduler_edf_Release_job( the_period );
+
+        _ISR_Enable( level );
+
+        the_period->state = PERIODIC_ACTIVE;
+        the_period->next_length = length;
+
+        _Watchdog_Insert_ticks( &the_period->Timer, length );
+        _Thread_Enable_dispatch();
+        return RTEMS_TIMEOUT;
+      }
+
+      /*
+       *  These should never happen so just return invalid Id.
+       *    - RATE_MONOTONIC_OWNER_IS_BLOCKING:
+       *    - RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING:
+       */
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:            /* should never return this */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
+
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicreportstatistics.c rtems/cpukit/rtems/src/periodicreportstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicreportstatistics.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicreportstatistics.c	2010-07-22 15:29:43.000000000 -0400
@@ -0,0 +1,209 @@
+/*
+ *  Periodic Manager -- Report Statistics for All Periods
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <inttypes.h>
+
+#include <rtems/bspIo.h>
+#include <rtems/score/timespec.h>
+#include <rtems/rtems/periodic.h>
+
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  /* We print to 1/10's of milliseconds */
+  #define NANOSECONDS_DIVIDER 1000
+  #define PERCENT_FMT     "%04" PRId32
+  #define NANOSECONDS_FMT "%06" PRId32
+#endif
+
+/*
+ *  This directive allows a thread to print the statistics information
+ *  on ALL period instances which have non-zero counts using printk.
+ *
+ *  The implementation of this directive straddles the fence between
+ *  inside and outside of RTEMS.  It is presented as part of the Manager
+ *  but actually uses other services of the Manager.
+ */
+void rtems_periodic_report_statistics_with_plugin(
+  void                  *context,
+  rtems_printk_plugin_t  print
+)
+{
+  rtems_status_code                      status;
+  rtems_id                               id;
+  rtems_periodic_period_statistics the_stats;
+  rtems_periodic_period_status     the_status;
+  char                                   name[5];
+
+  if ( !print )
+    return;
+
+  (*print)( context, "Period information by period\n" );
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    (*print)( context, "--- CPU times are in seconds ---\n" );
+    (*print)( context, "--- Wall times are in seconds ---\n" );
+  #endif
+/*
+Layout by columns -- in memory of Hollerith :)
+
+1234567890123456789012345678901234567890123456789012345678901234567890123456789\
+   ID     OWNER COUNT MISSED X
+ididididid NNNN ccccc mmmmmm X
+
+  Uncomment the following if you are tinkering with the formatting.
+  Be sure to test the various cases.
+  (*print)( context,"\
+1234567890123456789012345678901234567890123456789012345678901234567890123456789\
+\n");
+*/
+  (*print)( context, "   ID     OWNER COUNT MISSED     "
+       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          "     "
+       #endif
+          "CPU TIME     "
+       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          "          "
+       #endif
+          "   WALL TIME\n"
+  );
+  (*print)( context, "                               "
+       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          "     "
+       #endif
+          "MIN/MAX/AVG    "
+       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+          "          "
+       #endif
+          "  MIN/MAX/AVG\n"
+  );
+
+  /*
+   * Cycle through all possible ids and try to report on each one.  If it
+   * is a period that is inactive, we just get an error back.  No big deal.
+   */
+  for ( id=_Periodic_Information.minimum_id ;
+        id <= _Periodic_Information.maximum_id ;
+        id++ ) {
+    status = rtems_periodic_get_statistics( id, &the_stats );
+    if ( status != RTEMS_SUCCESSFUL )
+      continue;
+
+    /* If the above passed, so should this but check it anyway */
+    status = rtems_periodic_get_status( id, &the_status );
+    #if defined(RTEMS_DEBUG)
+      if ( status != RTEMS_SUCCESSFUL )
+        continue;
+    #endif
+
+    rtems_object_get_name( the_status.owner, sizeof(name), name );
+
+    /*
+     *  Print part of report line that is not dependent on granularity
+     */
+    (*print)( context,
+      "0x%08" PRIx32 " %4s %5" PRId32 " %6" PRId32 " ",
+      id, name,
+      the_stats.count, the_stats.missed_count
+    );
+
+    /*
+     *  If the count is zero, don't print statistics
+     */
+    if (the_stats.count == 0) {
+      (*print)( context, "\n" );
+      continue;
+    }
+
+    /*
+     *  print CPU Usage part of statistics
+     */
+    {
+    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+      struct timespec  cpu_average;
+      struct timespec *min_cpu = &the_stats.min_cpu_time;
+      struct timespec *max_cpu = &the_stats.max_cpu_time;
+      struct timespec *total_cpu = &the_stats.total_cpu_time;
+
+      _Timespec_Divide_by_integer( total_cpu, the_stats.count, &cpu_average );
+      (*print)( context,
+        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* min cpu time */
+        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* max cpu time */
+        "%" PRId32 "."  NANOSECONDS_FMT " ",       /* avg cpu time */
+        _Timespec_Get_seconds( min_cpu ),
+	  _Timespec_Get_nanoseconds( min_cpu ) / NANOSECONDS_DIVIDER,
+        _Timespec_Get_seconds( max_cpu ),
+	  _Timespec_Get_nanoseconds( max_cpu ) / NANOSECONDS_DIVIDER,
+        _Timespec_Get_seconds( &cpu_average ),
+	  _Timespec_Get_nanoseconds( &cpu_average ) / NANOSECONDS_DIVIDER
+       );
+    #else
+      uint32_t ival_cpu, fval_cpu;
+
+      ival_cpu = the_stats.total_cpu_time * 100 / the_stats.count;
+      fval_cpu = ival_cpu % 100;
+      ival_cpu /= 100;
+
+      (*print)( context,
+        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 " ",
+        the_stats.min_cpu_time, the_stats.max_cpu_time, ival_cpu, fval_cpu
+      );
+    #endif
+    }
+
+    /*
+     *  print wall time part of statistics
+     */
+    {
+    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+      struct timespec  wall_average;
+      struct timespec *min_wall = &the_stats.min_wall_time;
+      struct timespec *max_wall = &the_stats.max_wall_time;
+      struct timespec *total_wall = &the_stats.total_wall_time;
+
+      _Timespec_Divide_by_integer(total_wall, the_stats.count, &wall_average);
+      (*print)( context,
+        "%" PRId32 "." NANOSECONDS_FMT "/"        /* min wall time */
+        "%" PRId32 "." NANOSECONDS_FMT "/"        /* max wall time */
+        "%" PRId32 "." NANOSECONDS_FMT "\n",      /* avg wall time */
+        _Timespec_Get_seconds( min_wall ),
+          _Timespec_Get_nanoseconds( min_wall ) / NANOSECONDS_DIVIDER,
+        _Timespec_Get_seconds( max_wall ),
+          _Timespec_Get_nanoseconds( max_wall ) / NANOSECONDS_DIVIDER,
+        _Timespec_Get_seconds( &wall_average ),
+          _Timespec_Get_nanoseconds( &wall_average ) / NANOSECONDS_DIVIDER
+      );
+    #else
+      uint32_t  ival_wall, fval_wall;
+
+      ival_wall = the_stats.total_wall_time * 100 / the_stats.count;
+      fval_wall = ival_wall % 100;
+      ival_wall /= 100;
+      (*print)( context,
+        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 "\n",
+        the_stats.min_wall_time, the_stats.max_wall_time, ival_wall, fval_wall
+      );
+    #endif
+    }
+  }
+}
+
+void rtems_periodic_report_statistics( void )
+{
+  rtems_periodic_report_statistics_with_plugin( NULL, printk_plugin );
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicresetall.c rtems/cpukit/rtems/src/periodicresetall.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicresetall.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicresetall.c	2010-07-22 15:29:28.000000000 -0400
@@ -0,0 +1,57 @@
+/*
+ *  Periodic Manager -- Reset Statistics for All Periods
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*
+ *  rtems_periodic_reset_all_statistics
+ */
+void rtems_periodic_reset_all_statistics( void )
+{
+  Objects_Id        id;
+  rtems_status_code status;
+
+   /*
+    *  Prevent allocation or deallocation of any of the periods while
+    *  we are cycling.  Also this is an optimization which ensures that
+    *  we only disable/enable once.  The call to
+    *  rtems_periodic_reset_statistics will be in a nested dispatch
+    *  disabled critical section.
+    */
+  _Thread_Disable_dispatch();
+
+    /*
+     * Cycle through all possible ids and try to reset each one.  If it
+     * is a period that is inactive, we just get an error back.  No big deal.
+     */
+    for ( id=_Periodic_Information.minimum_id ;
+          id <= _Periodic_Information.maximum_id ;
+          id++ ) {
+      status = rtems_periodic_reset_statistics( id );
+    }
+
+  /*
+   *  Done so exit thread dispatching disabled critical section.
+   */
+  _Thread_Enable_dispatch();
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicresetstatistics.c rtems/cpukit/rtems/src/periodicresetstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/periodicresetstatistics.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/rtems/src/periodicresetstatistics.c	2010-07-22 15:30:10.000000000 -0400
@@ -0,0 +1,65 @@
+/*
+ *  Periodic Manager -- Reset Statistics
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  rtems_periodic_reset_statistics
+ *
+ *  This directive allows a thread to reset the statistics information
+ *  on a specific period instance.
+ *
+ *  Input parameters:
+ *    id         - periodic id
+ *
+ *  Output parameters:
+ *    RTEMS_SUCCESSFUL - if successful
+ *    error code       - if unsuccessful
+ *
+ */
+
+rtems_status_code rtems_periodic_reset_statistics(
+  rtems_id id
+)
+{
+  Objects_Locations              location;
+  Periodic_Control        *the_period;
+
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      _Periodic_Reset_statistics( the_period );
+      _Thread_Enable_dispatch();
+      return RTEMS_SUCCESSFUL;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:            /* should never return this */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+
+  return RTEMS_INVALID_ID;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemon.c rtems/cpukit/rtems/src/ratemon.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemon.c	2009-01-06 00:02:25.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemon.c	2010-07-22 16:41:04.000000000 -0400
@@ -22,6 +22,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -42,19 +43,5 @@
 
 void _Rate_monotonic_Manager_initialization(void)
 {
-  _Objects_Initialize_information(
-    &_Rate_monotonic_Information,    /* object information table */
-    OBJECTS_CLASSIC_API,             /* object API */
-    OBJECTS_RTEMS_PERIODS,           /* object class */
-    Configuration_RTEMS_API.maximum_periods,
-                                     /* maximum objects of this class */
-    sizeof( Rate_monotonic_Control ),/* size of this object's control block */
-    false,                           /* true if the name is a string */
-    RTEMS_MAXIMUM_NAME_LENGTH        /* maximum length of an object name */
-#if defined(RTEMS_MULTIPROCESSING)
-    ,
-    false,                           /* true if this is a global object class */
-    NULL                             /* Proxy extraction support callout */
-#endif
-  );
+  _Periodic_Manager_initialization();
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemoncancel.c rtems/cpukit/rtems/src/ratemoncancel.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemoncancel.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemoncancel.c	2010-07-22 16:00:23.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -41,28 +42,5 @@ rtems_status_code rtems_rate_monotonic_c
   rtems_id id
 )
 {
-  Rate_monotonic_Control *the_period;
-  Objects_Locations       location;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      if ( !_Thread_Is_executing( the_period->owner ) ) {
-        _Thread_Enable_dispatch();
-        return RTEMS_NOT_OWNER_OF_RESOURCE;
-      }
-      (void) _Watchdog_Remove( &the_period->Timer );
-      the_period->state = RATE_MONOTONIC_INACTIVE;
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_cancel(id));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemoncreate.c rtems/cpukit/rtems/src/ratemoncreate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemoncreate.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemoncreate.c	2010-07-22 16:01:31.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,37 +46,5 @@ rtems_status_code rtems_rate_monotonic_c
   rtems_id   *id
 )
 {
-  Rate_monotonic_Control *the_period;
-
-  if ( !rtems_is_name_valid( name ) )
-    return RTEMS_INVALID_NAME;
-
-  if ( !id )
-    return RTEMS_INVALID_ADDRESS;
-
-  _Thread_Disable_dispatch();            /* to prevent deletion */
-
-  the_period = _Rate_monotonic_Allocate();
-
-  if ( !the_period ) {
-    _Thread_Enable_dispatch();
-    return RTEMS_TOO_MANY;
-  }
-
-  the_period->owner = _Thread_Executing;
-  the_period->state = RATE_MONOTONIC_INACTIVE;
-
-  _Watchdog_Initialize( &the_period->Timer, NULL, 0, NULL );
-
-  _Rate_monotonic_Reset_statistics( the_period );
-
-  _Objects_Open(
-    &_Rate_monotonic_Information,
-    &the_period->Object,
-    (Objects_Name) name
-  );
-
-  *id = the_period->Object.id;
-  _Thread_Enable_dispatch();
-  return RTEMS_SUCCESSFUL;
+  return (rtems_periodic_create( name, id ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemondata.c rtems/cpukit/rtems/src/ratemondata.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemondata.c	2007-05-21 19:19:20.000000000 -0400
+++ rtems/cpukit/rtems/src/ratemondata.c	2010-07-22 16:02:51.000000000 -0400
@@ -9,6 +9,8 @@
  *  http://www.rtems.com/license/LICENSE.
  *
  *  $Id: ratemondata.c,v 1.1 2007/05/21 23:19:20 joel Exp $
+ *
+ *  Note: this file is deprecated.
  */
 
 #if HAVE_CONFIG_H
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemondelete.c rtems/cpukit/rtems/src/ratemondelete.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemondelete.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemondelete.c	2010-07-22 16:03:35.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -41,26 +42,5 @@ rtems_status_code rtems_rate_monotonic_d
   rtems_id id
 )
 {
-  Rate_monotonic_Control *the_period;
-  Objects_Locations       location;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      _Objects_Close( &_Rate_monotonic_Information, &the_period->Object );
-      (void) _Watchdog_Remove( &the_period->Timer );
-      the_period->state = RATE_MONOTONIC_INACTIVE;
-      _Rate_monotonic_Free( the_period );
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return(rtems_periodic_delete(id));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemongetstatistics.c rtems/cpukit/rtems/src/ratemongetstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemongetstatistics.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemongetstatistics.c	2010-07-22 16:04:17.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,47 +46,5 @@ rtems_status_code rtems_rate_monotonic_g
   rtems_rate_monotonic_period_statistics *statistics
 )
 {
-  Objects_Locations                        location;
-  Rate_monotonic_Control                  *the_period;
-  rtems_rate_monotonic_period_statistics  *dst;
-  Rate_monotonic_Statistics               *src;
-
-  if ( !statistics )
-    return RTEMS_INVALID_ADDRESS;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      dst = statistics;
-      src = &the_period->Statistics;
-      dst->count        = src->count;
-      dst->missed_count = src->missed_count;
-      #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-        _Timestamp_To_timespec( &src->min_cpu_time,   &dst->min_cpu_time );
-        _Timestamp_To_timespec( &src->max_cpu_time,   &dst->max_cpu_time );
-        _Timestamp_To_timespec( &src->total_cpu_time, &dst->total_cpu_time );
-        _Timestamp_To_timespec( &src->min_wall_time,   &dst->min_wall_time );
-        _Timestamp_To_timespec( &src->max_wall_time,   &dst->max_wall_time );
-        _Timestamp_To_timespec( &src->total_wall_time, &dst->total_wall_time );
-      #else
-        dst->min_cpu_time    = src->min_cpu_time;
-        dst->max_cpu_time    = src->max_cpu_time;
-        dst->total_cpu_time  = src->total_cpu_time;
-        dst->min_wall_time   = src->min_wall_time;
-        dst->max_wall_time   = src->max_wall_time;
-        dst->total_wall_time = src->total_wall_time;
-      #endif
-
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return(rtems_periodic_get_statistics( id, statistics ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemongetstatus.c rtems/cpukit/rtems/src/ratemongetstatus.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemongetstatus.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemongetstatus.c	2010-07-22 16:04:58.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -49,70 +50,5 @@ rtems_status_code rtems_rate_monotonic_g
   rtems_rate_monotonic_period_status *status
 )
 {
-  Thread_CPU_usage_t             executed;
-  Objects_Locations              location;
-  Rate_monotonic_Period_time_t   since_last_period;
-  Rate_monotonic_Control        *the_period;
-  bool                           valid_status;
-
-  if ( !status )
-    return RTEMS_INVALID_ADDRESS;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      status->owner = the_period->owner->Object.id;
-      status->state = the_period->state;
-
-      /*
-       *  If the period is inactive, there is no information.
-       */
-      if ( status->state == RATE_MONOTONIC_INACTIVE ) {
-        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          _Timespec_Set_to_zero( &status->since_last_period );
-          _Timespec_Set_to_zero( &status->executed_since_last_period );
-        #else
-          status->since_last_period = 0;
-          status->executed_since_last_period = 0;
-        #endif
-
-      } else {
-
-        /*
-         *  Grab the current status.
-         */
-        valid_status =
-          _Rate_monotonic_Get_status(
-            the_period, &since_last_period, &executed
-          );
-        if (!valid_status) {
-          _Thread_Enable_dispatch();
-          return RTEMS_NOT_DEFINED;
-        }
-
-        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          _Timestamp_To_timespec(
-            &since_last_period, &status->since_last_period
-          );
-          _Timestamp_To_timespec(
-            &executed, &status->executed_since_last_period
-          );
-        #else
-          status->since_last_period = since_last_period;
-          status->executed_since_last_period = executed;
-        #endif
-      }
-
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_get_status( id, status ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonident.c rtems/cpukit/rtems/src/ratemonident.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonident.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemonident.c	2010-07-22 16:05:25.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,14 +46,5 @@ rtems_status_code rtems_rate_monotonic_i
   rtems_id   *id
 )
 {
-  Objects_Name_or_id_lookup_errors  status;
-
-  status = _Objects_Name_to_id_u32(
-    &_Rate_monotonic_Information,
-    name,
-    OBJECTS_SEARCH_LOCAL_NODE,
-    id
-  );
-
-  return _Status_Object_name_errors_to_status[ status ];
+  return (rtems_periodic_ident( name, id ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonperiod.c rtems/cpukit/rtems/src/ratemonperiod.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonperiod.c	2010-07-27 10:46:34.000000000 -0400
+++ rtems/cpukit/rtems/src/ratemonperiod.c	2010-07-27 11:58:37.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- *  Rate Monotonic Manager - Period Blocking and Status
+ *  Rate Monotonic Manager - Period Blocking
  *
  *  COPYRIGHT (c) 1989-2010.
  *  On-Line Applications Research Corporation (OAR).
@@ -20,212 +20,10 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
-bool _Rate_monotonic_Get_status(
-  Rate_monotonic_Control        *the_period,
-  Rate_monotonic_Period_time_t  *wall_since_last_period,
-  Thread_CPU_usage_t            *cpu_since_last_period
-)
-{
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    Timestamp_Control        uptime;
-  #endif
-    Thread_Control          *owning_thread = the_period->owner;
-    Thread_CPU_usage_t       used;
-
-  /*
-   *  Determine elapsed wall time since period initiated.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _TOD_Get_uptime( &uptime );
-    _Timestamp_Subtract(
-      &the_period->time_period_initiated, &uptime, wall_since_last_period
-    );
-  #else
-    *wall_since_last_period =
-      _Watchdog_Ticks_since_boot - the_period->time_period_initiated;
-  #endif
-
-  /*
-   *  Determine cpu usage since period initiated.
-   */
-  used = owning_thread->cpu_time_used;
-
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    if (owning_thread == _Thread_Executing) {
-
-      Thread_CPU_usage_t ran;
-
-      /* How much time time since last context switch */
-      _Timestamp_Subtract(
-        &_Thread_Time_of_last_context_switch, &uptime, &ran
-      );
-
-      /* cpu usage += ran */
-      _Timestamp_Add_to( &used, &ran );
-
-      /*
-       *  The cpu usage info was reset while executing.  Can't
-       *  determine a status.
-       */
-      if (_Timestamp_Less_than(&used, &the_period->cpu_usage_period_initiated))
-        return false;
-
-       /* used = current cpu usage - cpu usage at start of period */
-      _Timestamp_Subtract(
-         &the_period->cpu_usage_period_initiated,
-         &used,
-         cpu_since_last_period
-      );
-    }
-  #else
-      /*
-       *  The cpu usage info was reset while executing.  Can't
-       *  determine a status.
-       */
-      if (used < the_period->cpu_usage_period_initiated)
-        return false;
-
-      *cpu_since_last_period = used - the_period->cpu_usage_period_initiated;
-  #endif
-  return true;
-}
-
-void _Rate_monotonic_Initiate_statistics(
-  Rate_monotonic_Control *the_period
-)
-{
-  Thread_Control *owning_thread = the_period->owner;
-
-  /*
-   *  If using nanosecond statistics, we need to obtain the uptime.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    Timestamp_Control  uptime;
-
-    _TOD_Get_uptime( &uptime );
-  #endif
-
-  /*
-   *  Set the starting point and the CPU time used for the statistics.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    the_period->time_period_initiated = uptime;
-  #else
-    the_period->time_period_initiated = _Watchdog_Ticks_since_boot;
-  #endif
-
-  the_period->cpu_usage_period_initiated = owning_thread->cpu_time_used;
-
-  /*
-   *  If using nanosecond statistics and the period's thread is currently
-   *  executing, then we need to take into account how much time the
-   *  executing thread has run since the last context switch.  When this
-   *  routine is invoked from rtems_rate_monotonic_period, the owner will
-   *  be the executing thread.  When this routine is invoked from
-   *  _Rate_monotonic_Timeout, it will not.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    if (owning_thread == _Thread_Executing) {
-
-      rtems_thread_cpu_usage_t ran;
-
-      /*
-       *  Adjust the CPU time used to account for the time since last
-       *  context switch.
-       */
-      _Timespec_Subtract(
-        &_Thread_Time_of_last_context_switch, &uptime, &ran
-      );
-
-      _Timespec_Add_to( &the_period->cpu_usage_period_initiated, &ran );
-    }
-  #endif
-}
-
-void _Rate_monotonic_Update_statistics(
-  Rate_monotonic_Control    *the_period
-)
-{
-  Thread_CPU_usage_t              executed;
-  Rate_monotonic_Period_time_t    since_last_period;
-  Rate_monotonic_Statistics      *stats;
-  bool                            valid_status;
-
-  /*
-   *  Assume we are only called in states where it is appropriate
-   *  to update the statistics.  This should only be RATE_MONOTONIC_ACTIVE
-   *  and RATE_MONOTONIC_EXPIRED.
-   */
-
-  /*
-   *  Update the counts.
-   */
-  stats = &the_period->Statistics;
-  stats->count++;
-
-  if ( the_period->state == RATE_MONOTONIC_EXPIRED )
-    stats->missed_count++;
-
-  /*
-   *  Grab status for time statistics.
-   */
-  valid_status =
-    _Rate_monotonic_Get_status( the_period, &since_last_period, &executed );
-  if (!valid_status)
-    return;
-
-  /*
-   *  Update CPU time
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _Timestamp_Add_to( &stats->total_cpu_time, &executed );
-
-    if ( _Timestamp_Less_than( &executed, &stats->min_cpu_time ) )
-      stats->min_cpu_time = executed;
-
-    if ( _Timestamp_Greater_than( &executed, &stats->max_cpu_time ) )
-      stats->max_cpu_time = executed;
-  #else
-    stats->total_cpu_time  += executed;
-
-    if ( executed < stats->min_cpu_time )
-      stats->min_cpu_time = executed;
-
-    if ( executed > stats->max_cpu_time )
-      stats->max_cpu_time = executed;
-  #endif
-
-  /*
-   *  Update Wall time
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _Timestamp_Add_to( &stats->total_wall_time, &since_last_period );
-
-    if ( _Timestamp_Less_than( &since_last_period, &stats->min_wall_time ) )
-      stats->min_wall_time = since_last_period;
-
-    if ( _Timestamp_Greater_than( &since_last_period, &stats->max_wall_time ) )
-      stats->max_wall_time = since_last_period;
-  #else
-
-    /* Sanity check wall time */
-    if ( since_last_period < executed )
-      since_last_period = executed;
-
-    stats->total_wall_time += since_last_period;
-
-    if ( since_last_period < stats->min_wall_time )
-      stats->min_wall_time = since_last_period;
-
-    if ( since_last_period > stats->max_wall_time )
-      stats->max_wall_time = since_last_period;
-  #endif
-}
-
-
 /*PAGE
  *
  *  rtems_rate_monotonic_period
@@ -246,129 +44,5 @@ rtems_status_code rtems_rate_monotonic_p
   rtems_interval length
 )
 {
-  Rate_monotonic_Control              *the_period;
-  Objects_Locations                    location;
-  rtems_status_code                    return_value;
-  rtems_rate_monotonic_period_states   local_state;
-  ISR_Level                            level;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-
-  switch ( location ) {
-    case OBJECTS_LOCAL:
-      if ( !_Thread_Is_executing( the_period->owner ) ) {
-        _Thread_Enable_dispatch();
-        return RTEMS_NOT_OWNER_OF_RESOURCE;
-      }
-
-      if ( length == RTEMS_PERIOD_STATUS ) {
-        switch ( the_period->state ) {
-          case RATE_MONOTONIC_INACTIVE:
-            return_value = RTEMS_NOT_DEFINED;
-            break;
-          case RATE_MONOTONIC_EXPIRED:
-          case RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING:
-            return_value = RTEMS_TIMEOUT;
-            break;
-          case RATE_MONOTONIC_ACTIVE:
-          default:              /* unreached -- only to remove warnings */
-            return_value = RTEMS_SUCCESSFUL;
-            break;
-        }
-        _Thread_Enable_dispatch();
-        return( return_value );
-      }
-
-      _ISR_Disable( level );
-      if ( the_period->state == RATE_MONOTONIC_INACTIVE ) {
-        _ISR_Enable( level );
-
-        /*
-         *  Baseline statistics information for the beginning of a period.
-         */
-        _Rate_monotonic_Initiate_statistics( the_period );
-
-        the_period->state = RATE_MONOTONIC_ACTIVE;
-        _Watchdog_Initialize(
-          &the_period->Timer,
-          _Rate_monotonic_Timeout,
-          id,
-          NULL
-        );
-
-        the_period->next_length = length;
-
-        _Watchdog_Insert_ticks( &the_period->Timer, length );
-        _Thread_Enable_dispatch();
-        return RTEMS_SUCCESSFUL;
-      }
-
-      if ( the_period->state == RATE_MONOTONIC_ACTIVE ) {
-        /*
-         *  Update statistics from the concluding period.
-         */
-        _Rate_monotonic_Update_statistics( the_period );
-
-        /*
-         *  This tells the _Rate_monotonic_Timeout that this task is
-         *  in the process of blocking on the period and that we
-         *  may be changing the length of the next period.
-         */
-        the_period->state = RATE_MONOTONIC_OWNER_IS_BLOCKING;
-        the_period->next_length = length;
-
-        _ISR_Enable( level );
-
-        _Thread_Executing->Wait.id = the_period->Object.id;
-        _Thread_Set_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
-
-        /*
-         *  Did the watchdog timer expire while we were actually blocking
-         *  on it?
-         */
-        _ISR_Disable( level );
-          local_state = the_period->state;
-          the_period->state = RATE_MONOTONIC_ACTIVE;
-        _ISR_Enable( level );
-
-        /*
-         *  If it did, then we want to unblock ourself and continue as
-         *  if nothing happen.  The period was reset in the timeout routine.
-         */
-        if ( local_state == RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING )
-          _Thread_Clear_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
-
-        _Thread_Enable_dispatch();
-        return RTEMS_SUCCESSFUL;
-      }
-
-      if ( the_period->state == RATE_MONOTONIC_EXPIRED ) {
-        /*
-         *  Update statistics from the concluding period
-         */
-        _Rate_monotonic_Update_statistics( the_period );
-
-        _ISR_Enable( level );
-
-        the_period->state = RATE_MONOTONIC_ACTIVE;
-        the_period->next_length = length;
-
-        _Watchdog_Insert_ticks( &the_period->Timer, length );
-        _Thread_Enable_dispatch();
-        return RTEMS_TIMEOUT;
-      }
-
-      /*
-       *  These should never happen so just return invalid Id.
-       *    - RATE_MONOTONIC_OWNER_IS_BLOCKING:
-       *    - RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING:
-       */
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_period( id, length ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonreportstatistics.c rtems/cpukit/rtems/src/ratemonreportstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonreportstatistics.c	2009-12-02 13:22:18.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemonreportstatistics.c	2010-07-22 16:07:24.000000000 -0400
@@ -20,16 +20,11 @@
 #include <ctype.h>
 #include <inttypes.h>
 
+#include <rtems/rtems/periodic.h>
+
 #include <rtems/bspIo.h>
 #include <rtems/score/timespec.h>
 
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  /* We print to 1/10's of milliseconds */
-  #define NANOSECONDS_DIVIDER 1000
-  #define PERCENT_FMT     "%04" PRId32
-  #define NANOSECONDS_FMT "%06" PRId32
-#endif
-
 /*
  *  This directive allows a thread to print the statistics information
  *  on ALL period instances which have non-zero counts using printk.
@@ -43,165 +38,10 @@ void rtems_rate_monotonic_report_statist
   rtems_printk_plugin_t  print
 )
 {
-  rtems_status_code                      status;
-  rtems_id                               id;
-  rtems_rate_monotonic_period_statistics the_stats;
-  rtems_rate_monotonic_period_status     the_status;
-  char                                   name[5];
-
-  if ( !print )
-    return;
-
-  (*print)( context, "Period information by period\n" );
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    (*print)( context, "--- CPU times are in seconds ---\n" );
-    (*print)( context, "--- Wall times are in seconds ---\n" );
-  #endif
-/*
-Layout by columns -- in memory of Hollerith :)
-
-1234567890123456789012345678901234567890123456789012345678901234567890123456789\
-   ID     OWNER COUNT MISSED X
-ididididid NNNN ccccc mmmmmm X
-
-  Uncomment the following if you are tinkering with the formatting.
-  Be sure to test the various cases.
-  (*print)( context,"\
-1234567890123456789012345678901234567890123456789012345678901234567890123456789\
-\n");
-*/
-  (*print)( context, "   ID     OWNER COUNT MISSED     "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "     "
-       #endif
-          "CPU TIME     "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "          "
-       #endif
-          "   WALL TIME\n"
-  );
-  (*print)( context, "                               "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "     "
-       #endif
-          "MIN/MAX/AVG    "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "          "
-       #endif
-          "  MIN/MAX/AVG\n"
-  );
-
-  /*
-   * Cycle through all possible ids and try to report on each one.  If it
-   * is a period that is inactive, we just get an error back.  No big deal.
-   */
-  for ( id=_Rate_monotonic_Information.minimum_id ;
-        id <= _Rate_monotonic_Information.maximum_id ;
-        id++ ) {
-    status = rtems_rate_monotonic_get_statistics( id, &the_stats );
-    if ( status != RTEMS_SUCCESSFUL )
-      continue;
-
-    /* If the above passed, so should this but check it anyway */
-    status = rtems_rate_monotonic_get_status( id, &the_status );
-    #if defined(RTEMS_DEBUG)
-      if ( status != RTEMS_SUCCESSFUL )
-        continue;
-    #endif
-
-    rtems_object_get_name( the_status.owner, sizeof(name), name );
-
-    /*
-     *  Print part of report line that is not dependent on granularity
-     */
-    (*print)( context,
-      "0x%08" PRIx32 " %4s %5" PRId32 " %6" PRId32 " ",
-      id, name,
-      the_stats.count, the_stats.missed_count
-    );
-
-    /*
-     *  If the count is zero, don't print statistics
-     */
-    if (the_stats.count == 0) {
-      (*print)( context, "\n" );
-      continue;
-    }
-
-    /*
-     *  print CPU Usage part of statistics
-     */
-    {
-    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-      struct timespec  cpu_average;
-      struct timespec *min_cpu = &the_stats.min_cpu_time;
-      struct timespec *max_cpu = &the_stats.max_cpu_time;
-      struct timespec *total_cpu = &the_stats.total_cpu_time;
-
-      _Timespec_Divide_by_integer( total_cpu, the_stats.count, &cpu_average );
-      (*print)( context,
-        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* min cpu time */
-        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* max cpu time */
-        "%" PRId32 "."  NANOSECONDS_FMT " ",       /* avg cpu time */
-        _Timespec_Get_seconds( min_cpu ),
-	  _Timespec_Get_nanoseconds( min_cpu ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( max_cpu ),
-	  _Timespec_Get_nanoseconds( max_cpu ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( &cpu_average ),
-	  _Timespec_Get_nanoseconds( &cpu_average ) / NANOSECONDS_DIVIDER
-       );
-    #else
-      uint32_t ival_cpu, fval_cpu;
-
-      ival_cpu = the_stats.total_cpu_time * 100 / the_stats.count;
-      fval_cpu = ival_cpu % 100;
-      ival_cpu /= 100;
-
-      (*print)( context,
-        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 " ",
-        the_stats.min_cpu_time, the_stats.max_cpu_time, ival_cpu, fval_cpu
-      );
-    #endif
-    }
-
-    /*
-     *  print wall time part of statistics
-     */
-    {
-    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-      struct timespec  wall_average;
-      struct timespec *min_wall = &the_stats.min_wall_time;
-      struct timespec *max_wall = &the_stats.max_wall_time;
-      struct timespec *total_wall = &the_stats.total_wall_time;
-
-      _Timespec_Divide_by_integer(total_wall, the_stats.count, &wall_average);
-      (*print)( context,
-        "%" PRId32 "." NANOSECONDS_FMT "/"        /* min wall time */
-        "%" PRId32 "." NANOSECONDS_FMT "/"        /* max wall time */
-        "%" PRId32 "." NANOSECONDS_FMT "\n",      /* avg wall time */
-        _Timespec_Get_seconds( min_wall ),
-          _Timespec_Get_nanoseconds( min_wall ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( max_wall ),
-          _Timespec_Get_nanoseconds( max_wall ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( &wall_average ),
-          _Timespec_Get_nanoseconds( &wall_average ) / NANOSECONDS_DIVIDER
-      );
-    #else
-      uint32_t  ival_wall, fval_wall;
-
-      ival_wall = the_stats.total_wall_time * 100 / the_stats.count;
-      fval_wall = ival_wall % 100;
-      ival_wall /= 100;
-      (*print)( context,
-        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 "\n",
-        the_stats.min_wall_time, the_stats.max_wall_time, ival_wall, fval_wall
-      );
-    #endif
-    }
-  }
+  rtems_periodic_report_statistics_with_plugin( context, print );
 }
 
 void rtems_rate_monotonic_report_statistics( void )
 {
-  rtems_rate_monotonic_report_statistics_with_plugin( NULL, printk_plugin );
+  rtems_periodic_report_statistics_with_plugin( NULL, printk_plugin );
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonresetall.c rtems/cpukit/rtems/src/ratemonresetall.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonresetall.c	2007-05-17 18:46:45.000000000 -0400
+++ rtems/cpukit/rtems/src/ratemonresetall.c	2010-07-22 16:07:50.000000000 -0400
@@ -19,6 +19,7 @@
 #include <rtems/rtems/status.h>
 #include <rtems/rtems/support.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -27,30 +28,5 @@
  */
 void rtems_rate_monotonic_reset_all_statistics( void )
 {
-  Objects_Id        id;
-  rtems_status_code status;
-
-   /*
-    *  Prevent allocation or deallocation of any of the periods while
-    *  we are cycling.  Also this is an optimization which ensures that
-    *  we only disable/enable once.  The call to
-    *  rtems_rate_monotonic_reset_statistics will be in a nested dispatch
-    *  disabled critical section.
-    */
-  _Thread_Disable_dispatch();
-
-    /*
-     * Cycle through all possible ids and try to reset each one.  If it
-     * is a period that is inactive, we just get an error back.  No big deal.
-     */
-    for ( id=_Rate_monotonic_Information.minimum_id ;
-          id <= _Rate_monotonic_Information.maximum_id ;
-          id++ ) {
-      status = rtems_rate_monotonic_reset_statistics( id );
-    }
-
-  /*
-   *  Done so exit thread dispatching disabled critical section.
-   */
-  _Thread_Enable_dispatch();
+  rtems_periodic_reset_all_statistics();
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonresetstatistics.c rtems/cpukit/rtems/src/ratemonresetstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/ratemonresetstatistics.c	2009-12-15 13:26:41.000000000 -0500
+++ rtems/cpukit/rtems/src/ratemonresetstatistics.c	2010-07-22 16:08:18.000000000 -0400
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -43,23 +44,5 @@ rtems_status_code rtems_rate_monotonic_r
   rtems_id id
 )
 {
-  Objects_Locations              location;
-  Rate_monotonic_Control        *the_period;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      _Rate_monotonic_Reset_statistics( the_period );
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_reset_statistics( id ));
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/taskwakeafter.c rtems/cpukit/rtems/src/taskwakeafter.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/rtems/src/taskwakeafter.c	2005-01-18 04:03:45.000000000 -0500
+++ rtems/cpukit/rtems/src/taskwakeafter.c	2010-07-08 13:33:01.000000000 -0400
@@ -21,6 +21,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/rtems/modes.h>
 #include <rtems/score/object.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/stack.h>
 #include <rtems/score/states.h>
 #include <rtems/rtems/tasks.h>
@@ -52,7 +53,7 @@ rtems_status_code rtems_task_wake_after(
 {
   _Thread_Disable_dispatch();
     if ( ticks == 0 ) {
-      _Thread_Yield_processor();
+      _Scheduler_Yield();
     } else {
       _Thread_Set_state( _Thread_Executing, STATES_DELAYING );
       _Watchdog_Initialize(
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/confdefs.h rtems/cpukit/sapi/include/confdefs.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/confdefs.h	2010-08-11 14:25:06.000000000 -0400
+++ rtems/cpukit/sapi/include/confdefs.h	2010-08-13 11:44:28.000000000 -0400
@@ -535,6 +535,131 @@ rtems_fs_init_functions_t    rtems_fs_in
 #endif
 
 /*
+ * Scheduler configuration.
+ *
+ * The scheduler configuration allows an application to select the 
+ * scheduling policy to use.  The supported configurations are:
+ *  CONFIGURE_SCHEDULER_USER
+ *  CONFIGURE_SCHEDULER_PRIORITY
+ *  CONFIGURE_SCHEDULER_FIFO
+ *  CONFIGURE_SCHEDULER_EDF
+ * 
+ * If no configuration is specified by the application, then 
+ * CONFIGURE_SCHEDULER_PRIORITY is assumed to be the default.
+ * An application can define its own scheduling policy by defining
+ * CONFIGURE_SCHEDULER_USER and CONFIGURE_SCHEDULER_ENTRY_USER to point
+ * to an initialization routine.  
+ *
+ * To add a new scheduler:
+ */
+#include <rtems/score/scheduler.h>
+
+#if defined(CONFIGURE_SCHEDULER_USER) && \
+    !defined(CONFIGURE_SCHEDULER_ENTRY_USER)
+  #error "CONFIGURE_ERROR: CONFIGURE_SCHEDULER_USER without CONFIGURE_SCHEDULER_ENTRY_USER"
+#endif
+
+/* enable all RTEMS-provided schedulers */
+#if defined(CONFIGURE_SCHEDULER_ALL)
+  #define CONFIGURE_SCHEDULER_PRIORITY
+  #define CONFIGURE_SCHEDULER_FIFO
+  #define CONFIGURE_SCHEDULER_EDF
+#endif
+
+/* If no scheduler is specified, the priority scheduler is default. */
+#if !defined(CONFIGURE_SCHEDULER_USER) && \
+    !defined(CONFIGURE_SCHEDULER_PRIORITY) && \
+    !defined(CONFIGURE_SCHEDULER_FIFO) && \
+    !defined(CONFIGURE_SCHEDULER_EDF)
+  #define CONFIGURE_SCHEDULER_PRIORITY
+  #define CONFIGURE_SCHEDULER_POLICY _Scheduler_PRIORITY
+#endif
+
+/*
+ * If a user scheduler is specified and no policy is set, 
+ * the user scheduler is the default policy.
+ */
+#if defined(CONFIGURE_SCHEDULER_USER) && \
+    !defined(CONFIGURE_SCHEDULER_POLICY)
+  #define CONFIGURE_SCHEDULER_POLICY _Scheduler_USER
+#endif
+
+/* 
+ * Check for priority scheduler next, as it is the default policy if there
+ * is no CONFIGURE_SCHEDULER_POLICY set and no USER scheduler provided.
+ */
+#if defined(CONFIGURE_SCHEDULER_PRIORITY)
+  #include <rtems/score/schedulerpriority.h>
+  #define CONFIGURE_SCHEDULER_ENTRY_PRIORITY { _Scheduler_priority_Initialize }
+  #if !defined(CONFIGURE_SCHEDULER_POLICY)
+    #define CONFIGURE_SCHEDULER_POLICY _Scheduler_PRIORITY
+  #endif
+#endif
+
+/* Check for FIFO scheduler */
+#if defined(CONFIGURE_SCHEDULER_FIFO)
+  #include <rtems/score/schedulerfifo.h>
+  #define CONFIGURE_SCHEDULER_ENTRY_FIFO { _Scheduler_fifo_Initialize }
+  #if !defined(CONFIGURE_SCHEDULER_POLICY)
+    #define CONFIGURE_SCHEDULER_POLICY _Scheduler_FIFO
+  #endif
+#endif
+
+/* Check for EDF scheduler */
+#if defined(CONFIGURE_SCHEDULER_EDF)
+  #include <rtems/score/scheduleredf.h>
+  #define CONFIGURE_SCHEDULER_ENTRY_EDF { _Scheduler_edf_Initialize }
+  #if !defined(CONFIGURE_SCHEDULER_POLICY)
+    #define CONFIGURE_SCHEDULER_POLICY _Scheduler_EDF
+  #endif
+#endif
+
+
+/* 
+ * Set up the scheduler table.  The scheduling code indexes this table to 
+ * invoke the correct scheduling implementation. The scheduler to use is 
+ * determined by the Configuration.scheduler_policy field, which is set
+ * by CONFIGURE_SCHEDULER_POLICY.  If a particular scheduler is not enabled,
+ * an empty entry is included in its entry in the scheduler table.
+ */
+
+  /**
+   * An empty scheduler entry
+   */
+  #define CONFIGURE_SCHEDULER_NULL { NULL }
+
+#ifdef CONFIGURE_INIT
+  /* the table of available schedulers. */
+  const Scheduler_Table_t _Scheduler_Table[] = {
+    #if defined(CONFIGURE_SCHEDULER_USER) && \
+        defined(CONFIGURE_SCHEDULER_ENTRY_USER)
+      CONFIGURE_SCHEDULER_ENTRY_USER,
+    #else
+      CONFIGURE_SCHEDULER_NULL,
+    #endif
+    #if defined(CONFIGURE_SCHEDULER_PRIORITY) && \
+        defined(CONFIGURE_SCHEDULER_ENTRY_PRIORITY)
+      CONFIGURE_SCHEDULER_ENTRY_PRIORITY,
+    #else
+      CONFIGURE_SCHEDULER_NULL,
+    #endif
+    #if defined(CONFIGURE_SCHEDULER_FIFO) && \
+        defined(CONFIGURE_SCHEDULER_ENTRY_FIFO)
+      CONFIGURE_SCHEDULER_ENTRY_FIFO,
+    #else
+      CONFIGURE_SCHEDULER_NULL,
+    #endif
+    #if defined(CONFIGURE_SCHEDULER_EDF) && \
+        defined(CONFIGURE_SCHEDULER_ENTRY_EDF)
+      CONFIGURE_SCHEDULER_ENTRY_EDF,
+    #else
+      CONFIGURE_SCHEDULER_NULL,
+    #endif   
+  };
+#endif
+
+
+/*
  *  If you said the IDLE task was going to do application initialization
  *  and didn't override the IDLE body, then something is amiss.
  */
@@ -2004,6 +2129,7 @@ rtems_fs_init_functions_t    rtems_fs_in
     CONFIGURE_MAXIMUM_USER_EXTENSIONS,        /* maximum dynamic extensions */
     CONFIGURE_MICROSECONDS_PER_TICK,          /* microseconds per clock tick */
     CONFIGURE_TICKS_PER_TIMESLICE,            /* ticks per timeslice quantum */
+    CONFIGURE_SCHEDULER_POLICY,               /* scheduling policy */
     CONFIGURE_IDLE_TASK_BODY,                 /* user's IDLE task */
     CONFIGURE_IDLE_TASK_STACK_SIZE,           /* IDLE task stack size */
     CONFIGURE_INTERRUPT_STACK_SIZE,           /* interrupt stack size */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/rtems/config.h rtems/cpukit/sapi/include/rtems/config.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/rtems/config.h	2010-06-21 11:29:25.000000000 -0400
+++ rtems/cpukit/sapi/include/rtems/config.h	2010-07-08 13:33:10.000000000 -0400
@@ -118,6 +118,10 @@ typedef struct {
    */
   uint32_t                       ticks_per_timeslice;
 
+  /** This field specifies the scheduling policy to use.
+   */
+  uint32_t                       scheduler_policy;
+
   /** This element points to the BSP's optional idle task which may override
    *  the default one provided with RTEMS.
    */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/rtems/rbtree.h rtems/cpukit/sapi/include/rtems/rbtree.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/include/rtems/rbtree.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/sapi/include/rtems/rbtree.h	2010-07-20 13:12:01.000000000 -0400
@@ -0,0 +1,74 @@
+/**
+ * @file rtems/rbtree.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the RBTree API in RTEMS. The rbtree is a Red Black Tree that
+ *  is part of the Super Core. This is the published interface to that
+ *  code.
+ *
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_RBTREE_H
+#define _RTEMS_RBTREE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/rbtree.h>
+
+/**
+ * @typedef rtems_rbtree_node
+ *
+ * A node that can be manipulated in the rbtree.
+ */
+typedef RBTree_Node rtems_rbtree_node;
+
+/**
+ * @typedef rtems_rbtree_control
+ *
+ * The rbtree's control anchors the rbtree.
+ */
+typedef RBTree_Control rtems_rbtree_control;
+
+/**
+ *  @brief RBTree initializer for an empty rbtree with designator @a name.
+ */
+#define RTEMS_RBTREE_INITIALIZER_EMPTY(name) \
+  RBTREE_INITIALIZER_EMPTY(name)
+
+/**
+ *  @brief RBTree definition for an empty rbtree with designator @a name.
+ */
+#define RTEMS_RBTREE_DEFINE_EMPTY(name) \
+  RBTREE_DEFINE_EMPTY(name)
+
+/**
+  * @brief macro to return the structure containing the @a node.
+  *
+  * This macro returns a pointer of type @a object_type that points 
+  * to the structure containing @a node, where @a object_member is the 
+  * field name of the rtems_rbtree_node structure in objects of @a object_type.
+  */
+#define rtems_rbtree_container_of(node,object_type, object_member) \
+  _RBTree_Container_of(node,object_type,object_member)
+
+#include <rtems/rbtree.inl>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/inline/rtems/rbtree.inl rtems/cpukit/sapi/inline/rtems/rbtree.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/inline/rtems/rbtree.inl	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/sapi/inline/rtems/rbtree.inl	2010-07-20 13:29:34.000000000 -0400
@@ -0,0 +1,391 @@
+/**
+ * @file rtems/rbtree.inl
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the RBTree API in RTEMS. The rbtree is a Red Black Tree that
+ *  is part of the Super Core. This is the published interface to that
+ *  code.
+ *
+ */
+ 
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_RBTREE_H
+# error "Never use <rtems/rbtree.inl> directly; include <rtems/rbtree.h> instead."
+#endif
+
+#ifndef _RTEMS_RBTREE_INL
+#define _RTEMS_RBTREE_INL
+
+#include <rtems/score/rbtree.inl>
+
+/**
+ *  @brief Initialize a RBTree Header
+ *
+ *  This routine initializes @a the_rbtree structure to manage the
+ *  contiguous array of @a number_nodes nodes which starts at
+ *  @a starting_address.  Each node is of @a node_size bytes.
+ */
+RTEMS_INLINE_ROUTINE void rtems_rbtree_initialize(
+  rtems_rbtree_control *the_rbtree,
+  void                *starting_address,
+  size_t               number_nodes,
+  size_t               node_size
+)
+{
+  _RBTree_Initialize( the_rbtree, starting_address, number_nodes, node_size);
+}
+
+/**
+ *  @brief Initialize this RBTree as Empty
+ *
+ *  This routine initializes @a the_rbtree to contain zero nodes.
+ */
+RTEMS_INLINE_ROUTINE void rtems_rbtree_initialize_empty(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  _RBTree_Initialize_empty( the_rbtree );
+}
+
+/**
+ *  @brief Set off rbtree
+ *
+ *  This function sets the next and previous fields of the @a node to NULL
+ *  indicating the @a node is not part of any rbtree.
+ */
+RTEMS_INLINE_ROUTINE void rtems_rbtree_set_off_rbtree(
+  rtems_rbtree_node *node
+)
+{
+  _RBTree_Set_off_rbtree( node );
+}
+
+/**
+ *  @brief Is the Node off RBTree
+ *
+ *  This function returns true if the @a node is not on a rbtree. A @a node is
+ *  off rbtree if the next and previous fields are set to NULL.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_node_off_rbtree(
+  const rtems_rbtree_node *node
+)
+{
+  return _RBTree_Is_node_off_rbtree( node );
+}
+
+/**
+ *  @brief Is the RBTree Node Pointer NULL
+ *
+ *  This function returns true if @a the_node is NULL and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_null_node(
+  const rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Is_null_node( the_node );
+}
+
+/**
+ *  @brief Return pointer to RBTree Root
+ *
+ *  This function returns a pointer to the root node of @a the_rbtree.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_root(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Root( the_rbtree );
+}
+
+/**
+ *  @brief Return pointer to RBTree Minimum
+ *
+ *  This function returns a pointer to the minimum node of @a the_rbtree.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_min(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_First( the_rbtree, RBT_LEFT );
+}
+
+/**
+ *  @brief Return pointer to RBTree Maximum
+ *
+ *  This function returns a pointer to the maximum node of @a the_rbtree.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_max(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_First( the_rbtree, RBT_RIGHT );
+}
+
+/**
+ *  @brief Return pointer to the left child node from this node
+ *
+ *  This function returns a pointer to the left child node of @a the_node.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_left(
+  rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Left( the_node );
+}
+
+/**
+ *  @brief Return pointer to the right child node from this node
+ *
+ *  This function returns a pointer to the right child node of @a the_node.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_right(
+  rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Right( the_node );
+}
+
+/**
+ *  @brief Return pointer to the parent child node from this node
+ *
+ *  This function returns a pointer to the parent node of @a the_node.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_parent(
+  rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Parent( the_node );
+}
+
+/**
+ *  @brief Are Two Nodes Equal
+ *
+ *  This function returns true if @a left and @a right are equal,
+ *  and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_are_nodes_equal(
+  const rtems_rbtree_node *left,
+  const rtems_rbtree_node *right
+)
+{
+  return _RBTree_Are_nodes_equal( left, right );
+}
+
+/**
+ *  @brief Is the RBTree Empty
+ *
+ *  This function returns true if there a no nodes on @a the_rbtree and
+ *  false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_empty(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Is_empty( the_rbtree );
+}
+
+/**
+ *  @brief Is this the Minimum Node on the RBTree
+ *
+ *  This function returns true if @a the_node is the min node on @a the_rbtree 
+ *  and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_min(
+  rtems_rbtree_control *the_rbtree,
+  const rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Is_first( the_rbtree, the_node, RBT_LEFT );
+}
+
+/**
+ *  @brief Is this the Maximum Node on the RBTree
+ *
+ *  This function returns true if @a the_node is the max node on @a the_rbtree 
+ *  and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_max(
+  rtems_rbtree_control *the_rbtree,
+  const rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Is_first( the_rbtree, the_node, RBT_RIGHT );
+}
+
+
+/**
+ *  @brief Does this RBTree have only One Node
+ *
+ *  This function returns true if there is only one node on @a the_rbtree and
+ *  false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_has_only_one_node(
+  const rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Has_only_one_node( the_rbtree );
+}
+
+/**
+ *  @brief Is this Node the RBTree Root
+ *
+ *  This function returns true if @a the_node is the root of @a the_rbtree and
+ *  false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool rtems_rbtree_is_root(
+  rtems_rbtree_control    *the_rbtree,
+  const rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Is_root( the_rbtree, the_node );
+}
+
+/** @brief Find the node with given value in the tree
+ *
+ *  This function returns a pointer to the node having value equal to @a value 
+ *  if it exists within @a the_rbtree, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node* rtems_rbtree_find(
+  rtems_rbtree_control *the_rbtree,
+  unsigned int value
+)
+{
+  return _RBTree_Find( the_rbtree, value );
+}
+
+/** @brief Find the node's in-order predecessor 
+ *
+ * This function returns a pointer to the in-order predecessor 
+ * of @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node* rtems_rbtree_predecessor(
+  rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Predecessor( the_node );
+}
+
+/** @brief Find the node's in-order successor 
+ *
+ *  This function returns a pointer to the in-order successor  
+ *  of @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node* rtems_rbtree_successor(
+  rtems_rbtree_node *the_node
+)
+{
+  return _RBTree_Successor( the_node );
+}
+
+/**
+ *  @brief Extract the specified node from a rbtree
+ *
+ *  This routine extracts @a the_node from @a the_rbtree on which it resides.
+ *  It disables interrupts to ensure the atomicity of the extract operation.
+ */
+RTEMS_INLINE_ROUTINE void rtems_rbtree_extract(
+  rtems_rbtree_control *the_rbtree,
+  rtems_rbtree_node *the_node
+)
+{
+  _RBTree_Extract( the_rbtree, the_node );
+}
+
+/**
+ *  @brief Obtain the min node on a rbtree
+ *
+ *  This function removes the min node from @a the_rbtree and returns
+ *  a pointer to that node.  If @a the_rbtree is empty, then NULL is returned.
+ *  It disables interrupts to ensure the atomicity of the get operation.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_get_min(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Get( the_rbtree, RBT_LEFT );
+}
+
+/**
+ *  @brief Obtain the max node on a rbtree
+ *
+ *  This function removes the max node from @a the_rbtree and returns
+ *  a pointer to that node.  If @a the_rbtree is empty, then NULL is returned.
+ *  It disables interrupts to ensure the atomicity of the get operation.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_get_max(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Get( the_rbtree, RBT_RIGHT );
+}
+
+/**
+ *  @brief Peek at the min node on a rbtree
+ *
+ *  This function returns a pointer to the min node from @a the_rbtree 
+ *  without changing the tree.  If @a the_rbtree is empty, 
+ *  then NULL is returned.
+ *  It disables interrupts to ensure the atomicity of the peek operation.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_peek_min(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Peek( the_rbtree, RBT_LEFT );
+}
+
+/**
+ *  @brief Peek at the max node on a rbtree
+ *
+ *  This function returns a pointer to the max node from @a the_rbtree 
+ *  without changing the tree.  If @a the_rbtree is empty, 
+ *  then NULL is returned.
+ *  It disables interrupts to ensure the atomicity of the peek operation.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_node *rtems_rbtree_peek_max(
+  rtems_rbtree_control *the_rbtree
+)
+{
+  return _RBTree_Peek( the_rbtree, RBT_RIGHT );
+}
+
+
+/**
+ *  @brief Find the control header of the tree containing a given node.
+ *
+ *  This routine finds the rtems_rbtree_control structure of the tree 
+ *  containing @a the_node.
+ *  It disables interrupts to ensure the atomicity of the find operation.
+ */
+RTEMS_INLINE_ROUTINE rtems_rbtree_control *rtems_rbtree_find_header(
+  rtems_rbtree_node *the_node
+)
+{
+  return(_RBTree_Find_header( the_node ));
+}
+
+/**
+ *  @brief Insert a node on a rbtree
+ *
+ *  This routine inserts @a the_node on @a the_rbtree.
+ *  It disables interrupts to ensure the atomicity of the insert operation.
+ */
+RTEMS_INLINE_ROUTINE void rtems_rbtree_insert(
+  rtems_rbtree_control *the_rbtree,
+  rtems_rbtree_node *the_node
+)
+{
+  _RBTree_Insert( the_rbtree, the_node );
+}
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/Makefile.am rtems/cpukit/sapi/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/Makefile.am	2010-06-29 13:52:47.000000000 -0400
+++ rtems/cpukit/sapi/Makefile.am	2010-07-20 13:12:58.000000000 -0400
@@ -10,12 +10,13 @@ include_rtemsdir = $(includedir)/rtems
 include_rtems_HEADERS = include/confdefs.h
 include_rtems_HEADERS += include/rtems/chain.h include/rtems/config.h \
     include/rtems/extension.h include/rtems/fatal.h include/rtems/init.h \
-    include/rtems/io.h include/rtems/mptables.h include/rtems/sptables.h
+    include/rtems/io.h include/rtems/mptables.h include/rtems/rbtree.h \
+		include/rtems/sptables.h
 
 EXTRA_DIST = include/rtems/README
 
 include_rtems_HEADERS += inline/rtems/chain.inl \
-    inline/rtems/extension.inl
+    inline/rtems/extension.inl inline/rtems/rbtree.inl
 
 ## src
 AM_CPPFLAGS += -D__RTEMS_INSIDE__
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/preinstall.am rtems/cpukit/sapi/preinstall.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/preinstall.am	2010-07-30 13:48:39.000000000 -0400
+++ rtems/cpukit/sapi/preinstall.am	2010-08-13 11:51:18.000000000 -0400
@@ -60,6 +60,10 @@ $(PROJECT_INCLUDE)/rtems/mptables.h: inc
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/mptables.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/mptables.h
 
+$(PROJECT_INCLUDE)/rtems/rbtree.h: include/rtems/rbtree.h $(PROJECT_INCLUDE)/rtems/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rbtree.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rbtree.h
+
 $(PROJECT_INCLUDE)/rtems/sptables.h: include/rtems/sptables.h $(PROJECT_INCLUDE)/rtems/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/sptables.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/sptables.h
@@ -72,6 +76,10 @@ $(PROJECT_INCLUDE)/rtems/extension.inl: 
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/extension.inl
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/extension.inl
 
+$(PROJECT_INCLUDE)/rtems/rbtree.inl: inline/rtems/rbtree.inl $(PROJECT_INCLUDE)/rtems/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rbtree.inl
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rbtree.inl
+
 $(PROJECT_LIB)/libsapi.a: libsapi.a $(PROJECT_LIB)/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_LIB)/libsapi.a
 TMPINSTALL_FILES += $(PROJECT_LIB)/libsapi.a
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/src/exinit.c rtems/cpukit/sapi/src/exinit.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/sapi/src/exinit.c	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/sapi/src/exinit.c	2010-08-13 11:47:35.000000000 -0400
@@ -41,7 +41,9 @@
 #if defined(RTEMS_MULTIPROCESSING)
 #include <rtems/score/mpci.h>
 #endif
+#include <rtems/score/periodic.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/prioritybitmap.h>
 #include <rtems/score/thread.h>
 #include <rtems/score/tod.h>
@@ -130,6 +132,8 @@ void rtems_initialize_data_structures(vo
   _TOD_Handler_initialization();
 
   _Thread_Handler_initialization();
+  
+  _Scheduler_Handler_initialization();
 
   #if defined(RTEMS_MULTIPROCESSING)
     _Objects_MP_Handler_initialization();
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/percpu.h rtems/cpukit/score/include/rtems/score/percpu.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/percpu.h	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/include/rtems/score/percpu.h	2010-08-13 11:48:23.000000000 -0400
@@ -154,13 +154,13 @@ extern Per_CPU_Control _Per_CPU_Informat
  * But on a non-SMP system, these macros are simple references.
  * Thus when built for non-SMP, there should be no performance penalty.
  */
-#define _Thread_Heir              _Per_CPU_Information.heir
-#define _Thread_Executing         _Per_CPU_Information.executing
-#define _Thread_Idle              _Per_CPU_Information.idle
-#define _ISR_Nest_level           _Per_CPU_Information.isr_nest_level
-#define _CPU_Interrupt_stack_low  _Per_CPU_Information.interrupt_stack_low
-#define _CPU_Interrupt_stack_high _Per_CPU_Information.interrupt_stack_high
-#define _Thread_Dispatch_necessary _Per_CPU_Information.dispatch_necessary
+#define _Thread_Heir                _Per_CPU_Information.heir
+#define _Thread_Executing           _Per_CPU_Information.executing
+#define _Thread_Idle                _Per_CPU_Information.idle
+#define _ISR_Nest_level             _Per_CPU_Information.isr_nest_level
+#define _CPU_Interrupt_stack_low    _Per_CPU_Information.interrupt_stack_low
+#define _CPU_Interrupt_stack_high   _Per_CPU_Information.interrupt_stack_high
+#define _Thread_Dispatch_necessary  _Per_CPU_Information.dispatch_necessary
 
 #endif  /* ASM */
 
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/periodic.h rtems/cpukit/score/include/rtems/score/periodic.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/periodic.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/periodic.h	2010-07-29 12:13:54.000000000 -0400
@@ -0,0 +1,316 @@
+/**
+ *  @file  rtems/score/periodic.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the Periodic Manager.
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_PERIODIC_H
+#define _RTEMS_SCORE_PERIODIC_H
+
+/**
+ *  @defgroup ScorePeriodic Periodic Handler
+ *
+ *  This handler encapsulates functionality related to managing sets of threads
+ *  that are periodic tasks.
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *  This is the internal type used for the periodic timing
+ *  statistics.
+ */
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  #include <rtems/score/timestamp.h>
+
+  typedef Timestamp_Control Periodic_Period_time_t;
+#else
+  typedef uint32_t Periodic_Period_time_t;
+#endif
+
+#include <rtems/score/object.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/watchdog.h>
+
+/**
+ *  The following enumerated type defines the states in which a
+ *  period may be.
+ */
+typedef enum {
+  /**
+   * This value indicates the period is off the watchdog chain,
+   * and has never been initialized.
+   */
+  PERIODIC_INACTIVE,
+
+  /**
+   * This value indicates the period is on the watchdog chain, and
+   * the owner is blocked waiting on it.
+   */
+  PERIODIC_OWNER_IS_BLOCKING,
+
+  /**
+   * This value indicates the period is on the watchdog chain, and
+   * running.  The owner should be executed or blocked waiting on
+   * another object.
+   */
+  PERIODIC_ACTIVE,
+
+  /**
+   * This value indicates the period is on the watchdog chain, and
+   * has expired.  The owner should be blocked waiting for the next period.
+   */
+  PERIODIC_EXPIRED_WHILE_BLOCKING,
+
+  /**
+   * This value indicates the period is off the watchdog chain, and
+   * has expired.  The owner is still executing and has taken too much
+   * all time to complete this iteration of the period.
+   */
+  PERIODIC_EXPIRED
+}   Periodic_Period_states;
+
+/**
+ *  The following constant is the interval passed to the rate_monontonic_period
+ *  directive to obtain status information.
+ */
+#define RTEMS_PERIOD_STATUS       WATCHDOG_NO_TIMEOUT
+
+/**
+ *  The following defines the INTERNAL data structure that has the
+ *  statistics kept on each period instance.
+ */
+typedef struct {
+  /** This field contains the number of periods executed. */
+  uint32_t     count;
+  /** This field contains the number of periods missed. */
+  uint32_t     missed_count;
+
+  /** This field contains the least amount of CPU time used in a period. */
+  Thread_CPU_usage_t                   min_cpu_time;
+  /** This field contains the highest amount of CPU time used in a period. */
+  Thread_CPU_usage_t                   max_cpu_time;
+  /** This field contains the total amount of wall time used in a period. */
+  Thread_CPU_usage_t                   total_cpu_time;
+
+  /** This field contains the least amount of wall time used in a period. */
+  Periodic_Period_time_t         min_wall_time;
+  /** This field contains the highest amount of wall time used in a period. */
+  Periodic_Period_time_t         max_wall_time;
+  /** This field contains the total amount of CPU time used in a period. */
+  Periodic_Period_time_t         total_wall_time;
+}  Periodic_Statistics;
+
+
+/**
+ *  The following structure defines the control block used to manage
+ *  each period.
+ */
+typedef struct {
+  /** This field is the object management portion of a Period instance. */
+  Objects_Control                         Object;
+
+  /** This is the timer used to provide the unblocking mechanism. */
+  Watchdog_Control                        Timer;
+
+  /** This field indicates the current state of the period. */
+  Periodic_Period_states                  state;
+
+  /**
+   * This field contains the length of the next period to be
+   * executed.
+   */
+  uint32_t                                next_length;
+
+  /**
+   * This field contains a pointer to the TCB for the thread
+   * which owns and uses this period instance.
+   */
+  Thread_Control                         *owner;
+
+  /**
+   * This field contains the cpu usage value of the owning thread when
+   * the period was initiated.  It is used to compute the period's
+   * statistics.
+   */
+  Thread_CPU_usage_t                      cpu_usage_period_initiated;
+
+  /**
+   * This field contains the wall time value when the period
+   * was initiated.  It is used to compute the period's statistics.
+   */
+  Periodic_Period_time_t                  time_period_initiated;
+
+  /**
+   * This field contains the statistics maintained for the period.
+   */
+  Periodic_Statistics                     Statistics;
+}   Periodic_Control;
+
+/**
+ *  @brief Periodic Period Class Management Structure
+ *
+ *  This instance of Objects_Information is used to manage the
+ *  set of periodic period instances.
+ */
+SCORE_EXTERN Objects_Information _Periodic_Information;
+
+/**
+ *  @brief Periodic Manager Initialization
+ *
+ *  This routine performs the initialization necessary for this manager.
+ */
+void _Periodic_Manager_initialization(void);
+
+/**
+ *  @brief _Periodic_Timeout
+ *
+ *  This routine is invoked when the period represented
+ *  by ID expires.  If the thread which owns this period is blocked
+ *  waiting for the period to expire, then it is readied and the
+ *  period is restarted.  If the owning thread is not waiting for the
+ *  period to expire, then the period is placed in the EXPIRED
+ *  state and not restarted.
+ */
+void _Periodic_Timeout(
+  Objects_Id id,
+  void       *ignored
+);
+
+/**
+ *  @brief _Periodic_Get_status(
+ *
+ *  This routine is invoked to compute the elapsed wall time and cpu
+ *  time for a period.
+ *
+ *  @param[in] the_period points to the period being operated upon.
+ *  @param[out] wall_since_last_period is set to the wall time elapsed
+ *              since the period was initiated.
+ *  @param[out] cpu_since_last_period is set to the cpu time used by the
+ *              owning thread since the period was initiated.
+ *
+ *  @return This routine returns true if the status can be determined
+ *          and false otherwise.
+ */
+bool _Periodic_Get_status(
+  Periodic_Control        *the_period,
+  Periodic_Period_time_t  *wall_since_last_period,
+  Thread_CPU_usage_t            *cpu_since_last_period
+);
+
+/**
+ *  @brief _Periodic_Initiate_statistics(
+ *
+ *  This routine is invoked when a period is initiated via an explicit
+ *  call to rtems_periodic_period for the period's first iteration
+ *  or from _Periodic_Timeout for period iterations 2-n.
+ *
+ *  @param[in] the_period points to the period being operated upon.
+ */
+void _Periodic_Initiate_statistics(
+  Periodic_Control *the_period
+);
+
+/**
+ *  @brief _Periodic_Update_statistics
+ *
+ *  This routine is invoked when a period concludes.
+ */
+void _Periodic_Update_statistics(
+  Periodic_Control    *the_period
+);
+
+/**
+ *  @brief _Periodic_Reset_wall_time_statistics
+ *
+ *  This method resets the statistics information for a period instance.
+ */
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  #define _Periodic_Reset_wall_time_statistics( _the_period ) \
+     do { \
+        /* set the minimums to a large value */ \
+        _Timestamp_Set( \
+          &(_the_period)->Statistics.min_wall_time, \
+          0x7fffffff, \
+          0x7fffffff \
+        ); \
+     } while (0)
+#else
+  #define _Periodic_Reset_wall_time_statistics( _the_period ) \
+     do { \
+        /* set the minimum to a large value */ \
+        (_the_period)->Statistics.min_wall_time = 0xffffffff; \
+     } while (0)
+#endif
+
+/**
+ *  @brief Periodic_Reset_cpu_use_statistics
+ *
+ *  This helper method resets the period CPU usage statistics structure.
+ */
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+  #define _Periodic_Reset_cpu_use_statistics( _the_period ) \
+     do { \
+        /* set the minimums to a large value */ \
+        _Timestamp_Set( \
+          &(_the_period)->Statistics.min_cpu_time, \
+          0x7fffffff, \
+          0x7fffffff \
+        ); \
+     } while (0)
+#else
+  #define _Periodic_Reset_cpu_use_statistics( _the_period ) \
+     do { \
+        /* set the minimum to a large value */ \
+        (_the_period)->Statistics.min_cpu_time = 0xffffffff; \
+     } while (0)
+#endif
+
+/**
+ *  @brief Periodic_Reset_statistics
+ *
+ *  This helper method resets the period wall time statistics structure.
+ */
+#define _Periodic_Reset_statistics( _the_period ) \
+  do { \
+    memset( \
+      &(_the_period)->Statistics, \
+      0, \
+      sizeof( rtems_periodic_period_statistics ) \
+    ); \
+    _Periodic_Reset_cpu_use_statistics( _the_period ); \
+    _Periodic_Reset_wall_time_statistics( _the_period ); \
+  } while (0)
+
+
+
+#ifndef __RTEMS_APPLICATION__
+
+#include <rtems/score/periodic.inl>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/rbtree.h rtems/cpukit/score/include/rtems/score/rbtree.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/rbtree.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/rbtree.h	2010-07-20 13:06:23.000000000 -0400
@@ -0,0 +1,305 @@
+
+/**
+ *  @file  rtems/score/rbtree.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the Red-Black Tree Handler.
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_RBTREE_H
+#define _RTEMS_SCORE_RBTREE_H
+
+/**
+ *  @defgroup ScoreRBTree Red-Black Tree Handler
+ *
+ *  The Red-Black Tree Handler is used to manage sets of entities.  This handler
+ *  provides two data structures.  The rbtree Node data structure is included
+ *  as the first part of every data structure that will be placed on
+ *  a RBTree.  The second data structure is rbtree Control which is used
+ *  to manage a set of rbtree Nodes.
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/address.h>
+
+  /**
+   *  @typedef RBTree_Node
+   *
+   *  This type definition promotes the name for the RBTree Node used by
+   *  all RTEMS code.  It is a separate type definition because a forward
+   *  reference is required to define it.  See @ref RBTree_Node_struct for
+   *  detailed information.
+   */
+  typedef struct RBTree_Node_struct RBTree_Node;
+
+  /**
+   * This enum type defines the colors available for the RBTree Nodes
+   */
+  typedef enum {
+    RBT_BLACK,
+    RBT_RED
+  } RBTree_Color;
+
+  /**
+   *  @struct RBTree_Node_struct
+   *
+   *  This is used to manage each element (node) which is placed
+   *  on a RBT.
+   *
+   *  @note Typically, a more complicated structure will use the
+   *        rbtree package.  The more complicated structure will
+   *        include a rbtree node as the first element in its
+   *        control structure.  It will then call the rbtree package
+   *        with a pointer to that node element.  The node pointer
+   *        and the higher level structure start at the same address
+   *        so the user can cast the pointers back and forth.
+   *
+   */
+  struct RBTree_Node_struct {
+    /** This points to the node's parent */
+    RBTree_Node *parent;
+    /** child[0] points to the left child, child[1] points to the right child */
+    RBTree_Node *child[2];
+    /** This is the integer value stored by this node, used for sorting */
+    unsigned int value;
+    /** The color of the node. Either red or black */
+    RBTree_Color color;
+  };
+
+  /**
+   * @brief macro to return the structure containing the @a node.
+   *
+   * This macro returns a pointer of type @a container_type that points 
+   * to the structure containing @a node, where @a node_field_name is the 
+   * field name of the RBTree_Node structure in @a container_type.
+   *
+   */
+  
+#define _RBTree_Container_of(node,container_type, node_field_name) \
+  ((container_type*) \
+   ((size_t)node - ((size_t)(&((container_type *)0)->node_field_name))))
+
+
+  typedef enum {
+    RBT_LEFT=0,
+    RBT_RIGHT=1
+  } RBTree_Direction;
+
+  /**
+   *  @struct RBTree_Control
+   *
+   * This is used to manage a RBT.  A rbtree consists of a tree of zero or more
+   * nodes.
+   *
+   * @note This implementation does not require special checks for
+   *   manipulating the root element of the RBT.
+   *   To accomplish this the @a RBTree_Control structure can be overlaid 
+   *   with a @ref RBTree_Node structure to act as a "dummy root", 
+   *   which has a NULL parent and its left child is the root.
+   */
+
+  /* the RBTree_Control is actually part of the RBTree structure as an 
+   * RBTree_Node. The mapping of fields from RBTree_Control to RBTree_Node are:
+   *   permanent_null == parent
+   *   root == left
+   *   first[0] == right
+   */
+  typedef struct {
+    /** This points to a NULL. Useful for finding the root. */
+    RBTree_Node *permanent_null;
+    /** This points to the root node of the RBT. */
+    RBTree_Node *root;
+    /** This points to the min and max nodes of this RBT. */
+    RBTree_Node *first[2];
+  } RBTree_Control;
+
+  /**
+   *  @brief RBTree initializer for an empty rbtree with designator @a name.
+   */
+#define RBTREE_INITIALIZER_EMPTY(name) \
+  { \
+    .permanent_null = NULL, \
+    .root = NULL, \
+    .first[0] = NULL, \
+    .first[1] = NULL, \
+  }
+
+  /**
+   *  @brief RBTree definition for an empty rbtree with designator @a name.
+   */
+#define RBTREE_DEFINE_EMPTY(name) \
+  RBTree_Control name = RBTREE_INITIALIZER_EMPTY(name)
+
+  /**
+   *  @brief RBTree_Node initializer for an empty node with designator @a name.
+   */
+#define RBTREE_NODE_INITIALIZER_EMPTY(name) \
+  { \
+    .parent = NULL, \
+    .child[0] = NULL, \
+    .child[1] = NULL, \
+    .value = -1, \
+    RBT_RED \
+  }
+
+  /**
+   *  @brief RBTree definition for an empty rbtree with designator @a name.
+   */
+#define RBTREE_NODE_DEFINE_EMPTY(name) \
+  RBTree_Node name = RBTREE_NODE_INITIALIZER_EMPTY(name)
+
+
+
+
+  /**
+   *  @brief Initialize a RBTree Header
+   *
+   *  This routine initializes @a the_rbtree structure to manage the
+   *  contiguous array of @a number_nodes nodes which starts at
+   *  @a starting_address.  Each node is of @a node_size bytes.
+   */
+  void _RBTree_Initialize(
+      RBTree_Control *the_rbtree,
+      void          *starting_address,
+      size_t         number_nodes,
+      size_t         node_size
+      );
+
+  /**
+   *  @brief Obtain the min or max node of a rbtree
+   *
+   *  This function removes the min or max node from @a the_rbtree and returns
+   *  a pointer to that node.  If @a the_rbtree is empty, then NULL is returned.
+   *  @a dir specifies whether to return the min (0) or max (1).
+   *
+   *  @return This method returns a pointer to a node.  If a node was removed,
+   *          then a pointer to that node is returned.  If @a the_rbtree was
+   *          empty, then NULL is returned.
+   *
+   *  @note It disables interrupts to ensure the atomicity of the get operation.
+   */
+  RBTree_Node *_RBTree_Get(
+      RBTree_Control *the_rbtree,
+      RBTree_Direction dir
+      );
+
+  /**
+   *  @brief Check the min or max node on a rbtree
+   *
+   *  This function returns a pointer to the min or max node of @a the_rbtree.
+   *  If @a the_rbtree is empty, then NULL is returned. @a dir specifies 
+   *  whether to return the min (0) or max (1).
+   *
+   *  @return This method returns a pointer to a node.
+   *          If @a the_rbtree was empty, then NULL is returned.
+   *
+   *  @note It disables interrupts to ensure the atomicity of the get operation.
+   */
+  RBTree_Node *_RBTree_Peek(
+      RBTree_Control *the_rbtree,
+      RBTree_Direction dir
+      );
+
+  /** @brief Find the node with given value in the tree
+   *
+   *  This function returns a pointer to the node with value equal to @a value 
+   *  if it exists in the Red-Black Tree @a the_rbtree, and NULL if not. 
+   */
+  RBTree_Node *_RBTree_Find(
+      RBTree_Control *the_rbtree, 
+      unsigned int value
+      );
+
+  /** @brief Find the control structure of the tree containing the given node 
+   *
+   *  This function returns a pointer to the control structure of the tree 
+   *  containing @a the_node, if it exists, and NULL if not. 
+   */
+  RBTree_Control *_RBTree_Find_header(
+      RBTree_Node *the_node
+      );
+
+  /** @brief Insert a Node (unprotected)
+   *
+   *  This routine inserts @a the_node on the Red-Black Tree @a the_rbtree.
+   *
+   *  @retval 0 Successfully inserted.
+   *  @retval -1 NULL @a the_node.
+   *  @retval RBTree_Node* if one with equal value to @a the_node->value exists 
+   *          in @a the_rbtree.
+   *
+   *  @note It does NOT disable interrupts to ensure the atomicity
+   *        of the extract operation.
+   */
+  RBTree_Node *_RBTree_Insert_unprotected(
+      RBTree_Control *the_rbtree,
+      RBTree_Node *the_node
+  );
+
+  /**
+   *  @brief Insert a node on a rbtree
+   *
+   *  This routine inserts @a the_node on the tree @a the_rbtree.
+   *
+   *  @note It disables interrupts to ensure the atomicity
+   *  of the extract operation.
+   */
+  void _RBTree_Insert(
+      RBTree_Control *the_rbtree,
+      RBTree_Node *the_node
+      );
+
+
+  /** @brief Extract a Node (unprotected)
+   *
+   *  This routine extracts (removes) @a the_node from @a the_rbtree.
+   *
+   *  @note It does NOT disable interrupts to ensure the atomicity
+   *        of the extract operation.
+   */
+
+  void _RBTree_Extract_unprotected(
+      RBTree_Control *the_rbtree,
+      RBTree_Node *the_node
+  );
+
+
+  /**
+   *  @brief Delete a node from the rbtree
+   *
+   *  This routine deletes @a the_node from @a the_rbtree.
+   *
+   *  @note It disables interrupts to ensure the atomicity of the
+   *  append operation.
+   */
+  void _RBTree_Extract(
+      RBTree_Control *the_rbtree,
+      RBTree_Node    *the_node
+      );
+
+#ifndef __RTEMS_APPLICATION__
+#include <rtems/score/rbtree.inl>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqedf.h rtems/cpukit/score/include/rtems/score/readyqedf.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqedf.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/readyqedf.h	2010-07-29 14:26:59.000000000 -0400
@@ -0,0 +1,121 @@
+/**
+ *  @file  rtems/score/readyqedf.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a edf-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_READYQEDF_H
+#define _RTEMS_SCORE_READYQEDF_H
+
+/**
+ *  @addtogroup ScoreReadyQ
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/thread.h>
+
+/*
+ * This structure is the Queues.EDF field of Ready_queue_Control when 
+ * using the EDF scheduling.   
+ */
+struct Ready_queue_edf_Control_struct {
+  RBTree_Control edf_rbtree;
+
+  Chain_Control deadline_queue;
+  Chain_Control fifo_queue;
+};
+
+/** @brief  Ready queue Initialize
+ *
+ *  This routine initializes @a the_ready_queue for edf-based scheduling.
+ */
+void _Ready_queue_edf_Initialize(
+  Ready_queue_Control         *the_ready_queue
+);
+
+/** @brief  Ready queue Enqueue
+ *
+ *  This routine enqueues @a the_thread on the edf-based
+ *  @a the_ready_queue.
+ */
+void _Ready_queue_edf_Enqueue(
+  Ready_queue_Control        *the_ready_queue,
+  Thread_Control             *the_thread
+);
+
+/** @brief  Ready queue Extract
+ *
+ *  This routine removes @a the_thread from edf-based @a the_ready_queue
+ */
+void _Ready_queue_edf_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+/** @brief  Ready queue First
+ *
+ *  This function returns a pointer to the "first" thread
+ *  on the_ready_queue.  For edf-based scheduling, this is 
+ *  the ready thread with the earliest deadline.
+ */
+Thread_Control *_Ready_queue_edf_First(
+  Ready_queue_Control *the_ready_queue
+);
+
+/*
+ *  @brief  _Ready_queue_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. For 
+ *  edf-based scheduling the thread will be the first thread
+ *  with its deadline.
+ *
+ *  TODO: is this dead code?
+ *  
+ */
+
+void _Ready_queue_edf_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+);
+
+/**
+ *  @brief Ready queue Requeue
+ *
+ *  This routine is invoked when a thread changes priority and remains
+ *  ready.  For edf-based ordering,
+ *  the_thread is removed from the_ready_queue and reinserted.  
+ *  This method has no impact on the state of the_thread
+ *
+ */
+void _Ready_queue_edf_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqfifo.h rtems/cpukit/score/include/rtems/score/readyqfifo.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqfifo.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/readyqfifo.h	2010-07-28 15:45:25.000000000 -0400
@@ -0,0 +1,106 @@
+/**
+ *  @file  rtems/score/readyqfifo.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a FIFO ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_READYQFIFO_H
+#define _RTEMS_SCORE_READYQFIFO_H
+
+/**
+ *  @addtogroup ScoreReadyQ
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/readyq.h>
+#include <rtems/score/thread.h>
+
+/** @brief  Ready queue Initialize
+ *
+ *  This routine initializes @a the_ready_queue for fifo-based scheduling.
+ */
+void _Ready_queue_fifo_Initialize(
+  Ready_queue_Control         *the_ready_queue
+);
+
+/** @brief  Ready queue Enqueue
+ *
+ *  This routine enqueues @a the_thread on the fifo-based
+ *  @a the_ready_queue.
+ */
+void _Ready_queue_fifo_Enqueue(
+  Ready_queue_Control        *the_ready_queue,
+  Thread_Control             *the_thread
+);
+
+/*
+ *  @brief  _Ready_queue_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. For 
+ *  fifo-based scheduling the thread will be the first thread
+ *  at its fifo level.
+ *  
+ */
+
+void _Ready_queue_fifo_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+);
+
+/** @brief  Ready queue Extract
+ *
+ *  This routine removes @a the_thread from fifo-based @a the_ready_queue
+ */
+void _Ready_queue_fifo_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+/** @brief  Ready queue First
+ *
+ *  This function returns a pointer to the "first" thread
+ *  on the_ready_queue.  For fifo-based scheduling, this is 
+ *  the highest fifo ready thread.
+ */
+Thread_Control *_Ready_queue_fifo_First(
+  Ready_queue_Control *the_ready_queue
+);
+
+/**
+ *  @brief Ready queue Requeue
+ *
+ *  This routine is invoked when a thread changes fifo and remains
+ *  ready.  For fifo-based ordering,
+ *  the_thread is removed from the_ready_queue and reinserted using
+ *  its new fifo.  This method has no impact on the state of the_thread
+ */
+void _Ready_queue_fifo_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyq.h rtems/cpukit/score/include/rtems/score/readyq.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyq.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/readyq.h	2010-07-29 11:03:08.000000000 -0400
@@ -0,0 +1,112 @@
+/**
+ *  @file  rtems/score/readyq.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a ready queue.
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_READYQ_H
+#define _RTEMS_SCORE_READYQ_H
+
+/**
+ *  @defgroup ScoreReadyQ Ready Queue Handler
+ *
+ *  This handler encapsulates functionality related to managing sets of threads
+ *  that are ready for execution.
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/percpu.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/rbtree.h>
+
+typedef struct Ready_queue_edf_Control_struct Ready_queue_edf_Control;
+typedef struct Ready_queue_Control_struct Ready_queue_Control;
+
+/**
+ * function jump table that holds pointers to the functions that 
+ * implement the ready queue structure-specific code
+ */
+typedef struct {
+  /*
+   * enqueues the given thread on the ready queue.
+   */
+  void ( *enqueue )( Ready_queue_Control *, Thread_Control * );
+
+  /*
+   * enqueues the given thread at the head of the ready queue, respecting 
+   * the scheduling policy. e.g. for priority-based scheduling the thread
+   * will be the first thread at its priority level.
+   */
+  void ( *enqueue_first )( Ready_queue_Control *, Thread_Control * );
+
+  /*
+   * Removes a thread from the ready queue.
+   */
+  void ( *extract )( Ready_queue_Control *, Thread_Control * );
+
+  /*
+   * Returns a pointer to the first (head) thread on the ready queue.
+   */
+  Thread_Control * ( *first )( Ready_queue_Control * );
+
+  /*
+   * Removes and reinserts a thread on the ready queue.
+   */
+  void ( *requeue )( Ready_queue_Control *, Thread_Control * );
+
+} Ready_queue_Operations;
+
+/**
+ *  This is the structure used to manage sets of tasks which are ready to 
+ *  use the CPU.
+ */
+struct Ready_queue_Control_struct {
+  /** 
+   *  This union contains the pointer to the data structure used to manage 
+   *  the ready set of tasks. The pointer varies based upon the type of 
+   *  ready queue required by the scheduler.
+   */
+  union {
+    /** 
+     * This is the set of lists (an array of Chain_Control) for 
+     * priority scheduling. 
+     */
+    Chain_Control            *Priority;
+
+    /** This points to the Chain_Control for a simple FIFO list. */
+    Chain_Control            *Fifo;
+
+    Ready_queue_edf_Control  *EDF;
+  } Queues;
+
+  /** The jump table for ready queue structure-specific functions */
+  Ready_queue_Operations rq_ops;
+};
+
+#ifndef __RTEMS_APPLICATION__
+#include <rtems/score/readyq.inl>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqpriority.h rtems/cpukit/score/include/rtems/score/readyqpriority.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/readyqpriority.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/readyqpriority.h	2010-07-28 15:45:51.000000000 -0400
@@ -0,0 +1,107 @@
+/**
+ *  @file  rtems/score/readyqpriority.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a priority-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_READYQPRIORITY_H
+#define _RTEMS_SCORE_READYQPRIORITY_H
+
+/**
+ *  @addtogroup ScoreReadyQ
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/thread.h>
+
+/** @brief  Ready queue Initialize
+ *
+ *  This routine initializes @a the_ready_queue for priority-based scheduling.
+ */
+void _Ready_queue_priority_Initialize(
+  Ready_queue_Control         *the_ready_queue
+);
+
+/** @brief  Ready queue Enqueue
+ *
+ *  This routine enqueues @a the_thread on the priority-based
+ *  @a the_ready_queue.
+ */
+void _Ready_queue_priority_Enqueue(
+  Ready_queue_Control        *the_ready_queue,
+  Thread_Control             *the_thread
+);
+
+/*
+ *  @brief  _Ready_queue_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. For 
+ *  priority-based scheduling the thread will be the first thread
+ *  at its priority level.
+ *  
+ */
+
+void _Ready_queue_priority_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+);
+
+/** @brief  Ready queue Extract
+ *
+ *  This routine removes @a the_thread from priority-based @a the_ready_queue
+ */
+void _Ready_queue_priority_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+/** @brief  Ready queue First
+ *
+ *  This function returns a pointer to the "first" thread
+ *  on the_ready_queue.  For priority-based scheduling, this is 
+ *  the highest priority ready thread.
+ */
+Thread_Control *_Ready_queue_priority_First(
+  Ready_queue_Control *the_ready_queue
+);
+
+/**
+ *  @brief Ready queue Requeue
+ *
+ *  This routine is invoked when a thread changes priority and remains
+ *  ready.  For priority-based ordering,
+ *  the_thread is removed from the_ready_queue and reinserted using
+ *  its new priority.  This method has no impact on the state of the_thread
+ */
+void _Ready_queue_priority_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/scheduleredf.h rtems/cpukit/score/include/rtems/score/scheduleredf.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/scheduleredf.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/scheduleredf.h	2010-07-29 17:55:13.000000000 -0400
@@ -0,0 +1,87 @@
+/**
+ *  @file  rtems/score/scheduleredf.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a edf-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULEREDF_H
+#define _RTEMS_SCORE_SCHEDULEREDF_H
+
+/**
+ *  @addtogroup ScoreScheduler
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/scheduler.h>
+
+/* 
+ * Include generic scheduling implementations that rely on the ready queue 
+ * implementation to provide scheduling logic.
+ */
+#include <rtems/score/schedulerqueue.h>
+
+/**
+ * This routine initializes the edf scheduler.
+ */
+void _Scheduler_edf_Initialize( Scheduler_Control *sched );
+
+/**
+ * This routine allocates the sched field for a new thread.
+ */
+void * _Scheduler_edf_Sched_allocate(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+/**
+ * This routine frees the sched field 
+ */
+void _Scheduler_edf_Sched_free(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+/**
+ * This routine udpates the sched field of a thread based on the scheduler 
+ * structures and thread state
+ */
+void _Scheduler_edf_Sched_update(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+/**
+ * EDF specific routines
+ */
+#include <rtems/score/periodic.h>
+
+void _Scheduler_edf_Release_job(
+      Periodic_Control *the_period 
+    );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerfifo.h rtems/cpukit/score/include/rtems/score/schedulerfifo.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerfifo.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/schedulerfifo.h	2010-07-28 12:16:36.000000000 -0400
@@ -0,0 +1,51 @@
+/**
+ *  @file  rtems/score/schedulerfifo.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a fifo-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULERFIFO_H
+#define _RTEMS_SCORE_SCHEDULERFIFO_H
+
+/**
+ *  @addtogroup ScoreScheduler
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/scheduler.h>
+
+/* Include generic scheduling implementations that rely on the ready queue 
+ * implementation to provide scheduling logic.
+ */
+#include <rtems/score/schedulerqueue.h>
+
+/**
+ * This routine initializes the fifo scheduler.
+ */
+void _Scheduler_fifo_Initialize( Scheduler_Control *sched );
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/scheduler.h rtems/cpukit/score/include/rtems/score/scheduler.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/scheduler.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/scheduler.h	2010-07-29 11:09:54.000000000 -0400
@@ -0,0 +1,176 @@
+/**
+ *  @file  rtems/score/scheduler.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the scheduler.
+ */
+
+/*
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULER_H
+#define _RTEMS_SCORE_SCHEDULER_H
+
+/**
+ *  @defgroup ScoreScheduler Scheduler Handler
+ *
+ *  This handler encapsulates functionality related to managing sets of threads
+ *  that are ready for execution.
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/percpu.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/readyq.h>
+
+/* 
+ * These defines are used to set the scheduler_policy value. The values 
+ * must correspond directly with the order of the fields in the scheduler
+ * table (Scheduler_Table_t), because the Configuration.scheduler_policy 
+ * field is used to index the scheduler table.
+ */
+#define _Scheduler_USER     (0)
+#define _Scheduler_PRIORITY (1)
+#define _Scheduler_FIFO     (2)
+#define _Scheduler_EDF      (3)
+
+typedef struct Scheduler_Control_struct Scheduler_Control;
+
+/*
+ * The Scheduler_Table_t type defines the scheduler initialization table, 
+ * which is set up by confdefs.h based on the user's choice of scheduler 
+ * policy.
+ */
+typedef struct {
+  void (*sched_init)( Scheduler_Control * );
+} Scheduler_Table_t;
+
+/* instantiated and initialized in confdefs.h */
+extern const Scheduler_Table_t _Scheduler_Table[]; 
+
+/**
+ * The following Scheduler_Per_thread_xxx structures are used to 
+ * hold per-thread data used by the scheduler.  Thread_Control->sched is a 
+ * union of pointers, one for each of the following structures.  The
+ * sched->xxx field points to an instantion of one of these structures, 
+ * which is allocated from the workspace during _Thread_Start.
+ */
+
+/**
+ * Per-thread data related to the _SCHED_PRI scheduling policy.
+ */
+typedef struct {
+  /** This field points to the Ready FIFO for this thread's priority. */
+  Chain_Control *ready_chain;
+
+  /** This field contains precalculated priority map indices. */
+  Priority_bit_map_Information    Priority_map;
+} Scheduler_priority_Per_thread;
+
+/**
+ * Per-thread data related to the _SCHED_FIFO scheduling policy.
+ */
+typedef struct {
+  char nothing; /* it doesn't matter, this is never instantiated. */
+} Scheduler_fifo_Per_thread;
+
+/**
+ * Per-thread data related to the _SCHED_EDF scheduling policy.
+ */
+typedef struct {
+  /** Point back to this thread. */
+  Thread_Control                   *this_thread;
+
+  /** This field contains the thread's deadline information. */
+  RBTree_Node                       deadline;
+
+  unsigned int                      absolute_deadline;
+
+  /** 
+   * This field points to the last node in the ready queue that has 
+   * the same deadline (absolute) as this thread.
+   */
+  Chain_Node                       *last_duplicate;
+} Scheduler_edf_Per_thread;
+
+
+/**
+ * function jump table that holds pointers to the functions that 
+ * implement specific schedulers.
+ */
+typedef struct {
+  /** Implements the scheduling decision logic (policy). */
+  void ( *schedule ) ( Scheduler_Control * );
+
+  /** Voluntarily yields the processor per the scheduling policy. */
+  void ( *yield ) ( Scheduler_Control * );
+
+  /** Removes the given thread from scheduling decisions. */
+  void ( *block ) ( Scheduler_Control *, Thread_Control * );
+
+  /** Adds the given thread to scheduling decisions. */
+  void ( *unblock ) ( Scheduler_Control *, Thread_Control * );
+
+  /** allocates the sched field of the given thread */
+  void * ( *sched_allocate ) ( Scheduler_Control *, Thread_Control * );
+
+  /** frees the sched field of the given thread */
+  void ( *sched_free ) ( Scheduler_Control *, Thread_Control * );
+  
+  /** updates the sched field of the given thread */
+  void ( *sched_update ) ( Scheduler_Control *, Thread_Control * );
+} Scheduler_Operations;
+
+/**
+ * This is the structure used to manage the scheduler.
+ */
+struct Scheduler_Control_struct {
+
+  /* A scheduler defines its own ready queue. */
+  Ready_queue_Control ready_queue;
+
+  /** The jump table for scheduler-specific functions */
+  Scheduler_Operations s_ops;
+};
+
+/* TODO: make this per-cpu? then _Scheduler will be a macro. */
+/**
+ *  The following points to the structures used to manage the
+ *  scheduler.
+ */
+SCORE_EXTERN Scheduler_Control _Scheduler;
+
+
+/**
+ *  This routine initializes the scheduler to the policy chosen by the user 
+ *  through confdefs, or to the priority scheduler with ready chains by
+ *  default.
+ */
+void _Scheduler_Handler_initialization( void );
+
+#ifndef __RTEMS_APPLICATION__
+#include <rtems/score/scheduler.inl>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerpriority.h rtems/cpukit/score/include/rtems/score/schedulerpriority.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerpriority.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/schedulerpriority.h	2010-07-28 12:17:28.000000000 -0400
@@ -0,0 +1,76 @@
+/**
+ *  @file  rtems/score/schedulerpriority.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a priority-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULERPRIORITY_H
+#define _RTEMS_SCORE_SCHEDULERPRIORITY_H
+
+/**
+ *  @addtogroup ScoreScheduler
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/scheduler.h>
+
+/* Include generic scheduling implementations that rely on the ready queue 
+ * implementation to provide scheduling logic.
+ */
+#include <rtems/score/schedulerqueue.h>
+
+/**
+ * This routine initializes the priority scheduler.
+ */
+void _Scheduler_priority_Initialize( Scheduler_Control *sched );
+
+/**
+ * This routine allocates the sched field for a new thread.
+ */
+void * _Scheduler_priority_Sched_allocate(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+/**
+ * This routine frees the sched field 
+ */
+void _Scheduler_priority_Sched_free(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+/**
+ * This routine udpates the sched field of a thread based on the scheduler 
+ * structures and thread state
+ */
+void _Scheduler_priority_Sched_update(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerqueue.h rtems/cpukit/score/include/rtems/score/schedulerqueue.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/schedulerqueue.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/include/rtems/score/schedulerqueue.h	2010-07-29 10:34:22.000000000 -0400
@@ -0,0 +1,87 @@
+/**
+ *  @file  rtems/score/schedulerqueue.h
+ *
+ *  This include file contains all the constants and structures associated
+ *  with the manipulation of threads on a priority-based ready queue.
+ */
+
+/*
+ *  COPYRIGHT (c) 2010.
+ *  Gedare Bloom
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULERQUEUE_H
+#define _RTEMS_SCORE_SCHEDULERQUEUE_H
+
+/**
+ *  @addtogroup ScoreScheduler
+ *
+ */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rtems/score/scheduler.h>
+
+/* 
+ * Generic scheduling implementations that rely on the ready queue 
+ * implementation to provide scheduling logic. 
+ * Note: There is no "queue" scheduler.
+ */
+
+/**
+ *  This kernel routine sets the heir thread to be the next ready thread 
+ *  on the ready queue by invoking sched->ready_queue->rq_ops->first().
+ */
+void _Scheduler_queue_Schedule(
+    Scheduler_Control *sched 
+);
+
+/**
+ *  This routine is invoked when a thread wishes to voluntarily
+ *  transfer control of the processor to another thread in the queue.
+ *  It invokes sched->ready_queue->rq_ops->requeue() followed by a 
+ *  call to sched->s_ops->schedule().
+ */
+void _Scheduler_queue_Yield( Scheduler_Control *sched );
+
+/**
+ *  This routine removes @a the_thread from the scheduling decision, 
+ *  that is, removes it from the ready queue.  It performs
+ *  any necessary scheduling operations including the selection of
+ *  a new heir thread.
+ */
+void _Scheduler_queue_Block( 
+    Scheduler_Control *sched,
+    Thread_Control *the_thread 
+);
+
+/**
+ *  This routine adds @a the_thread to the scheduling decision, 
+ *  that is, adds it to the ready queue and 
+ *  updates any appropriate scheduling variables, for example the heir thread.
+ */
+void _Scheduler_queue_Unblock(
+    Scheduler_Control *sched,
+    Thread_Control *the_thread 
+);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/thread.h rtems/cpukit/score/include/rtems/score/thread.h
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/include/rtems/score/thread.h	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/score/include/rtems/score/thread.h	2010-08-13 11:49:07.000000000 -0400
@@ -70,6 +70,7 @@ extern "C" {
 #endif
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/prioritybitmap.h>
 #include <rtems/score/stack.h>
 #include <rtems/score/states.h>
@@ -390,10 +391,12 @@ struct Thread_Control_struct {
    *  since it was created.
    */
   Thread_CPU_usage_t                    cpu_time_used;
-  /** This field points to the Ready FIFO for this priority. */
-  Chain_Control                        *ready;
-  /** This field contains precalculated priority map indices. */
-  Priority_bit_map_Information          Priority_map;
+  /** This union holds per-thread data for the scheduler and ready queue. */
+  union {
+    Scheduler_priority_Per_thread      *priority;
+    Scheduler_fifo_Per_thread          *fifo;
+    Scheduler_edf_Per_thread           *edf;
+  } sched;
   /** This field contains information about the starting state of
    *  this thread.
    */
@@ -456,12 +459,6 @@ SCORE_EXTERN uint32_t   _Thread_Maximum_
 SCORE_EXTERN uint32_t   _Thread_Ticks_per_timeslice;
 
 /**
- *  The following points to the array of FIFOs used to manage the
- *  set of ready threads.
- */
-SCORE_EXTERN Chain_Control *_Thread_Ready_chain;
-
-/**
  *  The following points to the thread whose floating point
  *  context is currently loaded.
  */
@@ -654,13 +651,6 @@ void _Thread_Set_transient(
 void _Thread_Tickle_timeslice( void );
 
 /**
- *  This routine is invoked when a thread wishes to voluntarily
- *  transfer control of the processor to another thread of equal
- *  or greater priority.
- */
-void _Thread_Yield_processor( void );
-
-/**
  *  This routine initializes the context of the_thread to its
  *  appropriate starting state.
  */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/periodic.inl rtems/cpukit/score/inline/rtems/score/periodic.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/periodic.inl	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/inline/rtems/score/periodic.inl	2010-07-22 15:33:26.000000000 -0400
@@ -0,0 +1,135 @@
+/** 
+ *  @file  rtems/score/periodic.inl
+ *
+ *  This inline file contains all of the inlined routines associated with
+ *  the Periodic Manager.
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_PERIODIC_H
+# error "Never use <rtems/score/periodic.inl> directly; include <rtems/score/periodic.h> instead."
+#endif
+
+#ifndef _RTEMS_SCORE_PERIODIC_INL
+#define _RTEMS_SCORE_PERIODIC_INL
+
+/**
+ *  @addtogroup ScorePeriodic
+ * @{
+ */
+
+/**
+ *  @brief Periodic_Allocate
+ *
+ *  This function allocates a period control block from
+ *  the inactive chain of free period control blocks.
+ */
+RTEMS_INLINE_ROUTINE Periodic_Control *_Periodic_Allocate( void )
+{
+  return (Periodic_Control *)
+    _Objects_Allocate( &_Periodic_Information );
+}
+
+/**
+ *  @brief Periodic_Free
+ *
+ *  This routine allocates a period control block from
+ *  the inactive chain of free period control blocks.
+ */
+RTEMS_INLINE_ROUTINE void _Periodic_Free (
+  Periodic_Control *the_period
+)
+{
+  _Objects_Free( &_Periodic_Information, &the_period->Object );
+}
+
+/**
+ *  @brief Periodic_Get
+ *
+ *  This function maps period IDs to period control blocks.
+ *  If ID corresponds to a local period, then it returns
+ *  the_period control pointer which maps to ID and location
+ *  is set to OBJECTS_LOCAL.  Otherwise, location is set
+ *  to OBJECTS_ERROR and the_period is undefined.
+ */
+RTEMS_INLINE_ROUTINE Periodic_Control *_Periodic_Get (
+  Objects_Id         id,
+  Objects_Locations *location
+)
+{
+  return (Periodic_Control *)
+    _Objects_Get( &_Periodic_Information, id, location );
+}
+
+/**
+ *  @brief Periodic_Is_active
+ *
+ *  This function returns TRUE if the_period is in the ACTIVE state,
+ *  and FALSE otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _Periodic_Is_active (
+  Periodic_Control *the_period
+)
+{
+  return (the_period->state == PERIODIC_ACTIVE);
+}
+
+/**
+ *  @brief Periodic_Is_inactive
+ *
+ *  This function returns TRUE if the_period is in the ACTIVE state,
+ *  and FALSE otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _Periodic_Is_inactive (
+  Periodic_Control *the_period
+)
+{
+  return (the_period->state == PERIODIC_INACTIVE);
+}
+
+/**
+ *  @brief Periodic_Is_expired
+ *
+ *  This function returns TRUE if the_period is in the EXPIRED state,
+ *  and FALSE otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _Periodic_Is_expired (
+  Periodic_Control *the_period
+)
+{
+  return (the_period->state == PERIODIC_EXPIRED);
+}
+
+/**
+ *  @brief Periodic_Is_null
+ *
+ *  This function returns TRUE if the_period is NULL and FALSE otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _Periodic_Is_null (
+  Periodic_Control *the_period
+)
+{
+  return (the_period == NULL);
+}
+
+
+
+
+
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/rbtree.inl rtems/cpukit/score/inline/rtems/score/rbtree.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/rbtree.inl	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/inline/rtems/score/rbtree.inl	2010-07-20 13:41:06.000000000 -0400
@@ -0,0 +1,440 @@
+/**
+ *  @file  rtems/score/rbtree.inl
+ *
+ *  This include file contains the bodies of the routines which are
+ *  associated with Red-Black Trees and inlined.
+ *
+ *  @note  The routines in this file are ordered from simple
+ *         to complex.  No other RBTree Handler routine is referenced
+ *         unless it has already been defined.
+ */
+
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_RBTREE_H
+# error "Never use <rtems/score/rbtree.inl> directly; include <rtems/score/rbtree.h> instead."
+#endif
+
+#ifndef _RTEMS_SCORE_RBTREE_INL
+#define _RTEMS_SCORE_RBTREE_INL
+
+/**
+ *  @addtogroup ScoreRBTree 
+ *  @{
+ */
+
+/** @brief Set off rbtree
+ *
+ *  This function sets the parent and child fields of the @a node to NULL
+ *  indicating the @a node is not part of a rbtree.
+ *
+ */
+RTEMS_INLINE_ROUTINE void _RBTree_Set_off_rbtree(
+    RBTree_Node *node
+    )
+{
+  node->parent = node->child[RBT_LEFT] = node->child[RBT_RIGHT] = NULL;
+}
+
+/** @brief Is the Node off RBTree
+ *
+ *  This function returns true if the @a node is not on a rbtree. A @a node is
+ *  off rbtree if the parent and child fields are set to NULL.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_node_off_rbtree(
+    const RBTree_Node *node
+    )
+{
+  return (node->parent == NULL) && (node->child[RBT_LEFT] == NULL) && (node->child[RBT_RIGHT] == NULL);
+}
+
+/** @brief Are Two Nodes Equal
+ *
+ *  This function returns true if @a left and @a right are equal,
+ *  and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Are_nodes_equal(
+    const RBTree_Node *left,
+    const RBTree_Node *right
+    )
+{
+  return left == right;
+}
+
+/** @brief Is this RBTree Control Pointer Null
+ *
+ *  This function returns true if @a the_rbtree is NULL and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_null(
+    const RBTree_Control *the_rbtree
+    )
+{
+  return (the_rbtree == NULL);
+}
+
+/** @brief Is the RBTree Node Pointer NULL
+ *
+ *  This function returns true if @a the_node is NULL and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_null_node(
+    const RBTree_Node *the_node
+    )
+{
+  return (the_node == NULL);
+}
+
+
+/** @brief Return pointer to RBTree's root node
+ *
+ *  This function returns a pointer to the root node of @a the_rbtree.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Root(
+    RBTree_Control *the_rbtree
+    )
+{
+  return the_rbtree->root;
+}
+
+/** @brief Return pointer to RBTree's First node
+ *
+ *  This function returns a pointer to the first node on @a the_rbtree, 
+ *  where @a dir specifies whether to return the minimum (0) or maximum (1).
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_First(
+    RBTree_Control *the_rbtree,
+    RBTree_Direction dir
+    )
+{
+  return the_rbtree->first[dir];
+}
+
+/** @brief Return pointer to the parent of this node
+ *
+ *  This function returns a pointer to the parent node of @a the_node.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Parent(
+    RBTree_Node *the_node
+    )
+{
+  if (!the_node->parent->parent) return NULL;
+  return the_node->parent;
+}
+
+/** @brief Return pointer to the left of this node
+ *
+ *  This function returns a pointer to the left node of this node.
+ *
+ *  @param[in] the_node is the node to be operated upon.
+ *
+ *  @return This method returns the left node on the rbtree.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Left(
+    RBTree_Node *the_node
+    )
+{
+  return the_node->child[RBT_LEFT];
+}
+
+/** @brief Return pointer to the right of this node
+ *
+ *  This function returns a pointer to the right node of this node.
+ *
+ *  @param[in] the_node is the node to be operated upon.
+ *
+ *  @return This method returns the right node on the rbtree.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Right(
+    RBTree_Node *the_node
+    )
+{
+  return the_node->child[RBT_RIGHT];
+}
+
+/** @brief Is the RBTree Empty
+ *
+ *  This function returns true if there are no nodes on @a the_rbtree and
+ *  false otherwise.
+ *
+ *  @param[in] the_rbtree is the rbtree to be operated upon.
+ *
+ *  @return This function returns true if there are no nodes on 
+ *  @a the_rbtree and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_empty(
+    RBTree_Control *the_rbtree
+    )
+{
+  return (the_rbtree->root == NULL);
+}
+
+/** @brief Is this the First Node on the RBTree
+ *
+ *  This function returns true if @a the_node is the first node on 
+ *  @a the_rbtree and false otherwise. @a dir specifies whether first means 
+ *  minimum (0) or maximum (1).
+ *
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_first(
+    RBTree_Control *the_rbtree,
+    const RBTree_Node *the_node,
+    RBTree_Direction dir
+    )
+{
+  return (the_node == _RBTree_First(the_rbtree, dir));
+}
+
+/** @brief Is this node red?
+ *
+ *  This function returns true if @a the_node is red and false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_red(
+    const RBTree_Node *the_node
+    )
+{
+  return (the_node && the_node->color == RBT_RED);
+}
+
+
+/** @brief Does this RBTree have only One Node
+ *
+ *  This function returns true if there is only one node on @a the_rbtree and
+ *  false otherwise.
+ *
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Has_only_one_node(
+    const RBTree_Control *the_rbtree
+    )
+{
+  if(!the_rbtree) return NULL; /* TODO: expected behavior? */
+  return (the_rbtree->root->child[RBT_LEFT] == NULL && the_rbtree->root->child[RBT_RIGHT] == NULL);
+}
+
+/** @brief Is this Node the RBTree root
+ *
+ *  This function returns true if @a the_node is the root of @a the_rbtree and
+ *  false otherwise.
+ */
+RTEMS_INLINE_ROUTINE bool _RBTree_Is_root(
+    RBTree_Control *the_rbtree,
+    const RBTree_Node    *the_node
+    )
+{
+  return (the_node == _RBTree_Root(the_rbtree));
+}
+
+/** @brief Initialize this RBTree as Empty
+ *
+ *  This routine initializes @a the_rbtree to contain zero nodes.
+ */
+RTEMS_INLINE_ROUTINE void _RBTree_Initialize_empty(
+    RBTree_Control *the_rbtree
+    )
+{
+  the_rbtree->permanent_null = NULL;
+  the_rbtree->root           = NULL;
+  the_rbtree->first[0]       = NULL;
+  the_rbtree->first[1]       = NULL;
+}
+
+/** @brief Return a pointer to node's grandparent
+ *
+ *  This function returns a pointer to the grandparent of @a the_node if it 
+ *  exists, and NULL if not. 
+ *  
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Grandparent(
+    RBTree_Node *the_node
+    )
+{
+  if(!the_node) return NULL;
+  if(!(the_node->parent)) return NULL;
+  if(!(the_node->parent->parent)) return NULL;
+  if(!(the_node->parent->parent->parent)) return NULL;
+  return(the_node->parent->parent);
+}
+
+/** @brief Return a pointer to node's sibling
+ *
+ *  This function returns a pointer to the sibling of @a the_node if it 
+ *  exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Sibling(
+    RBTree_Node *the_node
+    )
+{
+  if(!the_node) return NULL;
+  if(!(the_node->parent)) return NULL;
+  if(!(the_node->parent->parent)) return NULL;
+
+  if(the_node == the_node->parent->child[RBT_LEFT])
+    return the_node->parent->child[RBT_RIGHT];
+  else
+    return the_node->parent->child[RBT_LEFT];
+}
+
+/** @brief Return a pointer to node's parent's sibling
+ *
+ *  This function returns a pointer to the sibling of the parent of 
+ *  @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Parent_sibling(
+    RBTree_Node *the_node
+    )
+{
+  if(!the_node) return NULL;
+  if(_RBTree_Grandparent(the_node) == NULL) return NULL;
+
+  return _RBTree_Sibling(the_node->parent);
+}
+
+/** @brief Find the RBTree_Control header given a node in the tree
+ *
+ *  This function returns a pointer to the header of the Red Black 
+ *  Tree containing @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Control *_RBTree_Find_header_unprotected(
+    RBTree_Node *the_node
+    )
+{
+  if(!the_node) return NULL;
+  if(!(the_node->parent)) return NULL;
+  while(the_node->parent) the_node = the_node->parent;
+  return (RBTree_Control*)the_node;
+}
+
+/** @brief Find the node with given value in the tree
+ *
+ *  This function returns a pointer to the node in @a the_rbtree 
+ *  having value equal to @a the_value if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Find_unprotected(
+    RBTree_Control *the_rbtree,
+    unsigned int the_value
+    )
+{
+  RBTree_Node* iter_node = the_rbtree->root;
+  while (iter_node) {
+    if (the_value == iter_node->value) return(iter_node);
+
+    RBTree_Direction dir = the_value > iter_node->value;
+    iter_node = iter_node->child[dir];
+  } /* while(iter_node) */
+
+  return 0;
+}
+
+/** @brief Find the nodes in-order predecessor
+ *
+ *  This function returns a pointer to the in-order predecessor 
+ *  of @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Predecessor(
+    RBTree_Node *the_node
+    )
+{
+  if (!the_node) return NULL;
+  RBTree_Node* iter_node = the_node->child[RBT_LEFT];
+  if (!iter_node) return NULL;
+  while (iter_node->child[RBT_RIGHT]) {
+    iter_node = iter_node->child[RBT_RIGHT];
+  } 
+  return iter_node;
+}
+
+/** @brief Find the nodes in-order successor
+ *
+ *  This function returns a pointer to the in-order successor  
+ *  of @a the_node if it exists, and NULL if not. 
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Successor(
+    RBTree_Node *the_node
+    )
+{
+  if (!the_node) return NULL;
+  RBTree_Node* iter_node = the_node->child[RBT_RIGHT];
+  if (!iter_node) return NULL;
+  while (iter_node->child[RBT_LEFT]) {
+    iter_node = iter_node->child[RBT_LEFT];
+  } 
+  return iter_node;
+}
+
+/** @brief Get the First Node (unprotected)
+ *
+ *  This function removes the minimum or maximum node from the_rbtree and 
+ *  returns a pointer to that node.  It does NOT disable interrupts to ensure
+ *  the atomicity of the get operation.
+ *
+ *  @param[in] the_rbtree is the rbtree to attempt to get the min node from.
+ *  @param[in] dir specifies whether to get minimum (0) or maximum (1)
+ *
+ *  @return This method returns the min or max node on the rbtree, or NULL.
+ *
+ *  @note This routine may return NULL if the RBTree is empty.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Get_unprotected(
+    RBTree_Control *the_rbtree,
+    RBTree_Direction dir
+    )
+{
+  RBTree_Node *the_node = the_rbtree->first[dir];
+  _RBTree_Extract_unprotected(the_rbtree, the_node);
+  return the_node;
+}
+
+/** @brief Peek at the First Node (unprotected)
+ *
+ *  This function returns a pointer to the first node, minimum if @a dir is 0 
+ *  or maximum if @a dir is 1, from @a the_rbtree without extracting it.  
+ *  It does NOT disable interrupts to ensure the atomicity of the peek.
+ *
+ *  @retval NULL if @a the_rbtree is empty.
+ */
+RTEMS_INLINE_ROUTINE RBTree_Node *_RBTree_Peek_unprotected(
+    RBTree_Control *the_rbtree,
+    RBTree_Direction dir
+    )
+{
+  return(the_rbtree->first[dir]);
+}
+
+/** @brief Rotate the_node in the direction passed as second argument
+ *  
+ *  This routine rotates @a the_node to the direction @a dir, swapping
+ *  @a the_node with its child\[@a dir\].
+ */
+RTEMS_INLINE_ROUTINE void _RBTree_Rotate(
+    RBTree_Node *the_node,
+    RBTree_Direction dir
+    )
+{
+  RBTree_Node *c;
+  if (the_node == NULL) return;
+  if (the_node->child[(1-dir)] == NULL) return;
+  
+
+  c = the_node->child[(1-dir)];
+  the_node->child[(1-dir)] = c->child[dir];
+
+  if (c->child[dir])
+    c->child[dir]->parent = the_node;
+
+  c->child[dir] = the_node;
+
+  the_node->parent->child[the_node != the_node->parent->child[0]] = c;
+
+  c->parent = the_node->parent;
+  the_node->parent = c;
+}
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/readyq.inl rtems/cpukit/score/inline/rtems/score/readyq.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/readyq.inl	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/inline/rtems/score/readyq.inl	2010-07-28 17:10:58.000000000 -0400
@@ -0,0 +1,113 @@
+/** 
+ *  @file  rtems/score/readyq.inl
+ *
+ *  This inline file contains all of the inlined routines associated with
+ *  the manipulation of ready queues.
+ */
+
+/*
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_READYQ_H
+# error "Never use <rtems/score/readyq.inl> directly; include <rtems/score/readyq.h> instead."
+#endif
+
+#ifndef _RTEMS_SCORE_READYQ_INL
+#define _RTEMS_SCORE_READYQ_INL
+
+/**
+ *  @addtogroup ScoreReadyQ
+ * @{
+ */
+
+/**
+ * The preferred method to add a new ready queue implementation is to define 
+ * the jump table entries and add a case to the _Ready_queue_Initialize 
+ * routine.  See cpukit/score/src/readyq.c file.
+ */
+
+/** @brief  Ready queue Enqueue
+ *
+ *  This routine enqueues the given thread on
+ *  the_ready_queue.
+ */
+RTEMS_INLINE_ROUTINE void _Ready_queue_Enqueue(
+  Ready_queue_Control        *the_ready_queue,
+  Thread_Control             *the_thread
+)
+{
+  the_ready_queue->rq_ops.enqueue( the_ready_queue, the_thread );
+}
+
+/*
+ *  @brief  _Ready_queue_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. If the 
+ *  queueing discipling is priority, then the thread will be the first thread
+ *  at its priority level.
+ *  
+ */
+
+RTEMS_INLINE_ROUTINE void _Ready_queue_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  the_ready_queue->rq_ops.enqueue_first( the_ready_queue, the_thread );
+}
+
+/** @brief  Ready queue Extract
+ *
+ *  This routine removes the_thread from the_ready_queue
+ */
+RTEMS_INLINE_ROUTINE void _Ready_queue_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  the_ready_queue->rq_ops.extract( the_ready_queue, the_thread );
+}
+
+
+/** @brief  Ready queue First
+ *
+ *  This function returns a pointer to the "first" thread
+ *  on the_ready_queue.  The "first" thread is selected
+ *  based on the discipline of the_ready_queue.
+ */
+RTEMS_INLINE_ROUTINE Thread_Control *_Ready_queue_First(
+  Ready_queue_Control *the_ready_queue
+)
+{
+ return ( the_ready_queue->rq_ops.first( the_ready_queue ) );
+}
+
+/**
+ *  @brief Ready queue Requeue
+ *
+ *  This routine is invoked when a thread changes priority and remains
+ *  ready.  If the queue is priority ordered,
+ *  the_thread is removed from the_ready_queue and reinserted using
+ *  its new priority.  This method has no impact on the state of the_thread
+ *  or of any timeouts associated with this blocking.
+ */
+RTEMS_INLINE_ROUTINE void _Ready_queue_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  the_ready_queue->rq_ops.requeue( the_ready_queue, the_thread );
+}
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/scheduler.inl rtems/cpukit/score/inline/rtems/score/scheduler.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/scheduler.inl	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/inline/rtems/score/scheduler.inl	2010-07-28 12:21:10.000000000 -0400
@@ -0,0 +1,134 @@
+/** 
+ *  @file  rtems/score/scheduler.inl
+ *
+ *  This inline file contains all of the inlined routines associated with
+ *  the manipulation of the scheduler.
+ */
+
+/*
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _RTEMS_SCORE_SCHEDULER_H
+# error "Never use <rtems/score/scheduler.inl> directly; include <rtems/score/scheduler.h> instead."
+#endif
+
+#ifndef _RTEMS_SCORE_SCHEDULER_INL
+#define _RTEMS_SCORE_SCHEDULER_INL
+
+/**
+ *  @addtogroup ScoreScheduler
+ * @{
+ */
+
+/**
+ * The preferred method to add a new scheduler is to define the jump table 
+ * entries and add a case to the _Scheduler_Initialize routine. 
+ *
+ * Generic scheduling implementations that rely on the ready queue only can 
+ * be found in the _Scheduler_queue_XXX functions.
+ *
+ */
+
+/* Passing the Scheduler_Control* to these functions allows for multiple 
+ * scheduler's to exist simultaneously, which could be useful on an SMP 
+ * system.  Then remote Schedulers may be accessible.  How to protect such 
+ * accesses remains an open problem.
+ */
+
+/**
+ *  This kernel routine implements the scheduling decision logic. It does 
+ *  NOT dispatch.
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Schedule(
+    Scheduler_Control *the_scheduler 
+)
+{
+  the_scheduler->s_ops.schedule( the_scheduler );
+}
+
+/**
+ *  This routine is invoked when a thread wishes to voluntarily
+ *  transfer control of the processor to another thread. This routine
+ *  always operates on the scheduler that 'owns' the currently executing
+ *  thread.
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Yield( void )
+{
+  _Scheduler.s_ops.yield( &_Scheduler );
+}
+
+/**
+ *  This routine removes @a the_thread from the schedulering decision, 
+ *  that is, removes it from the ready queue.  It performs
+ *  any necessary schedulering operations including the selection of
+ *  a new heir thread.
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Block( 
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread 
+)
+{
+  the_scheduler->s_ops.block( the_scheduler, the_thread );
+}
+
+/**
+ *  This routine adds @a the_thread to the schedulering decision, 
+ *  that is, adds it to the ready queue per the schedulering policy and 
+ *  updates any appropriate schedulering variables, for example the heir thread.
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Unblock(
+    Scheduler_Control *the_scheduler,
+    Thread_Control *the_thread 
+)
+{
+  the_scheduler->s_ops.unblock( the_scheduler, the_thread );
+}
+
+/**
+ * This routine allocates the sched field of @a the_thread
+ */
+RTEMS_INLINE_ROUTINE void* _Scheduler_Sched_allocate( 
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+)
+{
+  return ( the_scheduler->s_ops.sched_allocate( the_scheduler, the_thread ) );
+}
+
+/**
+ * This routine frees the sched field of @a the_thread
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Sched_free( 
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+)
+{
+  return ( the_scheduler->s_ops.sched_free( the_scheduler, the_thread ) );
+}
+
+/**
+ * This routine updates the sched field of @a the_thread.
+ */
+RTEMS_INLINE_ROUTINE void _Scheduler_Sched_update( 
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+)
+{
+  the_scheduler->s_ops.sched_update( the_scheduler, the_thread );
+}
+
+
+
+
+/**@}*/
+
+#endif
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/thread.inl rtems/cpukit/score/inline/rtems/score/thread.inl
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/inline/rtems/score/thread.inl	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/inline/rtems/score/thread.inl	2010-08-13 11:49:28.000000000 -0400
@@ -120,17 +120,6 @@ RTEMS_INLINE_ROUTINE void _Thread_Restar
 }
 
 /**
- *  This function returns a pointer to the highest priority
- *  ready thread.
- */
-
-RTEMS_INLINE_ROUTINE void _Thread_Calculate_heir( void )
-{
-  _Thread_Heir = (Thread_Control *)
-    _Thread_Ready_chain[ _Priority_bit_map_Get_highest() ].first;
-}
-
-/**
  *  This function returns true if the floating point context of
  *  the_thread is currently loaded in the floating point unit, and
  *  false otherwise.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/Makefile.am rtems/cpukit/score/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/Makefile.am	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/score/Makefile.am	2010-08-13 11:48:04.000000000 -0400
@@ -25,15 +25,22 @@ include_rtems_score_HEADERS = include/rt
     include/rtems/score/heap.h include/rtems/score/protectedheap.h \
     include/rtems/score/interr.h include/rtems/score/isr.h \
     include/rtems/score/object.h include/rtems/score/percpu.h \
-    include/rtems/score/priority.h include/rtems/score/prioritybitmap.h \
-    include/rtems/score/stack.h include/rtems/score/states.h \
-    include/rtems/score/sysstate.h include/rtems/score/thread.h \
-    include/rtems/score/threadq.h include/rtems/score/threadsync.h \
-    include/rtems/score/timespec.h include/rtems/score/timestamp.h \
-    include/rtems/score/timestamp64.h include/rtems/score/tod.h \
-    include/rtems/score/tqdata.h include/rtems/score/userext.h \
-    include/rtems/score/watchdog.h include/rtems/score/wkspace.h \
-    include/rtems/score/cpuopts.h include/rtems/score/basedefs.h
+    include/rtems/score/periodic.h include/rtems/score/priority.h \
+    include/rtems/score/prioritybitmap.h include/rtems/score/readyqedf.h \
+    include/rtems/score/rbtree.h include/rtems/score/readyq.h \
+    include/rtems/score/readyqfifo.h include/rtems/score/readyqpriority.h \
+    include/rtems/score/scheduler.h include/rtems/score/scheduleredf.h \
+    include/rtems/score/schedulerfifo.h \
+    include/rtems/score/schedulerpriority.h \
+    include/rtems/score/schedulerqueue.h include/rtems/score/stack.h \
+    include/rtems/score/states.h include/rtems/score/sysstate.h \
+    include/rtems/score/thread.h include/rtems/score/threadq.h \
+    include/rtems/score/threadsync.h include/rtems/score/timespec.h \
+    include/rtems/score/timestamp.h include/rtems/score/timestamp64.h \
+    include/rtems/score/tod.h include/rtems/score/tqdata.h \
+    include/rtems/score/userext.h include/rtems/score/watchdog.h \
+    include/rtems/score/wkspace.h include/rtems/score/cpuopts.h \
+    include/rtems/score/basedefs.h
 
 if HAS_PTHREADS
 include_rtems_score_HEADERS += include/rtems/score/corespinlock.h \
@@ -53,12 +60,14 @@ include_rtems_score_HEADERS += inline/rt
     inline/rtems/score/coremsg.inl inline/rtems/score/coremutex.inl \
     inline/rtems/score/coresem.inl inline/rtems/score/heap.inl \
     inline/rtems/score/isr.inl inline/rtems/score/object.inl \
-    inline/rtems/score/priority.inl inline/rtems/score/prioritybitmap.inl \
-    inline/rtems/score/stack.inl inline/rtems/score/states.inl \
-    inline/rtems/score/sysstate.inl inline/rtems/score/thread.inl \
-    inline/rtems/score/threadq.inl inline/rtems/score/tod.inl \
-    inline/rtems/score/tqdata.inl inline/rtems/score/watchdog.inl \
-    inline/rtems/score/wkspace.inl
+    inline/rtems/score/periodic.inl inline/rtems/score/priority.inl \
+    inline/rtems/score/prioritybitmap.inl \
+    inline/rtems/score/stack.inl inline/rtems/score/rbtree.inl \
+    inline/rtems/score/readyq.inl  inline/rtems/score/scheduler.inl \
+    inline/rtems/score/states.inl inline/rtems/score/sysstate.inl \
+    inline/rtems/score/thread.inl inline/rtems/score/threadq.inl \
+    inline/rtems/score/tod.inl inline/rtems/score/tqdata.inl \
+    inline/rtems/score/watchdog.inl inline/rtems/score/wkspace.inl
 
 if HAS_PTHREADS
 include_rtems_score_HEADERS += inline/rtems/score/corespinlock.inl \
@@ -71,7 +80,7 @@ include_rtems_score_HEADERS += inline/rt
     inline/rtems/score/objectmp.inl inline/rtems/score/threadmp.inl
 endif
 
-## src
+## src/
 
 AM_CPPFLAGS += -D__RTEMS_INSIDE__
 
@@ -137,12 +146,60 @@ libscore_a_SOURCES += src/objectallocate
     src/objectgetinfo.c src/objectgetinfoid.c src/objectapimaximumclass.c \
     src/objectnamespaceremove.c
 
+## PERIODIC_C_FILES
+libscore_a_SOURCES += src/periodic.c \
+    src/periodicgetstatus.c src/periodicstatistics.c src/periodictimeout.c
+
 ## PROTECTED_HEAP_C_FILES
 libscore_a_SOURCES += src/pheapallocate.c \
     src/pheapextend.c src/pheapfree.c src/pheapgetsize.c \
     src/pheapgetblocksize.c src/pheapgetfreeinfo.c src/pheapgetinfo.c \
     src/pheapinit.c src/pheapresizeblock.c src/pheapwalk.c
 
+## RBTREE_C FILES
+libscore_a_SOURCES += src/rbtree.c \
+    src/rbtreeextract.c src/rbtreefind.c src/rbtreefindheader.c \
+    src/rbtreeget.c src/rbtreeinsert.c src/rbtreepeek.c
+
+## READYQEDF_C_FILES
+libscore_a_SOURCES += src/readyqedf.c \
+    src/readyqedfenqueue.c src/readyqedfenqueuefirst.c \
+    src/readyqedfextract.c src/readyqedffirst.c src/readyqedfrequeue.c
+
+## READYQFIFO_C_FILES
+libscore_a_SOURCES += src/readyqfifo.c \
+    src/readyqfifoenqueue.c src/readyqfifoenqueuefirst.c \
+    src/readyqfifoextract.c src/readyqfifofirst.c \
+    src/readyqfiforequeue.c
+
+## READYQPRIORITY_C_FILES
+libscore_a_SOURCES += src/readyqpriority.c \
+    src/readyqpriorityenqueue.c src/readyqpriorityenqueuefirst.c \
+    src/readyqpriorityextract.c src/readyqpriorityfirst.c \
+    src/readyqpriorityrequeue.c
+
+## SCHEDULER_C_FILES
+libscore_a_SOURCES += src/scheduler.c
+
+## SCHEDULERQUEUE_C_FILES
+libscore_a_SOURCES += src/schedulerqueueblock.c \
+                      src/schedulerqueueschedule.c \
+                      src/schedulerqueueunblock.c src/schedulerqueueyield.c
+
+## SCHEDULEREDF_C_FILES
+libscore_a_SOURCES += src/scheduleredf.c \
+      src/scheduleredfschedallocate.c src/scheduleredfschedfree.c \
+      src/scheduleredfschedupdate.c
+
+## SCHEDULERFIFO_C_FILES
+libscore_a_SOURCES += src/schedulerfifo.c
+
+## SCHEDULERPRIORITY_C_FILES
+libscore_a_SOURCES += src/schedulerpriority.c \
+                      src/schedulerpriorityschedallocate.c \
+                      src/schedulerpriorityschedfree.c \
+                      src/schedulerpriorityschedupdate.c
+
 ## THREAD_C_FILES
 libscore_a_SOURCES += src/thread.c src/threadchangepriority.c \
     src/threadclearstate.c src/threadclose.c src/threadcreateidle.c \
@@ -153,7 +210,7 @@ libscore_a_SOURCES += src/thread.c src/t
     src/threadsetstate.c src/threadsettransient.c \
     src/threadstackallocate.c src/threadstackfree.c src/threadstart.c \
     src/threadstartmultitasking.c src/threadsuspend.c \
-    src/threadtickletimeslice.c src/threadyieldprocessor.c \
+    src/threadtickletimeslice.c \
     src/iterateoverthreads.c src/threadblockingoperationcancel.c
 
 ## THREADQ_C_FILES
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/preinstall.am rtems/cpukit/score/preinstall.am
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/preinstall.am	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/score/preinstall.am	2010-08-13 11:51:18.000000000 -0400
@@ -103,6 +103,10 @@ $(PROJECT_INCLUDE)/rtems/score/percpu.h:
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/percpu.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/percpu.h
 
+$(PROJECT_INCLUDE)/rtems/score/periodic.h: include/rtems/score/periodic.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/periodic.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/periodic.h
+
 $(PROJECT_INCLUDE)/rtems/score/priority.h: include/rtems/score/priority.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/priority.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/priority.h
@@ -111,6 +115,46 @@ $(PROJECT_INCLUDE)/rtems/score/priorityb
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/prioritybitmap.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/prioritybitmap.h
 
+$(PROJECT_INCLUDE)/rtems/score/readyqedf.h: include/rtems/score/readyqedf.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/readyqedf.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/readyqedf.h
+
+$(PROJECT_INCLUDE)/rtems/score/rbtree.h: include/rtems/score/rbtree.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/rbtree.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/rbtree.h
+
+$(PROJECT_INCLUDE)/rtems/score/readyq.h: include/rtems/score/readyq.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/readyq.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/readyq.h
+
+$(PROJECT_INCLUDE)/rtems/score/readyqfifo.h: include/rtems/score/readyqfifo.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/readyqfifo.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/readyqfifo.h
+
+$(PROJECT_INCLUDE)/rtems/score/readyqpriority.h: include/rtems/score/readyqpriority.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/readyqpriority.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/readyqpriority.h
+
+$(PROJECT_INCLUDE)/rtems/score/scheduler.h: include/rtems/score/scheduler.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/scheduler.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/scheduler.h
+
+$(PROJECT_INCLUDE)/rtems/score/scheduleredf.h: include/rtems/score/scheduleredf.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/scheduleredf.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/scheduleredf.h
+
+$(PROJECT_INCLUDE)/rtems/score/schedulerfifo.h: include/rtems/score/schedulerfifo.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/schedulerfifo.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/schedulerfifo.h
+
+$(PROJECT_INCLUDE)/rtems/score/schedulerpriority.h: include/rtems/score/schedulerpriority.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/schedulerpriority.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/schedulerpriority.h
+
+$(PROJECT_INCLUDE)/rtems/score/schedulerqueue.h: include/rtems/score/schedulerqueue.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/schedulerqueue.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/schedulerqueue.h
+
 $(PROJECT_INCLUDE)/rtems/score/stack.h: include/rtems/score/stack.h $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/stack.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/stack.h
@@ -237,6 +281,10 @@ $(PROJECT_INCLUDE)/rtems/score/object.in
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/object.inl
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/object.inl
 
+$(PROJECT_INCLUDE)/rtems/score/periodic.inl: inline/rtems/score/periodic.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/periodic.inl
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/periodic.inl
+
 $(PROJECT_INCLUDE)/rtems/score/priority.inl: inline/rtems/score/priority.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/priority.inl
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/priority.inl
@@ -249,6 +297,18 @@ $(PROJECT_INCLUDE)/rtems/score/stack.inl
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/stack.inl
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/stack.inl
 
+$(PROJECT_INCLUDE)/rtems/score/rbtree.inl: inline/rtems/score/rbtree.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/rbtree.inl
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/rbtree.inl
+
+$(PROJECT_INCLUDE)/rtems/score/readyq.inl: inline/rtems/score/readyq.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/readyq.inl
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/readyq.inl
+
+$(PROJECT_INCLUDE)/rtems/score/scheduler.inl: inline/rtems/score/scheduler.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/scheduler.inl
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/scheduler.inl
+
 $(PROJECT_INCLUDE)/rtems/score/states.inl: inline/rtems/score/states.inl $(PROJECT_INCLUDE)/rtems/score/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/score/states.inl
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/score/states.inl
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodic.c rtems/cpukit/score/src/periodic.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodic.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/periodic.c	2010-07-22 16:31:35.000000000 -0400
@@ -0,0 +1,70 @@
+/*
+ *  Periodic Manager
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+
+#include <rtems/rtems/status.h>
+#include <rtems/rtems/support.h>
+
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/periodic.h>
+#include <rtems/score/thread.h>
+
+/* TODO: 
+ * This is currently wrapped by _Rate_monotonic_Manager_initialization. 
+ * It should be a stand-alone manager in the supercore, that follows the 
+ * OBJECTS_INTERNAL_API.  This is a relic of being copied directly from 
+ * the Rate Monotonic Manager code base.
+ */
+
+/*PAGE
+ *
+ *  _Periodic_Manager_initialization
+ *
+ *  This routine initializes all Periodic Manager related
+ *  data structures.
+ *
+ *  Input parameters:   NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  NOTE: The Periodic Manager is built on top of the Watchdog
+ *        Handler.
+ */
+
+void _Periodic_Manager_initialization(void)
+{
+  _Objects_Initialize_information(
+    &_Periodic_Information,    /* object information table */
+    OBJECTS_CLASSIC_API,             /* object API */
+    OBJECTS_RTEMS_PERIODS,           /* object class */
+    Configuration_RTEMS_API.maximum_periods,
+                                     /* maximum objects of this class */
+    sizeof( Periodic_Control ),/* size of this object's control block */
+    false,                           /* true if the name is a string */
+    RTEMS_MAXIMUM_NAME_LENGTH        /* maximum length of an object name */
+#if defined(RTEMS_MULTIPROCESSING)
+    ,
+    false,                           /* true if this is a global object class */
+    NULL                             /* Proxy extraction support callout */
+#endif
+  );
+}
+
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodicgetstatus.c rtems/cpukit/score/src/periodicgetstatus.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodicgetstatus.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/periodicgetstatus.c	2010-07-22 15:43:12.000000000 -0400
@@ -0,0 +1,110 @@
+/*
+ *  Periodic Manager -- Get Status
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  _Periodic_Get_status
+ *
+ *  This directive allows a thread to obtain status information on a
+ *  period.
+ *
+ *  Input parameters:
+ *    the_period              - periodic control
+ *    wall_since_last_period  - wall time between period invocations
+ *    cpu_since_last_period   - cpu time between period invocations
+ *
+ *  Output parameters:
+ *    true        - if successful
+ *    false       - if unsuccessful
+ *
+ */
+bool _Periodic_Get_status(
+  Periodic_Control        *the_period,
+  Periodic_Period_time_t  *wall_since_last_period,
+  Thread_CPU_usage_t            *cpu_since_last_period
+)
+{
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    Timestamp_Control        uptime;
+  #endif
+    Thread_Control          *owning_thread = the_period->owner;
+    Thread_CPU_usage_t       used;
+
+  /*
+   *  Determine elapsed wall time since period initiated.
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    _TOD_Get_uptime( &uptime );
+    _Timestamp_Subtract(
+      &the_period->time_period_initiated, &uptime, wall_since_last_period
+    );
+  #else
+    *wall_since_last_period =
+      _Watchdog_Ticks_since_boot - the_period->time_period_initiated;
+  #endif
+
+  /*
+   *  Determine cpu usage since period initiated.
+   */
+  used = owning_thread->cpu_time_used;
+
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    if (owning_thread == _Thread_Executing) {
+
+      Thread_CPU_usage_t ran;
+
+      /* How much time time since last context switch */
+      _Timestamp_Subtract(
+        &_Thread_Time_of_last_context_switch, &uptime, &ran
+      );
+
+      /* cpu usage += ran */
+      _Timestamp_Add_to( &used, &ran );
+
+      /*
+       *  The cpu usage info was reset while executing.  Can't
+       *  determine a status.
+       */
+      if (_Timestamp_Less_than(&used, &the_period->cpu_usage_period_initiated))
+        return false;
+
+       /* used = current cpu usage - cpu usage at start of period */
+      _Timestamp_Subtract(
+         &the_period->cpu_usage_period_initiated,
+         &used,
+         cpu_since_last_period
+      );
+    }
+  #else
+      /*
+       *  The cpu usage info was reset while executing.  Can't
+       *  determine a status.
+       */
+      if (used < the_period->cpu_usage_period_initiated)
+        return false;
+
+      *cpu_since_last_period = used - the_period->cpu_usage_period_initiated;
+  #endif
+  return true;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodicstatistics.c rtems/cpukit/score/src/periodicstatistics.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodicstatistics.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/periodicstatistics.c	2010-07-29 12:31:55.000000000 -0400
@@ -0,0 +1,183 @@
+/*
+ *  Periodic Manager -- Period Statistics
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/periodic.h>
+#include <rtems/score/scheduleredf.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  _Periodic_Initate_statistics
+ *
+ *  This directive resets the statistics for a given period. 
+ *
+ *  Input parameters:
+ *    the_period              - periodic control
+ *
+ *  Output parameters:
+ *
+ */
+void _Periodic_Initiate_statistics(
+  Periodic_Control *the_period
+)
+{
+  Thread_Control *owning_thread = the_period->owner;
+
+  /*
+   *  If using nanosecond statistics, we need to obtain the uptime.
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    Timestamp_Control  uptime;
+
+    _TOD_Get_uptime( &uptime );
+  #endif
+
+  /*
+   *  Set the starting point and the CPU time used for the statistics.
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    the_period->time_period_initiated = uptime;
+  #else
+    the_period->time_period_initiated = _Watchdog_Ticks_since_boot;
+  #endif
+
+  the_period->cpu_usage_period_initiated = owning_thread->cpu_time_used;
+
+  /*
+   *  If using nanosecond statistics and the period's thread is currently
+   *  executing, then we need to take into account how much time the
+   *  executing thread has run since the last context switch.  When this
+   *  routine is invoked from rtems_periodic_period, the owner will
+   *  be the executing thread.  When this routine is invoked from
+   *  _Periodic_Timeout, it will not.
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    if (owning_thread == _Thread_Executing) {
+
+      Thread_CPU_usage_t ran;
+
+      /*
+       *  Adjust the CPU time used to account for the time since last
+       *  context switch.
+       */
+      _Timespec_Subtract(
+	&_Thread_Time_of_last_context_switch, &uptime, &ran
+      );
+
+      _Timespec_Add_to( &the_period->cpu_usage_period_initiated, &ran );
+    }
+  #endif
+    
+    /* TODO: scheduler-specific job release */
+    _Scheduler_edf_Release_job( the_period );
+}
+
+/*PAGE
+ *
+ *  _Periodic_Update_statistics
+ *
+ *  This directive updates the statistics for a given period. 
+ *
+ *  Input parameters:
+ *    the_period              - periodic control
+ *
+ *  Output parameters:
+ *
+ */
+void _Periodic_Update_statistics(
+  Periodic_Control    *the_period
+)
+{
+  Thread_CPU_usage_t              executed;
+  Periodic_Period_time_t    since_last_period;
+  Periodic_Statistics      *stats;
+  bool                            valid_status;
+
+  /*
+   *  Assume we are only called in states where it is appropriate
+   *  to update the statistics.  This should only be PERIODIC_ACTIVE
+   *  and PERIODIC_EXPIRED.
+   */
+
+  /*
+   *  Update the counts.
+   */
+  stats = &the_period->Statistics;
+  stats->count++;
+
+  if ( the_period->state == PERIODIC_EXPIRED )
+    stats->missed_count++;
+
+  /*
+   *  Grab status for time statistics.
+   */
+  valid_status =
+    _Periodic_Get_status( the_period, &since_last_period, &executed );
+  if (!valid_status)
+    return;
+
+  /*
+   *  Update CPU time
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    _Timestamp_Add_to( &stats->total_cpu_time, &executed );
+
+    if ( _Timestamp_Less_than( &executed, &stats->min_cpu_time ) )
+      stats->min_cpu_time = executed;
+
+    if ( _Timestamp_Greater_than( &executed, &stats->max_cpu_time ) )
+      stats->max_cpu_time = executed;
+  #else
+    stats->total_cpu_time  += executed;
+
+    if ( executed < stats->min_cpu_time )
+      stats->min_cpu_time = executed;
+
+    if ( executed > stats->max_cpu_time )
+      stats->max_cpu_time = executed;
+  #endif
+
+  /*
+   *  Update Wall time
+   */
+  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    _Timestamp_Add_to( &stats->total_wall_time, &since_last_period );
+
+    if ( _Timestamp_Less_than( &since_last_period, &stats->min_wall_time ) )
+      stats->min_wall_time = since_last_period;
+
+    if ( _Timestamp_Greater_than( &since_last_period, &stats->max_wall_time ) )
+      stats->max_wall_time = since_last_period;
+  #else
+
+    /* Sanity check wall time */
+    if ( since_last_period < executed )
+      since_last_period = executed;
+
+    stats->total_wall_time += since_last_period;
+
+    if ( since_last_period < stats->min_wall_time )
+      stats->min_wall_time = since_last_period;
+
+    if ( since_last_period > stats->max_wall_time )
+      stats->max_wall_time = since_last_period;
+  #endif
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodictimeout.c rtems/cpukit/score/src/periodictimeout.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/periodictimeout.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/periodictimeout.c	2010-07-22 15:39:06.000000000 -0400
@@ -0,0 +1,81 @@
+/*
+ *  Periodic Manager -- Period End Timeout Handler
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/periodic.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  _Periodic_Timeout
+ *
+ *  This routine processes a period ending.  If the owning thread
+ *  is waiting for the period, that thread is unblocked and the
+ *  period reinitiated.  Otherwise, the period is expired.
+ *  This routine is called by the watchdog handler.
+ *
+ *  Input parameters:
+ *    id - period id
+ *
+ *  Output parameters: NONE
+ */
+
+void _Periodic_Timeout(
+  Objects_Id  id,
+  void       *ignored
+)
+{
+  Periodic_Control *the_period;
+  Objects_Locations       location;
+  Thread_Control         *the_thread;
+
+  /*
+   *  When we get here, the Timer is already off the chain so we do not
+   *  have to worry about that -- hence no _Watchdog_Remove().
+   */
+  the_period = _Periodic_Get( id, &location );
+  switch ( location ) {
+
+    case OBJECTS_LOCAL:
+      the_thread = the_period->owner;
+      if ( _States_Is_waiting_for_period( the_thread->current_state ) &&
+            the_thread->Wait.id == the_period->Object.id ) {
+        _Thread_Unblock( the_thread );
+
+        _Periodic_Initiate_statistics( the_period );
+
+        _Watchdog_Insert_ticks( &the_period->Timer, the_period->next_length );
+      } else if ( the_period->state == PERIODIC_OWNER_IS_BLOCKING ) {
+        the_period->state = PERIODIC_EXPIRED_WHILE_BLOCKING;
+
+        _Periodic_Initiate_statistics( the_period );
+
+        _Watchdog_Insert_ticks( &the_period->Timer, the_period->next_length );
+      } else
+        the_period->state = PERIODIC_EXPIRED;
+      _Thread_Unnest_dispatch();
+      break;
+
+#if defined(RTEMS_MULTIPROCESSING)
+    case OBJECTS_REMOTE:  /* impossible */
+#endif
+    case OBJECTS_ERROR:
+      break;
+  }
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtree.c rtems/cpukit/score/src/rbtree.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtree.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtree.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/*PAGE
+ *
+ *  _RBTree_Initialize
+ *
+ *  This kernel routine initializes a Red-Black Tree.
+ *
+ *  Input parameters:
+ *    the_rbtree        - pointer to rbtree header
+ *    starting_address - starting address of first node
+ *    number_nodes     - number of nodes in rbtree
+ *    node_size        - size of node in bytes
+ *
+ *  Output parameters:  NONE
+ */
+
+void _RBTree_Initialize(
+  RBTree_Control *the_rbtree,
+  void           *starting_address,
+  size_t         number_nodes,
+  size_t         node_size
+)
+{
+  size_t      count;
+  RBTree_Node *next;
+
+  /* TODO: Error message? */
+  if (!the_rbtree) return;
+
+  /* could do sanity checks here */
+  _RBTree_Initialize_empty(the_rbtree);
+ 
+  count = number_nodes;
+  next  = starting_address;
+  while ( count-- ) {
+    _RBTree_Insert(the_rbtree, next);
+    next           = (RBTree_Node *)
+                        _Addresses_Add_offset( (void *) next, node_size );
+  }
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeextract.c rtems/cpukit/score/src/rbtreeextract.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeextract.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreeextract.c	2010-07-20 13:53:37.000000000 -0400
@@ -0,0 +1,245 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/** @brief  Validate and fix-up tree properties after deleting a node
+ *
+ *  This routine is called on a black node, @a the_node, after its deletion.
+ *  This function maintains the properties of the red-black tree.
+ *
+ *  @note It does NOT disable interrupts to ensure the atomicity
+ *        of the extract operation.
+ */
+void _RBTree_Extract_validate_unprotected(
+    RBTree_Node *the_node
+    )
+{
+  RBTree_Node *parent, *sibling;
+  RBTree_Direction dir;
+
+  parent = the_node->parent; 
+  if(!parent->parent) return;
+
+  sibling = _RBTree_Sibling(the_node);
+
+  /* continue to correct tree as long as the_node is black and not the root */
+  while (!_RBTree_Is_red(the_node) && parent->parent) {
+
+    /* if sibling is red, switch parent (black) and sibling colors, 
+     * then rotate parent left, making the sibling be the_node's grandparent.
+     * Now the_node has a black sibling and red parent. After rotation, 
+     * update sibling pointer.
+     */
+    if (_RBTree_Is_red(sibling)) {
+      parent->color = RBT_RED;
+      sibling->color = RBT_BLACK;
+      dir = the_node != parent->child[0];
+      _RBTree_Rotate(parent, dir);
+      sibling = parent->child[!dir];
+    }
+
+    /* sibling is black, see if both of its children are also black. */
+    if (sibling && 
+        !_RBTree_Is_red(sibling->child[RBT_RIGHT]) && 
+        !_RBTree_Is_red(sibling->child[RBT_LEFT])) {
+        sibling->color = RBT_RED;
+        if (_RBTree_Is_red(parent)) {
+          parent->color = RBT_BLACK;
+          break;
+        }
+        the_node = parent; /* done if parent is red */
+        parent = the_node->parent;
+        sibling = _RBTree_Sibling(the_node);
+    } else if(sibling) {
+      /* at least one of sibling's children is red. we now proceed in two 
+       * cases, either the_node is to the left or the right of the parent. 
+       * In both cases, first check if one of sibling's children is black, 
+       * and if so rotate in the proper direction and update sibling pointer.
+       * Then switch the sibling and parent colors, and rotate through parent.
+       */
+      dir = the_node != parent->child[0];
+      if (!_RBTree_Is_red(sibling->child[!dir])) {
+        sibling->color = RBT_RED;
+        sibling->child[dir]->color = RBT_BLACK;
+        _RBTree_Rotate(sibling, !dir);
+        sibling = parent->child[!dir];
+      }
+      sibling->color = parent->color;
+      parent->color = RBT_BLACK;
+      sibling->child[!dir]->color = RBT_BLACK;
+      _RBTree_Rotate(parent, dir);
+      break; /* done */
+    }
+  } /* while */
+  if(!the_node->parent->parent) the_node->color = RBT_BLACK;
+}
+
+/** @brief Extract a Node (unprotected)
+ *
+ *  This routine extracts (removes) @a the_node from @a the_rbtree.
+ *
+ *  @note It does NOT disable interrupts to ensure the atomicity
+ *        of the extract operation.
+ */
+void _RBTree_Extract_unprotected(
+    RBTree_Control *the_rbtree,
+    RBTree_Node *the_node
+    )
+{
+  RBTree_Node *leaf, *target;
+  RBTree_Color victim_color;
+  RBTree_Direction dir;
+
+  if(!the_node) return;
+
+  /* check if min needs to be updated */
+  if (the_node == the_rbtree->first[RBT_LEFT]) {
+    if (the_node->child[RBT_RIGHT])
+      the_rbtree->first[RBT_LEFT] = the_node->child[RBT_RIGHT];
+    else {
+      the_rbtree->first[RBT_LEFT] = the_node->parent;
+      if(_RBTree_Are_nodes_equal((RBTree_Node *)the_rbtree, 
+            the_rbtree->first[RBT_LEFT]))
+        the_rbtree->first[RBT_LEFT] = NULL;
+    }
+  }
+  /* check if max needs to be updated: note, min can equal max (1 element) */
+  if (the_node == the_rbtree->first[RBT_RIGHT]) {
+    if (the_node->child[RBT_LEFT])
+      the_rbtree->first[RBT_RIGHT] = the_node->child[RBT_LEFT];
+    else {
+      the_rbtree->first[RBT_RIGHT] = the_node->parent;
+      if(_RBTree_Are_nodes_equal((RBTree_Node *)the_rbtree, 
+            the_rbtree->first[RBT_RIGHT]))
+        the_rbtree->first[RBT_RIGHT] = NULL;
+    }
+  }
+
+  /* if the_node has at most one non-null child then it is safe to proceed
+   * check if both children are non-null, if so then we must find a target node
+   * either max in node->child[RBT_LEFT] or min in node->child[RBT_RIGHT], 
+   * and replace the_node with the target node. This maintains the binary 
+   * search tree property, but may violate the red-black properties.
+   */
+
+  if (the_node->child[RBT_LEFT] && the_node->child[RBT_RIGHT]) {
+    target = the_node->child[RBT_LEFT]; /* find max in node->child[RBT_LEFT] */
+    while (target->child[RBT_RIGHT]) target = target->child[RBT_RIGHT];
+
+    /* if the target node has a child, need to move it up the tree into 
+     * target's position (target is the right child of target->parent) 
+     * when target vacates it. if there is no child, then target->parent 
+     * should become NULL. This may cause the coloring to be violated.
+     * For now we store the color of the node being deleted in victim_color.
+     */
+     leaf = target->child[RBT_LEFT];
+    if(leaf) { 
+      leaf->parent = target->parent;
+    } else {
+      /* fix the tree here if the child is a null leaf. */
+      _RBTree_Extract_validate_unprotected(target);
+    }
+    victim_color = target->color;
+    dir = target != target->parent->child[0];
+    target->parent->child[dir] = leaf;
+
+    /* now replace the_node with target */
+    dir = the_node != the_node->parent->child[0];
+    the_node->parent->child[dir] = target;
+
+    /* set target's new children to the original node's children */
+    target->child[RBT_RIGHT] = the_node->child[RBT_RIGHT];
+    the_node->child[RBT_RIGHT]->parent = target;
+    target->child[RBT_LEFT] = the_node->child[RBT_LEFT];
+    the_node->child[RBT_LEFT]->parent = target;
+
+    /* finally, update the parent node and recolor. target has completely 
+     * replaced the_node, and target's child has moved up the tree if needed.
+     * the_node is no longer part of the tree, although it has valid pointers
+     * still.
+     */
+    target->parent = the_node->parent;
+    target->color = the_node->color;
+  } else { 
+    /* the_node has at most 1 non-null child. Move the child in to 
+     * the_node's location in the tree. This may cause the coloring to be 
+     * violated. We will fix it later.
+     * For now we store the color of the node being deleted in victim_color.
+     */
+    leaf = the_node->child[RBT_LEFT] ? 
+              the_node->child[RBT_LEFT] : the_node->child[RBT_RIGHT];
+    if( leaf ) {
+      leaf->parent = the_node->parent;
+    } else {
+      /* fix the tree here if the child is a null leaf. */
+      _RBTree_Extract_validate_unprotected(the_node);
+    }
+    victim_color = the_node->color;
+
+    /* remove the_node from the tree */
+    dir = the_node != the_node->parent->child[0];
+    the_node->parent->child[dir] = leaf;
+  }
+
+  /* fix coloring. leaf has moved up the tree. The color of the deleted 
+   * node is in victim_color. There are three cases:
+   *   1. Deleted a red node, its child must be black. Nothing must be done. 
+   *   2. Deleted a black node and the child is red. Paint child black.
+   *   3. Deleted a black node and its child is black. This requires some
+   *      care and rotations.
+   */
+  if (victim_color == RBT_BLACK) { /* eliminate case 1 */
+    if (_RBTree_Is_red(leaf))
+      leaf->color = RBT_BLACK; /* case 2 */
+    else if(leaf)
+      _RBTree_Extract_validate_unprotected(leaf); /* case 3 */
+  }
+
+  /* Wipe the_node */
+  _RBTree_Set_off_rbtree(the_node);
+
+  /* set root to black, if it exists */
+  if (the_rbtree->root) the_rbtree->root->color = RBT_BLACK;
+}
+
+
+/*
+ *  _RBTree_Extract
+ *
+ *  This kernel routine deletes the given node from a rbtree.
+ *
+ *  Input parameters:
+ *    node - pointer to node in rbtree to be deleted
+ *
+ *  Output parameters:  NONE
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+void _RBTree_Extract(
+  RBTree_Control *the_rbtree,
+  RBTree_Node *the_node
+)
+{
+  ISR_Level level;
+
+  _ISR_Disable( level );
+    _RBTree_Extract_unprotected( the_rbtree, the_node );
+  _ISR_Enable( level );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreefind.c rtems/cpukit/score/src/rbtreefind.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreefind.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreefind.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/*
+ *  _RBTree_Find
+ *
+ *  This kernel routine returns a pointer to the rbtree node containing the 
+ *  given value within the given tree, if it exists, or NULL otherwise. 
+ * 
+ *  Input parameters:
+ *    the_rbtree - pointer to rbtree control
+ *    the_value - value of the node to search for
+ *
+ *  Output parameters:
+ *    return_node - pointer to control header of rbtree
+ *    NULL   - if there is no control header available (the node is not part
+ *    of a tree)
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+RBTree_Node *_RBTree_Find(
+  RBTree_Control *the_rbtree,
+  unsigned int the_value
+)
+{
+  ISR_Level          level;
+  RBTree_Node *return_node;
+
+  return_node = NULL;
+  _ISR_Disable( level );
+      return_node = _RBTree_Find_unprotected( the_rbtree, the_value );
+  _ISR_Enable( level );
+  return return_node;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreefindheader.c rtems/cpukit/score/src/rbtreefindheader.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreefindheader.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreefindheader.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,50 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/*
+ *  _RBTree_Find_header
+ *
+ *  This kernel routine returns a pointer to the rbtree header of the tree
+ *  containing the given node.
+ *
+ *  Input parameters:
+ *    the_node - pointer to rbtree node
+ *
+ *  Output parameters:
+ *    return_header - pointer to control header of rbtree
+ *    NULL   - if there is no control header available (the node is not part
+ *    of a tree)
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+RBTree_Control *_RBTree_Find_header(
+  RBTree_Node *the_node
+)
+{
+  ISR_Level          level;
+  RBTree_Control *return_header;
+
+  return_header = NULL;
+  _ISR_Disable( level );
+      return_header = _RBTree_Find_header_unprotected( the_node );
+  _ISR_Enable( level );
+  return return_header;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeget.c rtems/cpukit/score/src/rbtreeget.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeget.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreeget.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/*
+ *  _RBTree_Get
+ *
+ *  This kernel routine returns a pointer to a node taken from the
+ *  given rbtree.
+ *
+ *  Input parameters:
+ *    the_rbtree - pointer to rbtree header
+ *    dir - specifies min (0) or max (1)
+ *
+ *  Output parameters:
+ *    return_node - pointer to node in rbtree allocated
+ *    NULL   - if no nodes available
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+RBTree_Node *_RBTree_Get(
+  RBTree_Control *the_rbtree,
+  RBTree_Direction dir
+)
+{
+  ISR_Level          level;
+  RBTree_Node *return_node;
+
+  return_node = NULL;
+  _ISR_Disable( level );
+      return_node = _RBTree_Get_unprotected( the_rbtree, dir );
+  _ISR_Enable( level );
+  return return_node;
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeinsert.c rtems/cpukit/score/src/rbtreeinsert.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreeinsert.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreeinsert.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,149 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/** @brief Validate and fix-up tree properties for a new insert/colored node
+ *
+ *  This routine checks and fixes the Red-Black Tree properties based on 
+ *  @a the_node being just added to the tree.
+ * 
+ *  @note It does NOT disable interrupts to ensure the atomicity of the
+ *        append operation.
+ */
+void _RBTree_Validate_insert_unprotected(
+    RBTree_Node    *the_node
+    )
+{
+  RBTree_Node *u,*g;
+
+  /* note: the insert root case is handled already */
+  /* if the parent is black, nothing needs to be done
+   * otherwise may need to loop a few times */
+  while (_RBTree_Is_red(_RBTree_Parent(the_node))) {
+    u = _RBTree_Parent_sibling(the_node);
+    g = the_node->parent->parent;
+    
+    /* if uncle is red, repaint uncle/parent black and grandparent red */
+    if(_RBTree_Is_red(u)) {
+      the_node->parent->color = RBT_BLACK;
+      u->color = RBT_BLACK;
+      g->color = RBT_RED;
+      the_node = g;
+    } else { /* if uncle is black */
+      RBTree_Direction dir = the_node != the_node->parent->child[0];
+      RBTree_Direction pdir = the_node->parent != g->child[0];
+      
+      /* ensure node is on the same branch direction as parent */
+      if (dir != pdir) {
+        _RBTree_Rotate(the_node->parent, pdir);
+        the_node = the_node->child[pdir];
+      }
+      the_node->parent->color = RBT_BLACK;
+      g->color = RBT_RED;
+      
+      /* now rotate grandparent in the other branch direction (toward uncle) */
+      _RBTree_Rotate(g, (1-pdir));
+    }
+  }
+  if(!the_node->parent->parent) the_node->color = RBT_BLACK;
+}
+
+
+
+/** @brief Insert a Node (unprotected)
+ *
+ *  This routine inserts @a the_node on the Red-Black Tree @a the_rbtree.
+ *
+ *  @retval 0 Successfully inserted.
+ *  @retval -1 NULL @a the_node.
+ *  @retval RBTree_Node* if one with equal value to @a the_node->value exists 
+ *          in @a the_rbtree.
+ *
+ *  @note It does NOT disable interrupts to ensure the atomicity
+ *        of the extract operation.
+ */
+RBTree_Node *_RBTree_Insert_unprotected(
+    RBTree_Control *the_rbtree,
+    RBTree_Node *the_node
+    )
+{
+  if(!the_node) return (RBTree_Node*)-1;
+
+  RBTree_Node *iter_node = the_rbtree->root;
+
+  if (!iter_node) { /* special case: first node inserted */
+    the_node->color = RBT_BLACK;
+    the_rbtree->root = the_node;
+    the_rbtree->first[0] = the_rbtree->first[1] = the_node;
+    the_node->parent = (RBTree_Node *) the_rbtree;
+    the_node->child[RBT_LEFT] = the_node->child[RBT_RIGHT] = NULL;
+  } else { 
+    /* typical binary search tree insert, descend tree to leaf and insert */
+    while (iter_node) {
+      if(the_node->value == iter_node->value) return(iter_node);
+      RBTree_Direction dir = the_node->value > iter_node->value;
+      if (!iter_node->child[dir]) {
+        the_node->child[RBT_LEFT] = the_node->child[RBT_RIGHT] = NULL;
+        the_node->color = RBT_RED;
+        iter_node->child[dir] = the_node;
+        the_node->parent = iter_node;
+        /* update min/max */
+        if (_RBTree_Is_first(the_rbtree, iter_node, dir)) {
+          the_rbtree->first[dir] = the_node;
+        }
+        break;
+      } else {
+        iter_node = iter_node->child[dir];
+      }
+
+    } /* while(iter_node) */
+    
+    /* verify red-black properties */
+    _RBTree_Validate_insert_unprotected(the_node);
+  }
+  return (RBTree_Node*)0;
+}
+
+
+/*
+ *  _RBTree_Insert
+ *
+ *  This kernel routine inserts a given node after a specified node
+ *  a requested rbtree.
+ *
+ *  Input parameters:
+ *    tree - pointer to RBTree Control for tree to insert to
+ *    node       - pointer to node to be inserted
+ *
+ *  Output parameters:  NONE
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+void _RBTree_Insert(
+  RBTree_Control *tree,
+  RBTree_Node *node
+)
+{
+  ISR_Level level;
+
+  _ISR_Disable( level );
+    _RBTree_Insert_unprotected( tree, node );
+  _ISR_Enable( level );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreepeek.c rtems/cpukit/score/src/rbtreepeek.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/rbtreepeek.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/rbtreepeek.c	2010-07-20 13:36:46.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/address.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/isr.h>
+
+/*
+ *  _RBTree_Get
+ *
+ *  This kernel routine returns a pointer to the min or max node on the tree, 
+ *  without removing that node.
+ *
+ *  Input parameters:
+ *    the_rbtree - pointer to rbtree header
+ *    dir - specifies whether to return minimum (0) or maximum (1)
+ *
+ *  Output parameters:
+ *    return_node - pointer to node in rbtree allocated
+ *    NULL   - if no nodes available
+ *
+ *  INTERRUPT LATENCY:
+ *    only case
+ */
+
+RBTree_Node *_RBTree_Peek(
+  RBTree_Control *the_rbtree,
+  RBTree_Direction dir
+)
+{
+  ISR_Level          level;
+  RBTree_Node *return_node;
+
+  return_node = NULL;
+  _ISR_Disable( level );
+      return_node = _RBTree_Peek_unprotected( the_rbtree, dir );
+  _ISR_Enable( level );
+  return return_node;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedf.c rtems/cpukit/score/src/readyqedf.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedf.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedf.c	2010-07-29 14:26:42.000000000 -0400
@@ -0,0 +1,62 @@
+/*
+ *  Ready Queue Handler -- EDF
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+#include <rtems/score/wkspace.h>
+#include <rtems/config.h>
+
+/*
+ *
+ *  _Ready_queue_edf_Initialize
+ *
+ *  This routine initializes @a the_ready_queue for use as a priority-based
+ *  ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue      - pointer to a readyq header
+ *
+ *  Output parameters: NONE
+ */
+
+void _Ready_queue_edf_Initialize(
+  Ready_queue_Control         *the_ready_queue
+)
+{
+  /* allocate ready queue structures */
+  the_ready_queue->Queues.EDF = (Ready_queue_edf_Control *) 
+    _Workspace_Allocate_or_fatal_error((1) * sizeof(Ready_queue_edf_Control));
+
+  /* initialize ready queue structures */
+  _Chain_Initialize_empty( &the_ready_queue->Queues.EDF->deadline_queue );
+  _Chain_Initialize_empty( &the_ready_queue->Queues.EDF->fifo_queue );
+  _RBTree_Initialize_empty( &the_ready_queue->Queues.EDF->edf_rbtree );
+
+  /* initialize ready queue operations */
+  the_ready_queue->rq_ops.enqueue           = &_Ready_queue_edf_Enqueue;
+  the_ready_queue->rq_ops.enqueue_first     = &_Ready_queue_edf_Enqueue_first;
+  the_ready_queue->rq_ops.extract           = &_Ready_queue_edf_Extract;
+  the_ready_queue->rq_ops.first             = &_Ready_queue_edf_First;
+  the_ready_queue->rq_ops.requeue           = &_Ready_queue_edf_Requeue;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfenqueue.c rtems/cpukit/score/src/readyqedfenqueue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfenqueue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedfenqueue.c	2010-07-29 18:26:32.000000000 -0400
@@ -0,0 +1,163 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+
+/* 
+ *  _Ready_queue_edf_Enqueue
+ *
+ * This function adds the thread @a the_thread to its proper location in the 
+ * Red-Black Tree, and then determines where to place it in the ready queue. 
+ * There are 6 cases:
+ *    1) There is already a thread with the same absolute deadline. 
+ *       Add the new thread after threads in the list with the same deadline.
+ *    2) The new thread has an in-order predecessor in the RBTree. 
+ *       Add the new thread after its predecessor (check for duplicates).
+ *    3) The new thread has an in-order successor in the RBTree.
+ *       Add the new thread before its successor.
+ *    4) The new thread is the only thread in the tree.
+ *    5) The new thread is to the left of its parent in the RBTree.
+ *       Add the new thread before its parent.
+ *    6) The new thread is to the right of its parent in the RBTree.
+ *       Add the new thread after its parent (check for duplicates).
+ *
+ * Assume that the value of the_thread->sched.edf->deadline.value has already
+ * been set to the thread's absolute deadline.
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *    the_thread  - pointer to thread
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_edf_Enqueue(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  RBTree_Node *tmp_node = 0;
+
+  Scheduler_edf_Per_thread *sched = the_thread->sched.edf;
+  Scheduler_edf_Per_thread *tmp_sched;
+
+  /* queue tasks without deadlines separately */
+  if (!sched->deadline.value) {
+    Chain_Control *fifo = &the_ready_queue->Queues.EDF->fifo_queue;
+    _Chain_Append_unprotected( fifo, &the_thread->Object.Node );
+    if ( the_thread != _Thread_Idle && 
+        fifo->first == &_Thread_Idle->Object.Node ) {
+      _Chain_Extract_unprotected( &_Thread_Idle->Object.Node );
+      _Chain_Append_unprotected( fifo, &_Thread_Idle->Object.Node );
+    }
+    return;
+  }
+
+  /* first add the_thread to red-black tree */
+  tmp_node = _RBTree_Insert_unprotected(
+               &the_ready_queue->Queues.EDF->edf_rbtree, 
+               &sched->deadline
+             );
+  if (tmp_node) { /* 1 */
+    tmp_sched = _RBTree_Container_of(
+        tmp_node, 
+        Scheduler_edf_Per_thread, 
+        deadline
+    );
+    _Chain_Insert_unprotected(
+        tmp_sched->last_duplicate, 
+        &the_thread->Object.Node
+    );
+    tmp_sched->last_duplicate = &the_thread->Object.Node;
+    return;
+  }
+
+  tmp_node = _RBTree_Predecessor( &sched->deadline );
+
+  if (tmp_node) { /* 2 */
+    tmp_sched = _RBTree_Container_of(
+        tmp_node, 
+        Scheduler_edf_Per_thread, 
+        deadline
+    );
+    _Chain_Insert_unprotected(
+        tmp_sched->last_duplicate,
+        &the_thread->Object.Node
+    );
+    return;
+  }
+
+  tmp_node = _RBTree_Successor( &sched->deadline );
+
+  if (tmp_node) { /* 3 */
+    tmp_sched = _RBTree_Container_of(
+        tmp_node, 
+        Scheduler_edf_Per_thread, 
+        deadline
+    );
+    _Chain_Insert_unprotected(
+        _Chain_Previous(&tmp_sched->this_thread->Object.Node), 
+        &the_thread->Object.Node
+    );
+    return;
+  } 
+
+  if (_RBTree_Is_root(
+        &the_ready_queue->Queues.EDF->edf_rbtree,
+        &sched->deadline
+    )) { /* 4 */
+    _Chain_Append_unprotected( 
+        &the_ready_queue->Queues.EDF->deadline_queue, 
+        &the_thread->Object.Node
+    );
+    return;
+  }  
+
+  tmp_node = _RBTree_Parent( &sched->deadline );
+  tmp_sched = _RBTree_Container_of(tmp_node, 
+      Scheduler_edf_Per_thread, 
+      deadline
+  );
+
+  if ( _RBTree_Are_nodes_equal(&sched->deadline, 
+        _RBTree_Left(tmp_node))) { /* 5 */
+    _Chain_Insert_unprotected(
+        _Chain_Previous(&tmp_sched->this_thread->Object.Node), 
+        &the_thread->Object.Node
+    );
+    return;
+  } 
+  
+  /* 6 */
+  _Chain_Insert_unprotected(
+      tmp_sched->last_duplicate,
+      &the_thread->Object.Node
+  );
+
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfenqueuefirst.c rtems/cpukit/score/src/readyqedfenqueuefirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfenqueuefirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedfenqueuefirst.c	2010-07-29 11:13:29.000000000 -0400
@@ -0,0 +1,59 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+
+/*
+ *
+ *  _Ready_queue_edf_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. 
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_edf_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  Scheduler_edf_Per_thread *sched = the_thread->sched.edf;
+
+  if (!sched->deadline.value) {
+    _Chain_Prepend_unprotected(
+        &the_ready_queue->Queues.EDF->fifo_queue,
+        &the_thread->Object.Node
+    );
+  }
+  return;
+
+  /* TODO: re-write enqueue logic to be lifo? */
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfextract.c rtems/cpukit/score/src/readyqedfextract.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfextract.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedfextract.c	2010-07-29 14:28:39.000000000 -0400
@@ -0,0 +1,120 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ *  _Ready_queue_edf_Extract
+ *
+ *  This routine removes a specific thread from the specified 
+ *  edf-based ready queue.
+ *
+ * If there are other threads with the same 
+ * absolute deadline as the_thread, the next one should be added to the 
+ * Red-Black Tree.
+
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_edf_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  Thread_Control  *tmp_thd            = 0;
+  RBTree_Node     *tmp_node           = 0;
+  Scheduler_edf_Per_thread *tmp_sched = 0;
+  Scheduler_edf_Per_thread *sched     = the_thread->sched.edf;
+
+  /* handle tasks without a deadline separately */
+  if (!sched->deadline.value) {
+    if (_Chain_Has_only_one_node(&the_ready_queue->Queues.EDF->fifo_queue))
+      _Chain_Initialize_empty(&the_ready_queue->Queues.EDF->fifo_queue);
+    else
+      _Chain_Extract_unprotected(&the_thread->Object.Node);
+    return;
+  }
+
+  if ( !(_RBTree_Is_node_off_rbtree( &sched->deadline )) ) {
+    _RBTree_Extract_unprotected(
+        &the_ready_queue->Queues.EDF->edf_rbtree,
+        &sched->deadline
+    );
+
+    if (sched->last_duplicate != &the_thread->Object.Node) {
+      tmp_thd = (Thread_Control *) _Chain_Next(&the_thread->Object.Node);
+      tmp_sched = tmp_thd->sched.edf;
+      /* TODO: remove after debugging */
+      if (tmp_sched->deadline.value != sched->deadline.value)
+        printk("invalid duplicate\n");
+
+      tmp_sched->last_duplicate = sched->last_duplicate;
+      _RBTree_Insert_unprotected(
+          &the_ready_queue->Queues.EDF->edf_rbtree,
+          &tmp_sched->deadline
+      );
+      sched->last_duplicate = &the_thread->Object.Node;
+    }
+  } else {
+    /* the_thread is not on the RBTree. Find its duplicate and update 
+     * the last_duplicate field if necessary. */
+    tmp_node = _RBTree_Find_unprotected(
+        &the_ready_queue->Queues.EDF->edf_rbtree, 
+        sched->deadline.value
+    );
+    if (!tmp_node) {
+      /* TODO: remove after debugging */
+      printk("invalid thread\n");
+      while(1);
+    }
+    tmp_sched = _RBTree_Container_of(
+        tmp_node, 
+        Scheduler_edf_Per_thread, 
+        deadline
+    );
+      /* TODO: remove after debugging */
+    if (tmp_sched->deadline.value != sched->deadline.value)
+      printk("Invalid duplicate\n");
+
+    if (tmp_sched->last_duplicate == &the_thread->Object.Node)
+      tmp_sched->last_duplicate = _Chain_Previous(&the_thread->Object.Node);
+  }
+
+  if (_Chain_Has_only_one_node( &the_ready_queue->Queues.EDF->deadline_queue ))
+    _Chain_Initialize_empty( &the_ready_queue->Queues.EDF->deadline_queue );
+  else
+    _Chain_Extract_unprotected( &the_thread->Object.Node );
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedffirst.c rtems/cpukit/score/src/readyqedffirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedffirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedffirst.c	2010-07-29 15:44:17.000000000 -0400
@@ -0,0 +1,62 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ *  _Ready_queue_edf_First
+ *
+ *  This routines returns a pointer to the first thread on @a the_ready_queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to thread queue
+ *
+ *  Output parameters:
+ *    returns - first thread or NULL
+ */
+
+Thread_Control *_Ready_queue_edf_First(
+  Ready_queue_Control *the_ready_queue
+)
+{
+  /* when there are periodic jobs to run, schedule them first */
+  if ( !_Chain_Is_empty(&the_ready_queue->Queues.EDF->deadline_queue ) )
+    return (Thread_Control *) the_ready_queue->Queues.EDF->deadline_queue.first;
+
+  /* otherwise schedule aperiodic jobs as background tasks */
+
+  /* If idle is going to be heir, re-queue it. */
+  if ( the_ready_queue->Queues.EDF->fifo_queue.first == 
+        &_Thread_Idle->Object.Node ) {
+    _Ready_queue_edf_Extract( the_ready_queue, _Thread_Idle ); 
+    _Ready_queue_edf_Enqueue( the_ready_queue, _Thread_Idle );
+  }
+
+  /* this is the idle thread if there are no other aperiodic jobs */
+  return (Thread_Control *) the_ready_queue->Queues.EDF->fifo_queue.first;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfrequeue.c rtems/cpukit/score/src/readyqedfrequeue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqedfrequeue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqedfrequeue.c	2010-07-28 16:46:04.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/rbtree.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ *  _Ready_queue_edf_Requeue
+ *
+ *  This routine is invoked when a thread changes priority and should be
+ *  moved to a different position on the ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_edf_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifo.c rtems/cpukit/score/src/readyqfifo.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifo.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfifo.c	2010-07-28 15:48:21.000000000 -0400
@@ -0,0 +1,61 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqfifo.h>
+#include <rtems/score/wkspace.h>
+#include <rtems/config.h>
+
+/*
+ *
+ *  _Ready_queue_fifo_Initialize
+ *
+ *  This routine initializes @a the_ready_queue for use as a fifo
+ *  ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue      - pointer to a readyq header
+ *
+ *  Output parameters: NONE
+ */
+
+void _Ready_queue_fifo_Initialize(
+  Ready_queue_Control         *the_ready_queue
+)
+{
+  /* allocate ready queue structures */
+  the_ready_queue->Queues.Fifo = (Chain_Control *) 
+    _Workspace_Allocate_or_fatal_error( (1) * sizeof(Chain_Control) 
+  );
+
+  /* initialize ready queue structures */
+  _Chain_Initialize_empty( the_ready_queue->Queues.Fifo );
+
+  /* initialize ready queue operations */
+  the_ready_queue->rq_ops.enqueue       = &_Ready_queue_fifo_Enqueue;
+  the_ready_queue->rq_ops.enqueue_first = &_Ready_queue_fifo_Enqueue_first;
+  the_ready_queue->rq_ops.extract       = &_Ready_queue_fifo_Extract;
+  the_ready_queue->rq_ops.first         = &_Ready_queue_fifo_First;
+  the_ready_queue->rq_ops.requeue       = &_Ready_queue_fifo_Requeue;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoenqueue.c rtems/cpukit/score/src/readyqfifoenqueue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoenqueue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfifoenqueue.c	2010-07-28 12:49:26.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+//#include <rtems/score/rqdata.h>
+
+/* 
+ *  _Ready_queue_fifo_Enqueue
+ *
+ *  This routine puts @a the_thread on to the priority-based ready queue.
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *    the_thread  - pointer to thread
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_fifo_Enqueue(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  _Chain_Append_unprotected(
+        the_ready_queue->Queues.Fifo,
+        &the_thread->Object.Node
+      );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoenqueuefirst.c rtems/cpukit/score/src/readyqfifoenqueuefirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoenqueuefirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfifoenqueuefirst.c	2010-07-28 12:49:35.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+//#include <rtems/score/rqdata.h>
+
+/*
+ *
+ *  _Ready_queue_fifo_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. 
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_fifo_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  _Chain_Prepend_unprotected(
+        the_ready_queue->Queues.Fifo,
+        &the_thread->Object.Node
+      );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoextract.c rtems/cpukit/score/src/readyqfifoextract.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifoextract.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfifoextract.c	2010-07-28 12:50:15.000000000 -0400
@@ -0,0 +1,49 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_fifo_Extract
+ *
+ *  This routine removes a specific thread from the specified 
+ *  fifo-based ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_fifo_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  _Chain_Extract_unprotected( &the_thread->Object.Node );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifofirst.c rtems/cpukit/score/src/readyqfifofirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfifofirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfifofirst.c	2010-07-28 12:50:32.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/percpu.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqfifo.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_fifo_First
+ *
+ *  This routines returns a pointer to the first thread on @a the_ready_queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to thread queue
+ *
+ *  Output parameters:
+ *    returns - first thread or NULL
+ */
+
+Thread_Control *_Ready_queue_fifo_First(
+  Ready_queue_Control *the_ready_queue
+)
+{
+  Thread_Control *first;
+  if ( !_Chain_Is_empty( the_ready_queue->Queues.Fifo ) ) {
+    first = (Thread_Control *) _Chain_First(the_ready_queue->Queues.Fifo);
+
+    /* if the idle thread is the first thread, requeue it to give other 
+     * threads a chance to be the first on the FIFO queue.
+     */
+    if ( first == _Thread_Idle ) {
+      _Ready_queue_fifo_Requeue(the_ready_queue, first);
+      first = (Thread_Control *) _Chain_First(the_ready_queue->Queues.Fifo);
+    }
+
+    return first;
+  }
+
+  return NULL;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfiforequeue.c rtems/cpukit/score/src/readyqfiforequeue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqfiforequeue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqfiforequeue.c	2010-07-28 12:50:52.000000000 -0400
@@ -0,0 +1,55 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_fifo_Requeue
+ *
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_fifo_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  /* extract */
+  _Chain_Extract_unprotected( &the_thread->Object.Node );
+
+  /* enqueue */
+  _Chain_Append_unprotected(
+        the_ready_queue->Queues.Fifo,
+        &the_thread->Object.Node
+      );
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriority.c rtems/cpukit/score/src/readyqpriority.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriority.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriority.c	2010-07-28 15:47:48.000000000 -0400
@@ -0,0 +1,65 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqpriority.h>
+#include <rtems/score/wkspace.h>
+#include <rtems/config.h>
+
+/*
+ *
+ *  _Ready_queue_priority_Initialize
+ *
+ *  This routine initializes @a the_ready_queue for use as a priority-based
+ *  ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue      - pointer to a readyq header
+ *
+ *  Output parameters: NONE
+ */
+
+void _Ready_queue_priority_Initialize(
+  Ready_queue_Control         *the_ready_queue
+)
+{
+  uint32_t index;
+
+  /* allocate ready queue structures */
+  the_ready_queue->Queues.Priority = (Chain_Control *) 
+    _Workspace_Allocate_or_fatal_error(
+      (PRIORITY_MAXIMUM + 1) * sizeof(Chain_Control)
+    );
+
+  /* initialize ready queue structures */
+  for( index=0; index <= PRIORITY_MAXIMUM; index++)
+    _Chain_Initialize_empty( &the_ready_queue->Queues.Priority[index] );
+
+  /* initialize ready queue operations */
+  the_ready_queue->rq_ops.enqueue       = &_Ready_queue_priority_Enqueue;
+  the_ready_queue->rq_ops.enqueue_first = &_Ready_queue_priority_Enqueue_first;
+  the_ready_queue->rq_ops.extract       = &_Ready_queue_priority_Extract;
+  the_ready_queue->rq_ops.first         = &_Ready_queue_priority_First;
+  the_ready_queue->rq_ops.requeue       = &_Ready_queue_priority_Requeue;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityenqueue.c rtems/cpukit/score/src/readyqpriorityenqueue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityenqueue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriorityenqueue.c	2010-07-28 12:50:07.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/* 
+ *  _Ready_queue_priority_Enqueue
+ *
+ *  This routine puts @a the_thread on to the priority-based ready queue.
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *    the_thread  - pointer to thread
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_priority_Enqueue(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  _Priority_bit_map_Add( &the_thread->sched.priority->Priority_map );
+  _Chain_Append_unprotected( the_thread->sched.priority->ready_chain, 
+      &the_thread->Object.Node );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityenqueuefirst.c rtems/cpukit/score/src/readyqpriorityenqueuefirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityenqueuefirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriorityenqueuefirst.c	2010-07-28 12:49:58.000000000 -0400
@@ -0,0 +1,53 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_priority_Enqueue_first
+ *
+ *  This routine puts @a the_thread to the head of the ready queue. 
+ *  For priority-based ready queues, the thread will be the first thread
+ *  at its priority level.
+ *  
+ *  Input parameters:
+ *    the_ready_queue - pointer to readyq
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Ready_queue_priority_Enqueue_first(
+  Ready_queue_Control         *the_ready_queue,
+  Thread_Control                   *the_thread
+)
+{
+  _Priority_bit_map_Add( &the_thread->sched.priority->Priority_map );
+  _Chain_Prepend_unprotected( the_thread->sched.priority->ready_chain, 
+      &the_thread->Object.Node );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityextract.c rtems/cpukit/score/src/readyqpriorityextract.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityextract.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriorityextract.c	2010-07-28 12:50:23.000000000 -0400
@@ -0,0 +1,59 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_priority_Extract
+ *
+ *  This routine removes a specific thread from the specified 
+ *  priority-based ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_priority_Extract(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  Chain_Control *ready = the_thread->sched.priority->ready_chain;
+
+  if ( _Chain_Has_only_one_node( ready ) ) {
+
+    _Chain_Initialize_empty( ready );
+    _Priority_bit_map_Remove( &the_thread->sched.priority->Priority_map );
+
+  } else
+    _Chain_Extract_unprotected( &the_thread->Object.Node );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityfirst.c rtems/cpukit/score/src/readyqpriorityfirst.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityfirst.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriorityfirst.c	2010-07-28 12:50:40.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_priority_First
+ *
+ *  This routines returns a pointer to the first thread on @a the_ready_queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to thread queue
+ *
+ *  Output parameters:
+ *    returns - first thread or NULL
+ */
+
+Thread_Control *_Ready_queue_priority_First(
+  Ready_queue_Control *the_ready_queue
+)
+{
+  uint32_t   index = _Priority_bit_map_Get_highest();
+
+  if ( !_Chain_Is_empty( &the_ready_queue->Queues.Priority[ index ] ) )
+    return (Thread_Control *) the_ready_queue->Queues.Priority[ index ].first;
+
+  return NULL;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityrequeue.c rtems/cpukit/score/src/readyqpriorityrequeue.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/readyqpriorityrequeue.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/readyqpriorityrequeue.c	2010-07-28 12:51:01.000000000 -0400
@@ -0,0 +1,55 @@
+/*
+ *  Ready Queue Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/readyq.h>
+
+/*
+ *
+ *  _Ready_queue_priority_Requeue
+ *
+ *  This routine is invoked when a thread changes priority and should be
+ *  moved to a different position on the ready queue.
+ *
+ *  Input parameters:
+ *    the_ready_queue - pointer to a readyq header
+ *    the_thread       - pointer to a thread control block
+ *
+ *  Output parameters: NONE
+ *
+ *  INTERRUPT LATENCY: NONE
+ */
+
+void _Ready_queue_priority_Requeue(
+  Ready_queue_Control *the_ready_queue,
+  Thread_Control       *the_thread
+)
+{
+  if ( !_Chain_Has_only_one_node( the_thread->sched.priority->ready_chain ) ) {
+    _Chain_Extract_unprotected( &the_thread->Object.Node );
+
+    _Chain_Append_unprotected( the_thread->sched.priority->ready_chain, 
+      &the_thread->Object.Node );
+  }
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduler.c rtems/cpukit/score/src/scheduler.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduler.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/scheduler.c	2010-07-28 12:30:34.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerfifo.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*PAGE
+ *
+ *  _Scheduler_Handler_initialization
+ *
+ *  This routine initializes the scheduler
+ *
+ *  Input parameters:
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_Handler_initialization( )
+{
+  Scheduler_Control *the_scheduler = &_Scheduler;
+
+  /* call the sched_init function registered in the Configuration Scheduler 
+   * Table. */
+  (*(_Scheduler_Table[Configuration.scheduler_policy].sched_init))(
+      the_scheduler
+  );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredf.c rtems/cpukit/score/src/scheduleredf.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredf.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/scheduleredf.c	2010-07-29 17:56:42.000000000 -0400
@@ -0,0 +1,95 @@
+/*
+ *  Scheduler Handler -- EDF scheduling
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqedf.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/scheduleredf.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/watchdog.h>
+
+/* TODO: put this somewhere more appropriate. */
+void _Scheduler_edf_Release_job(
+  Periodic_Control *the_period
+)
+{
+  ISR_Level       level;
+
+  _ISR_Disable( level );
+  
+  /* if the thread is already in a ready state, need to dequeue it from
+   * the ready queue and then re-enqueue it with the new deadline.
+   */
+  if ( _States_Is_ready( the_period->owner->current_state ) ) {
+    _Ready_queue_edf_Extract(&_Scheduler.ready_queue, the_period->owner);
+
+    /* stamp this job with its new deadline */
+    the_period->owner->sched.edf->deadline.value 
+      = the_period->owner->real_priority + /* TODO: deadline field? */
+        _Watchdog_Ticks_since_boot;
+    the_period->owner->sched.edf->last_duplicate = 
+      &the_period->owner->Object.Node;
+
+    _Ready_queue_edf_Enqueue(&_Scheduler.ready_queue, the_period->owner);
+    _Scheduler_Schedule(&_Scheduler);
+  } else {
+    the_period->owner->sched.edf->deadline.value 
+      = the_period->owner->real_priority + /* TODO: deadline field? */
+        _Watchdog_Ticks_since_boot;
+    the_period->owner->sched.edf->last_duplicate = 
+      &the_period->owner->Object.Node;
+  }
+
+  if (the_period->owner != _Thread_Heir)
+    _Thread_Dispatch_necessary = true;
+
+  _ISR_Enable( level );
+}
+
+/*
+ *
+ *  _Scheduler_edf_Initialize
+ *
+ * Initializes the scheduler for edf scheduling.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_edf_Initialize (
+    Scheduler_Control *the_scheduler
+)
+{
+  the_scheduler->s_ops.schedule           = &_Scheduler_queue_Schedule;
+  the_scheduler->s_ops.yield              = &_Scheduler_queue_Yield;
+  the_scheduler->s_ops.block              = &_Scheduler_queue_Block;
+  the_scheduler->s_ops.unblock            = &_Scheduler_queue_Unblock;
+  the_scheduler->s_ops.sched_allocate     = &_Scheduler_edf_Sched_allocate;
+  the_scheduler->s_ops.sched_free         = &_Scheduler_edf_Sched_free;
+  the_scheduler->s_ops.sched_update       = &_Scheduler_edf_Sched_update;
+
+  _Ready_queue_edf_Initialize( &the_scheduler->ready_queue );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedallocate.c rtems/cpukit/score/src/scheduleredfschedallocate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedallocate.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/scheduleredfschedallocate.c	2010-07-29 18:33:43.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/scheduleredf.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/wkspace.h>
+
+/*
+ *
+ *  _Scheduler_edf_Sched_allocate
+ *
+ * Allocates the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void* _Scheduler_edf_Sched_allocate (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  void *sched;
+
+  sched = _Workspace_Allocate( sizeof(Scheduler_edf_Per_thread) );
+
+  the_thread->sched.edf = (Scheduler_edf_Per_thread*) sched;
+
+  if ( sched ) {
+    the_thread->sched.edf->last_duplicate = &the_thread->Object.Node;
+    the_thread->sched.edf->this_thread = the_thread;
+    the_thread->sched.edf->deadline.value = 0;
+    the_thread->sched.edf->absolute_deadline = 0;
+  }
+
+  return sched;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedfree.c rtems/cpukit/score/src/scheduleredfschedfree.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedfree.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/scheduleredfschedfree.c	2010-07-28 15:53:15.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/wkspace.h>
+
+/*
+ *
+ *  _Scheduler_edf_Sched_free
+ *
+ * Frees the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_edf_Sched_free (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  _Workspace_Free( the_thread->sched.edf );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedupdate.c rtems/cpukit/score/src/scheduleredfschedupdate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/scheduleredfschedupdate.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/scheduleredfschedupdate.c	2010-07-29 18:24:51.000000000 -0400
@@ -0,0 +1,54 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ *  _Scheduler_edf_Sched_update
+ *
+ * Updates the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_edf_Sched_update (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  Scheduler_edf_Per_thread *sched = the_thread->sched.edf;
+
+  sched->absolute_deadline = the_thread->real_priority;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerfifo.c rtems/cpukit/score/src/schedulerfifo.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerfifo.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerfifo.c	2010-07-28 12:47:24.000000000 -0400
@@ -0,0 +1,87 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqfifo.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerfifo.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/**
+ * This routine does nothing, and is used as a stub for Sched_allocate
+ *
+ * Note: returns a non-zero value, or else thread initialize thinks the 
+ * allocation failed.
+ *
+ * The overhead of a function call will still be imposed. :(
+ */
+static void * _Scheduler_fifo_Sched_allocate( 
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+  )
+{
+  return (void*)-1; /* maybe pick an appropriate poison value */
+}
+
+
+/**
+ * This routine does nothing, and is used as a stub for Sched_update
+ *
+ * The overhead of a function call will still be imposed. :(
+ */
+static void _Scheduler_fifo_Sched_update( 
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+  )
+{
+
+}
+
+/*
+ *
+ *  _Scheduler_fifo_Initialize
+ *
+ * Initializes the scheduler for fifo scheduling.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_fifo_Initialize (
+    Scheduler_Control *the_scheduler
+)
+{
+  the_scheduler->s_ops.schedule           = &_Scheduler_queue_Schedule;
+  the_scheduler->s_ops.yield              = &_Scheduler_queue_Yield;
+  the_scheduler->s_ops.block              = &_Scheduler_queue_Block;
+  the_scheduler->s_ops.unblock            = &_Scheduler_queue_Unblock;
+  the_scheduler->s_ops.sched_allocate     = &_Scheduler_fifo_Sched_allocate;
+  the_scheduler->s_ops.sched_free         = &_Scheduler_fifo_Sched_update;
+  the_scheduler->s_ops.sched_update       = &_Scheduler_fifo_Sched_update;
+ 
+  _Ready_queue_fifo_Initialize(&the_scheduler->ready_queue);
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriority.c rtems/cpukit/score/src/schedulerpriority.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriority.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerpriority.c	2010-07-29 11:38:07.000000000 -0400
@@ -0,0 +1,64 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/readyqpriority.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/* Instantiate any global variables needed by the priority scheduler */
+volatile Priority_bit_map_Control _Priority_Major_bit_map;
+
+Priority_bit_map_Control _Priority_Bit_map[16] CPU_STRUCTURE_ALIGNMENT;
+
+
+/*
+ *
+ *  _Scheduler_priority_Initialize
+ *
+ * Initializes the scheduler for priority scheduling.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_priority_Initialize (
+    Scheduler_Control *the_scheduler
+)
+{
+  the_scheduler->s_ops.schedule           = &_Scheduler_queue_Schedule;
+  the_scheduler->s_ops.yield              = &_Scheduler_queue_Yield;
+  the_scheduler->s_ops.block              = &_Scheduler_queue_Block;
+  the_scheduler->s_ops.unblock            = &_Scheduler_queue_Unblock;
+  the_scheduler->s_ops.sched_allocate    = &_Scheduler_priority_Sched_allocate;
+  the_scheduler->s_ops.sched_free        = &_Scheduler_priority_Sched_free;
+  the_scheduler->s_ops.sched_update      = &_Scheduler_priority_Sched_update;
+
+  _Ready_queue_priority_Initialize(&the_scheduler->ready_queue);
+  _Priority_bit_map_Handler_initialization();
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedallocate.c rtems/cpukit/score/src/schedulerpriorityschedallocate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedallocate.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerpriorityschedallocate.c	2010-07-28 12:18:19.000000000 -0400
@@ -0,0 +1,57 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/wkspace.h>
+
+/*
+ *
+ *  _Scheduler_priority_Sched_allocate
+ *
+ * Allocates the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void* _Scheduler_priority_Sched_allocate (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  void *sched;
+
+  sched = _Workspace_Allocate( sizeof(Scheduler_priority_Per_thread) );
+
+  the_thread->sched.priority = (Scheduler_priority_Per_thread*) sched;
+
+  return sched;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedfree.c rtems/cpukit/score/src/schedulerpriorityschedfree.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedfree.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerpriorityschedfree.c	2010-07-28 12:18:29.000000000 -0400
@@ -0,0 +1,51 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/wkspace.h>
+
+/*
+ *
+ *  _Scheduler_priority_Sched_free
+ *
+ * Frees the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_priority_Sched_free (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  _Workspace_Free( the_thread->sched.priority );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedupdate.c rtems/cpukit/score/src/schedulerpriorityschedupdate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerpriorityschedupdate.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerpriorityschedupdate.c	2010-07-28 12:18:55.000000000 -0400
@@ -0,0 +1,60 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2008.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/config.h>
+#include <rtems/score/chain.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/prioritybitmap.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/schedulerpriority.h>
+#include <rtems/score/schedulerqueue.h>
+#include <rtems/score/states.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ *  _Scheduler_priority_Sched_update
+ *
+ * Updates the sched field of @a the_thread.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread    - pointer to thread control block
+ *
+ *  Output parameters: NONE
+ */
+
+void _Scheduler_priority_Sched_update (
+    Scheduler_Control *the_scheduler,
+    Thread_Control    *the_thread
+)
+{
+  Ready_queue_Control *rq = &the_scheduler->ready_queue;
+  the_thread->sched.priority->ready_chain = &rq->Queues.Priority[ 
+      the_thread->current_priority 
+    ];
+
+  _Priority_bit_map_Initialize_information( 
+      &the_thread->sched.priority->Priority_map, 
+      the_thread->current_priority 
+  );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueblock.c rtems/cpukit/score/src/schedulerqueueblock.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueblock.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerqueueblock.c	2010-07-28 12:21:10.000000000 -0400
@@ -0,0 +1,62 @@
+/*
+ *  Scheduler Handler
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/context.h>
+#include <rtems/score/interr.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ * _Scheduler_queue_Block
+ *
+ * This kernel routine removes the_thread from scheduling decisions based 
+ * on simple queue extraction.
+ *
+ * Input parameters:
+ *   the_thread   - pointer to thread control block
+ *
+ * Output parameters:  NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Scheduler_queue_Block(
+  Scheduler_Control *the_scheduler,
+  Thread_Control   *the_thread
+)
+{
+
+  _Ready_queue_Extract(&the_scheduler->ready_queue, the_thread);
+
+  /* TODO: flash critical section */
+  /* XXX */
+
+  /* TODO: Is this robust? */
+  if ( _Thread_Is_heir( the_thread ) )
+     _Scheduler_Schedule(the_scheduler);
+
+  if ( _Thread_Is_executing( the_thread ) )
+    _Thread_Dispatch_necessary = true;
+
+  return;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueschedule.c rtems/cpukit/score/src/schedulerqueueschedule.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueschedule.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerqueueschedule.c	2010-07-28 12:21:10.000000000 -0400
@@ -0,0 +1,52 @@
+/*
+ *  Scheduler Handler
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/context.h>
+#include <rtems/score/interr.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/percpu.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/thread.h>
+
+/*
+ *
+ * _Scheduler_queue_Schedule
+ *
+ * This kernel routine implements scheduling decision logic for queue-based
+ * scheduling.  Any scheduler that selects the next ready task based on the
+ * head of the ready queue can use this function for its schedule routine.
+ *
+ * Input parameters:
+ *   the_scheduler - pointer to scheduler control
+ *   the_thread   - pointer to thread control block
+ *
+ * Output parameters:  NONE
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Scheduler_queue_Schedule(
+  Scheduler_Control *the_scheduler,
+  Thread_Control    *the_thread
+)
+{
+  _Thread_Heir = _Ready_queue_First(&the_scheduler->ready_queue);
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueunblock.c rtems/cpukit/score/src/schedulerqueueunblock.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueunblock.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerqueueunblock.c	2010-07-28 12:21:10.000000000 -0400
@@ -0,0 +1,88 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-2006.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/apiext.h>
+#include <rtems/score/context.h>
+#include <rtems/score/interr.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/states.h>
+#include <rtems/score/sysstate.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/threadq.h>
+#include <rtems/score/userext.h>
+#include <rtems/score/wkspace.h>
+
+/*
+ *
+ *  _Scheduler_queue_Unblock
+ *
+ *  This kernel routine readies the requested thread according to the queuing 
+ *  discipline. A new heir thread may be selected.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *    the_thread - pointer to thread control block
+ *
+ *  Output parameters:  NONE
+ *
+ *  NOTE:  This routine uses the "blocking" heir selection mechanism.
+ *         This ensures the correct heir after a thread restart.
+ *
+ *  INTERRUPT LATENCY:
+ */
+
+void _Scheduler_queue_Unblock(
+  Scheduler_Control *the_scheduler,
+  Thread_Control *the_thread
+)
+{
+  Thread_Control *heir;
+
+  _Ready_queue_Enqueue(&the_scheduler->ready_queue, the_thread);
+
+  /* TODO: flash critical section */
+  /* XXX */
+
+  _Scheduler_Schedule(the_scheduler);
+
+  heir = _Thread_Heir;
+
+  /*
+   * See if the heir is executing. if not, then the newly queue'd thread may
+   * cause a new dispatch.
+   *
+   *  Normal case:
+   *    If the current thread is preemptible, then we need to do
+   *    a context switch.
+   *  Pseudo-ISR case:
+   *    Even if the thread isn't preemptible, if the new heir is
+   *    a pseudo-ISR system task, we need to do a context switch.
+   */
+  if ( !_Thread_Is_executing( heir ) ) {
+    if ( _Thread_Executing->is_preemptible || 
+         the_thread->current_priority == 0 )
+      _Thread_Dispatch_necessary = true;
+  }
+
+  return;
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueyield.c rtems/cpukit/score/src/schedulerqueueyield.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/schedulerqueueyield.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/cpukit/score/src/schedulerqueueyield.c	2010-07-28 12:32:36.000000000 -0400
@@ -0,0 +1,74 @@
+/*
+ *  Scheduler Handler
+ *
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtems/system.h>
+#include <rtems/score/apiext.h>
+#include <rtems/score/context.h>
+#include <rtems/score/interr.h>
+#include <rtems/score/isr.h>
+#include <rtems/score/object.h>
+#include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
+#include <rtems/score/states.h>
+#include <rtems/score/sysstate.h>
+#include <rtems/score/thread.h>
+#include <rtems/score/threadq.h>
+#include <rtems/score/userext.h>
+#include <rtems/score/wkspace.h>
+
+/*PAGE
+ *
+ *  _Scheduler_queue_Yield
+ *
+ *  This kernel routine will remove the running THREAD from the ready queue
+ *  and place it immediatly at the rear of this chain.  Reset timeslice
+ *  and yield the processor functions both use this routine, therefore if
+ *  reset is true and this is the only thread on the queue then the
+ *  timeslice counter is reset.  The heir THREAD will be updated if the
+ *  running is also the currently the heir.
+ *
+ *  Input parameters:
+ *    the_scheduler - pointer to scheduler control
+ *
+ *  Output parameters:  NONE
+ *
+ *  INTERRUPT LATENCY:
+ *    ready chain
+ *    select heir
+ */
+
+void _Scheduler_queue_Yield( Scheduler_Control *the_scheduler )
+{
+  ISR_Level       level;
+  Thread_Control *executing;
+
+  executing = _Thread_Executing;
+  _ISR_Disable( level );
+      
+      _Ready_queue_Requeue(&the_scheduler->ready_queue, executing);
+
+      _ISR_Flash( level );
+
+      _Scheduler_Schedule(the_scheduler);
+    
+    if ( !_Thread_Is_heir( executing ) )
+      _Thread_Dispatch_necessary = true;
+
+  _ISR_Enable( level );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/thread.c rtems/cpukit/score/src/thread.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/thread.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/thread.c	2010-08-13 11:44:31.000000000 -0400
@@ -24,6 +24,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -45,7 +47,6 @@
 
 void _Thread_Handler_initialization(void)
 {
-  uint32_t     index;
   uint32_t     ticks_per_timeslice;
   uint32_t     maximum_extensions;
   #if defined(RTEMS_MULTIPROCESSING)
@@ -80,13 +81,6 @@ void _Thread_Handler_initialization(void
 
   _Thread_Ticks_per_timeslice  = ticks_per_timeslice;
 
-  _Thread_Ready_chain = (Chain_Control *) _Workspace_Allocate_or_fatal_error(
-    (PRIORITY_MAXIMUM + 1) * sizeof(Chain_Control)
-  );
-
-  for ( index=0; index <= PRIORITY_MAXIMUM ; index++ )
-    _Chain_Initialize_empty( &_Thread_Ready_chain[ index ] );
-
 #if defined(RTEMS_MULTIPROCESSING)
   _Thread_MP_Handler_initialization( maximum_proxies );
 #endif
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadclearstate.c rtems/cpukit/score/src/threadclearstate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadclearstate.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/threadclearstate.c	2010-08-13 11:49:55.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -66,31 +68,7 @@ void _Thread_Clear_state(
       the_thread->current_state = _States_Clear( state, current_state );
 
       if ( _States_Is_ready( current_state ) ) {
-
-        _Priority_bit_map_Add( &the_thread->Priority_map );
-
-        _Chain_Append_unprotected(the_thread->ready, &the_thread->Object.Node);
-
-        _ISR_Flash( level );
-
-        /*
-         *  If the thread that was unblocked is more important than the heir,
-         *  then we have a new heir.  This may or may not result in a
-         *  context switch.
-         *
-         *  Normal case:
-         *    If the current thread is preemptible, then we need to do
-         *    a context switch.
-         *  Pseudo-ISR case:
-         *    Even if the thread isn't preemptible, if the new heir is
-         *    a pseudo-ISR system task, we need to do a context switch.
-         */
-        if ( the_thread->current_priority < _Thread_Heir->current_priority ) {
-          _Thread_Heir = the_thread;
-          if ( _Thread_Executing->is_preemptible ||
-               the_thread->current_priority == 0 )
-            _Thread_Dispatch_necessary = true;
-        }
+        _Scheduler_Unblock( &_Scheduler, the_thread);
       }
   }
   _ISR_Enable( level );
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadclose.c rtems/cpukit/score/src/threadclose.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadclose.c	2008-05-22 16:38:03.000000000 -0400
+++ rtems/cpukit/score/src/threadclose.c	2010-07-08 15:45:24.000000000 -0400
@@ -23,6 +23,7 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -86,6 +87,11 @@ void _Thread_Close(
   }
 
   /*
+   * Free the per-thread scheduling information.
+   */
+  _Scheduler_Sched_free( &_Scheduler, the_thread );
+
+  /*
    *  The thread might have been FP.  So deal with that.
    */
 #if ( CPU_HARDWARE_FP == TRUE ) || ( CPU_SOFTWARE_FP == TRUE )
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadinitialize.c rtems/cpukit/score/src/threadinitialize.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadinitialize.c	2010-06-21 11:29:26.000000000 -0400
+++ rtems/cpukit/score/src/threadinitialize.c	2010-07-27 12:34:46.000000000 -0400
@@ -23,6 +23,7 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -60,6 +61,7 @@ bool _Thread_Initialize(
   #if ( CPU_HARDWARE_FP == TRUE ) || ( CPU_SOFTWARE_FP == TRUE )
     void              *fp_area;
   #endif
+  void                *sched = NULL;
   void                *extensions_area;
   bool                 extension_status;
   int                  i;
@@ -192,6 +194,9 @@ bool _Thread_Initialize(
   the_thread->resource_count          = 0;
   the_thread->real_priority           = priority;
   the_thread->Start.initial_priority  = priority;
+  sched =_Scheduler_Sched_allocate( &_Scheduler, the_thread );
+  if (!sched)
+    goto failed;
   _Thread_Set_priority( the_thread, priority );
 
   /*
@@ -235,6 +240,9 @@ failed:
       (void) _Workspace_Free( fp_area );
   #endif
 
+  if ( sched )
+    (void) _Workspace_Free( sched );
+
    _Thread_Stack_Free( the_thread );
   return false;
 
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadready.c rtems/cpukit/score/src/threadready.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadready.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/threadready.c	2010-08-13 11:50:05.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -55,24 +57,12 @@ void _Thread_Ready(
 )
 {
   ISR_Level              level;
-  Thread_Control *heir;
 
   _ISR_Disable( level );
 
   the_thread->current_state = STATES_READY;
 
-  _Priority_bit_map_Add( &the_thread->Priority_map );
-
-  _Chain_Append_unprotected( the_thread->ready, &the_thread->Object.Node );
-
-  _ISR_Flash( level );
-
-  _Thread_Calculate_heir();
-
-  heir = _Thread_Heir;
-
-  if ( !_Thread_Is_executing( heir ) && _Thread_Executing->is_preemptible )
-    _Thread_Dispatch_necessary = true;
+  _Scheduler_Unblock( &_Scheduler, the_thread );
 
   _ISR_Enable( level );
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadresume.c rtems/cpukit/score/src/threadresume.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadresume.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/threadresume.c	2010-08-13 11:50:14.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -68,19 +70,7 @@ void _Thread_Resume(
     the_thread->current_state = _States_Clear(STATES_SUSPENDED, current_state);
 
     if ( _States_Is_ready( current_state ) ) {
-
-      _Priority_bit_map_Add( &the_thread->Priority_map );
-
-      _Chain_Append_unprotected(the_thread->ready, &the_thread->Object.Node);
-
-      _ISR_Flash( level );
-
-      if ( the_thread->current_priority < _Thread_Heir->current_priority ) {
-        _Thread_Heir = the_thread;
-        if ( _Thread_Executing->is_preemptible ||
-             the_thread->current_priority == 0 )
-          _Thread_Dispatch_necessary = true;
-      }
+      _Scheduler_Unblock( &_Scheduler, the_thread );
     }
   }
 
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsetpriority.c rtems/cpukit/score/src/threadsetpriority.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsetpriority.c	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/score/src/threadsetpriority.c	2010-08-13 11:50:20.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -50,10 +52,6 @@ void _Thread_Set_priority(
 )
 {
   the_thread->current_priority = new_priority;
-  the_thread->ready            = &_Thread_Ready_chain[ new_priority ];
 
-  _Priority_bit_map_Initialize_information( 
-      &the_thread->Priority_map, 
-      new_priority 
-  );
+  _Scheduler_Sched_update(&_Scheduler, the_thread);
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsetstate.c rtems/cpukit/score/src/threadsetstate.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsetstate.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/threadsetstate.c	2010-08-13 11:50:27.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -54,9 +56,7 @@ void _Thread_Set_state(
 )
 {
   ISR_Level      level;
-  Chain_Control *ready;
-
-  ready = the_thread->ready;
+  
   _ISR_Disable( level );
   if ( !_States_Is_ready( the_thread->current_state ) ) {
     the_thread->current_state =
@@ -67,21 +67,7 @@ void _Thread_Set_state(
 
   the_thread->current_state = state;
 
-  if ( _Chain_Has_only_one_node( ready ) ) {
-
-    _Chain_Initialize_empty( ready );
-    _Priority_bit_map_Remove( &the_thread->Priority_map );
-
-  } else
-    _Chain_Extract_unprotected( &the_thread->Object.Node );
-
-  _ISR_Flash( level );
-
-  if ( _Thread_Is_heir( the_thread ) )
-     _Thread_Calculate_heir();
-
-  if ( _Thread_Is_executing( the_thread ) )
-    _Thread_Dispatch_necessary = true;
+  _Scheduler_Block( &_Scheduler, the_thread);
 
   _ISR_Enable( level );
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsettransient.c rtems/cpukit/score/src/threadsettransient.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsettransient.c	2010-07-29 18:57:14.000000000 -0400
+++ rtems/cpukit/score/src/threadsettransient.c	2010-08-13 11:50:35.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -54,22 +56,14 @@ void _Thread_Set_transient(
 {
   ISR_Level             level;
   uint32_t              old_state;
-  Chain_Control *ready;
-
-  ready = the_thread->ready;
+  
   _ISR_Disable( level );
 
   old_state = the_thread->current_state;
   the_thread->current_state = _States_Set( STATES_TRANSIENT, old_state );
 
   if ( _States_Is_ready( old_state ) ) {
-    if ( _Chain_Has_only_one_node( ready ) ) {
-
-      _Chain_Initialize_empty( ready );
-      _Priority_bit_map_Remove( &the_thread->Priority_map );
-
-    } else
-      _Chain_Extract_unprotected( &the_thread->Object.Node );
+    _Ready_queue_Extract(&_Scheduler.ready_queue, the_thread);
   }
 
   _ISR_Enable( level );
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsuspend.c rtems/cpukit/score/src/threadsuspend.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadsuspend.c	2010-08-11 14:25:07.000000000 -0400
+++ rtems/cpukit/score/src/threadsuspend.c	2010-08-13 11:50:43.000000000 -0400
@@ -23,6 +23,8 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/readyq.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -52,9 +54,7 @@ void _Thread_Suspend(
 )
 {
   ISR_Level      level;
-  Chain_Control *ready;
-
-  ready = the_thread->ready;
+  
   _ISR_Disable( level );
   if ( !_States_Is_ready( the_thread->current_state ) ) {
     the_thread->current_state =
@@ -65,21 +65,7 @@ void _Thread_Suspend(
 
   the_thread->current_state = STATES_SUSPENDED;
 
-  if ( _Chain_Has_only_one_node( ready ) ) {
-
-    _Chain_Initialize_empty( ready );
-    _Priority_bit_map_Remove( &the_thread->Priority_map );
-
-  } else
-    _Chain_Extract_unprotected( &the_thread->Object.Node );
-
-  _ISR_Flash( level );
-
-  if ( _Thread_Is_heir( the_thread ) )
-     _Thread_Calculate_heir();
-
-  if ( _Thread_Is_executing( the_thread ) )
-    _Thread_Dispatch_necessary = true;
+  _Scheduler_Block(&_Scheduler, the_thread);
 
   _ISR_Enable( level );
 }
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadtickletimeslice.c rtems/cpukit/score/src/threadtickletimeslice.c
--- /home/gedare/work/rtems/rtems/rtems/cpukit/score/src/threadtickletimeslice.c	2010-06-29 13:47:53.000000000 -0400
+++ rtems/cpukit/score/src/threadtickletimeslice.c	2010-07-08 13:33:02.000000000 -0400
@@ -23,6 +23,7 @@
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
 #include <rtems/score/priority.h>
+#include <rtems/score/scheduler.h>
 #include <rtems/score/states.h>
 #include <rtems/score/sysstate.h>
 #include <rtems/score/thread.h>
@@ -89,7 +90,7 @@ void _Thread_Tickle_timeslice( void )
          *  currently executing thread is placed at the rear of the
          *  FIFO for this priority and a new heir is selected.
          */
-        _Thread_Yield_processor();
+        _Scheduler_Yield( );
         executing->cpu_time_budget = _Thread_Ticks_per_timeslice;
       }
       break;
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/doc/user/conf.t rtems/doc/user/conf.t
--- /home/gedare/work/rtems/rtems/rtems/doc/user/conf.t	2010-06-21 11:29:27.000000000 -0400
+++ rtems/doc/user/conf.t	2010-08-13 15:06:13.000000000 -0400
@@ -24,6 +24,7 @@ RTEMS must be configured for an applicat
 information encompasses a variety of information including 
 the length of each clock tick, the maximum number of each RTEMS
 object that can be created, the application initialization tasks,
+the task scheduling algorithm to be used, 
 and the device drivers in the application.  This information
 is placed in data structures that are given to RTEMS at
 system initialization time.  This chapter details the 
@@ -392,6 +393,54 @@ and the user is assumed to provide one o
 @c
 @c
 @c
+@subsection Scheduler Algorithm Configuration
+This section defines the configuration parameters related to selecting 
+a scheduling algorithm for an application.  Regardless of whether 
+@code{CONFIGURE_SCHEDULER_POLICY} is defined, if none of the other 
+configuration parameters are set, then @code{rtems/confdefs.h} will define 
+@code{CONFIGURE_SCHEDULER_PRIORITY} and will (re)define 
+@code{CONFIGURE_SCHEDULER_POLICY} as @code{_Scheduler_Priority}. That is, 
+@code{CONFIGURE_SCHEDULER_PRIORITY} is the default scheduling algorithm.
+
+@itemize @bullet
+@findex CONFIGURE_SCHEDULER_POLICY
+@item @code{CONFIGURE_SCHEDULER_POLICY} is defined to specify which 
+scheduling algorithm an application will use.  If it is undefined, 
+then @code{rtems/confdefs.h} will define it based on the definition 
+of the following configuration parameters.
+Valid values for this configuration parameter are: 
+@code{_Scheduler_USER},
+@code{_Scheduler_Priority}.
+
+@findex CONFIGURE_SCHEDULER_USER
+@item @code{CONFIGURE_SCHEDULER_USER} is defined if the application 
+provides its own scheduling algorithm. If @code{CONFIGURE_SCHEDULER_USER} is 
+defined then @code{CONFIGURE_SCHEDULER_ENTRY_USER} must be defined with the 
+name of the application's initialization function.  If both 
+configuration parameters are defined and @code{CONFIGURE_SCHEDULER_POLICY} 
+is undefined, then @code{CONFIGURE_SCHEDULER_POLICY} will be be defined as 
+@code{_Scheduler_USER}.
+
+@findex CONFIGURE_SCHEDULER_ALL
+@item @code{CONFIGURE_SCHEDULER_ALL} is defined if the application 
+chooses to include all of the RTEMS-provided schedulers.  
+@code{CONFIGURE_SCHEDULER_ALL} will define all of the following configuration 
+parameters and will use @code{CONFIGURE_SCHEDULER_POLICY} to select the 
+algorithm to use. If @code{CONFIGURE_SCHEDULER_POLICY} is not defined, then 
+@code{rtems/confdefs.h} will define it as @code{_Scheduler_Priority}.
+
+@findex CONFIGURE_SCHEDULER_PRIORITY
+@item @code{CONFIGURE_SCHEDULER_PRIORITY} is defined if the application 
+will use the Priority Scheduling algorithm.
+If none of the previous configuration parameters are defined by the 
+application, then @code{rtems/confdefs.h} will define 
+@code{CONFIGURE_SCHEDULER_POLICY} as @code{_Scheduler_PRIORITY}.
+
+@end itemize
+
+@c
+@c
+@c
 @subsection Device Driver Table
 
 This section defines the configuration parameters related
@@ -816,6 +865,7 @@ typedef struct @{
   uint32_t                        maximum_extensions;
   uint32_t                        microseconds_per_tick;
   uint32_t                        ticks_per_timeslice;
+  uint32_t                        scheduler_policy;
   void                          (*idle_task)( void );
   uint32_t                        idle_task_stack_size;
   uint32_t                        interrupt_stack_size;
@@ -875,6 +925,12 @@ When using the @code{rtems/confdefs.h} m
 an RTEMS application, the value for this field corresponds
 to the setting of the macro @code{CONFIGURE_TICKS_PER_TIMESLICE}.
 
+@item scheduler_policy
+is the algorithm to use for task scheduling.
+When using the @code{rtems/confdefs.h} mechanism for configuring
+an RTEMS application, the value for this field corresponds
+to the setting of the macro @code{CONFIGURE_SCHEDULER_POLICY}.
+
 @item idle_task
 is the address of the optional user
 provided routine which is used as the system's IDLE task.  If
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/doc/user/schedule.t rtems/doc/user/schedule.t
--- /home/gedare/work/rtems/rtems/rtems/doc/user/schedule.t	2009-11-09 09:36:14.000000000 -0500
+++ rtems/doc/user/schedule.t	2010-08-13 14:42:37.000000000 -0400
@@ -30,7 +30,30 @@ The component of RTEMS responsible for p
 capability is appropriately called the scheduler.  The
 scheduler's sole purpose is to allocate the all important
 resource of processor time to the various tasks competing for
-attention.  The RTEMS scheduler allocates the processor using a
+attention.  
+
+@section Scheduling Algorithms
+
+@cindex scheduling algorithms
+
+RTEMS provides multiple possible scheduling algorithms, each 
+of which are appropriate to different use case scenarios. 
+The classic RTEMS scheduling algorithm -- the only 
+algorithm available in RTEMS 4.10 and earlier -- is the priority
+scheduling algorithm.  When not specified, the priority scheduling
+algorithm can be assumed.
+
+RTEMS currently supports the following scheduling algorithms:
+
+@itemize @bullet
+@item Priority scheduling
+@end itemize
+
+@subsection Priority Scheduling
+
+@cindex priority scheduling
+
+The RTEMS scheduler allocates the processor using a
 priority-based, preemptive algorithm augmented to provide
 round-robin characteristics within individual priority groups.
 The goal of this algorithm is to guarantee that the task which
@@ -50,6 +73,11 @@ chain is allocated the processor.  RTEMS
 the second method to guarantee faster response times to external
 events.
 
+Priority scheduling is the most commonly used scheduling algorithm.
+It should be used by applications in which multiple tasks contend for 
+CPU time or other resources and there is a need to ensure certain tasks
+are given priority over other tasks.
+
 @section Scheduling Mechanisms
 
 @cindex scheduling mechanisms
@@ -81,6 +109,11 @@ description.
 
 @cindex task priority
 
+This mechanism affects the following scheduling algorithms:
+@itemize @bullet
+@item Priority scheduling
+@end itemize
+
 The most significant of these mechanisms is the
 ability for the user to assign a priority level to each
 individual task when it is created and to alter a task's
@@ -104,6 +137,11 @@ to a task.}
 
 @cindex preemption
 
+This mechanism affects the following scheduling algorithms:
+@itemize @bullet
+@item Priority scheduling
+@end itemize
+
 Another way the user can alter the basic scheduling
 algorithm is by manipulating the preemption mode flag
 (@code{@value{RPREFIX}PREEMPT_MASK}) of individual tasks.  If preemption is disabled
@@ -120,6 +158,11 @@ control of the processor.
 @cindex timeslicing
 @cindex round robin scheduling
 
+This mechanism affects the following scheduling algorithms:
+@itemize @bullet
+@item Priority scheduling
+@end itemize
+
 Timeslicing or round-robin scheduling is an
 additional method which can be used to alter the basic
 scheduling algorithm.  Like preemption, timeslicing is specified
@@ -141,6 +184,11 @@ entire timeslice.
 
 @cindex manual round robin
 
+This mechanism affects the following scheduling algorithms:
+@itemize @bullet
+@item Priority scheduling
+@end itemize
+
 The final mechanism for altering the RTEMS scheduling
 algorithm is called manual round-robin.  Manual round-robin is
 invoked by using the @code{@value{DIRPREFIX}task_wake_after}
@@ -151,7 +199,7 @@ end of its priority group.  If no other 
 priority are ready to run, then the task does not lose control
 of the processor.
 
-@subsection Dispatching Tasks
+@section Dispatching Tasks
 
 @cindex dispatching
 
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/configure.ac rtems/testsuites/sptests/configure.ac
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/configure.ac	2010-08-11 14:25:11.000000000 -0400
+++ rtems/testsuites/sptests/configure.ac	2010-08-13 11:51:10.000000000 -0400
@@ -154,6 +154,12 @@ spmountmgr01/Makefile
 spnotepad01/Makefile
 spobjgetnext/Makefile
 spprintk/Makefile
+sprbtree01/Makefile
+spsched01/Makefile
+spsched02/Makefile
+spsched03/Makefile
+spsched04/Makefile
+spsched05/Makefile
 spprivenv01/Makefile
 spsize/Makefile
 spstkalloc/Makefile
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/Makefile.am rtems/testsuites/sptests/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/Makefile.am	2010-08-11 14:25:11.000000000 -0400
+++ rtems/testsuites/sptests/Makefile.am	2010-08-13 11:50:54.000000000 -0400
@@ -16,7 +16,8 @@ SUBDIRS = \
     sp60      sp62 sp63 sp64 sp65 sp66 sp67 sp68 sp69 \
     sp70 sp71 sp72 \
     spassoc01 spchain spclockget spcoverage spobjgetnext \
-    spnotepad01 spprintk spprivenv01 spsize spstkalloc spthreadq01 \
+    spnotepad01 spprintk sprbtree01 spsize spstkalloc spthreadq01 \
+		spsched01 spsched02 spsched03 spsched04 spsched05 \
     spwatchdog spwkspace \
     sperror01 sperror02 sperror03 \
     spfatal01 spfatal02 spfatal03 spfatal04 spfatal05 spfatal06 spfatal07 \
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sp69/init.c rtems/testsuites/sptests/sp69/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sp69/init.c	2009-12-15 13:24:12.000000000 -0500
+++ rtems/testsuites/sptests/sp69/init.c	2010-07-22 17:03:14.000000000 -0400
@@ -47,7 +47,7 @@ rtems_task Init(
 
   /* Check status values. */
   rtems_test_assert( period_status.owner == rtems_task_self() );
-  rtems_test_assert( period_status.state == RATE_MONOTONIC_INACTIVE );
+  rtems_test_assert( period_status.state == PERIODIC_INACTIVE );
   #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
     rtems_test_assert( period_status.since_last_period.tv_sec == 0 );
     rtems_test_assert( period_status.since_last_period.tv_nsec == 0 );
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spintrcritical08/init.c rtems/testsuites/sptests/spintrcritical08/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spintrcritical08/init.c	2009-11-29 22:33:25.000000000 -0500
+++ rtems/testsuites/sptests/spintrcritical08/init.c	2010-07-22 17:15:43.000000000 -0400
@@ -17,13 +17,13 @@ rtems_id Main_task;
 rtems_id Period;
 volatile bool case_hit;
 
-rtems_rate_monotonic_period_states getState(void)
+rtems_periodic_period_states getState(void)
 {
   Objects_Locations       location;
-  Rate_monotonic_Control *period;
+  Periodic_Control *period;
 
-  period = (Rate_monotonic_Control *)_Objects_Get(
-    &_Rate_monotonic_Information, Period, &location );
+  period = (Periodic_Control *)_Objects_Get(
+    &_Periodic_Information, Period, &location );
   if ( location != OBJECTS_LOCAL ) {
     puts( "Bad object lookup" );
     rtems_test_exit(0);
@@ -38,7 +38,7 @@ rtems_timer_service_routine test_release
   void     *arg
 )
 {
-  if ( getState() == RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING )
+  if ( getState() == PERIODIC_EXPIRED_WHILE_BLOCKING )
     case_hit = true;
 }
 
@@ -53,12 +53,12 @@ rtems_task Init(
 
   puts( "Init - Trying to generate period ending while blocking" );
 
-  puts( "Init - rtems_rate_monotonic_create - OK" );
-  sc = rtems_rate_monotonic_create(
+  puts( "Init - rtems_periodic_create - OK" );
+  sc = rtems_periodic_create(
     rtems_build_name( 'P', 'E', 'R', '1' ),
     &Period
   );
-  directive_failed( sc, "rtems_rate_monotonic_create" );
+  directive_failed( sc, "rtems_periodic_create" );
 
   Main_task = rtems_task_self();
 
@@ -70,10 +70,10 @@ rtems_task Init(
     if ( interrupt_critical_section_test_support_delay() )
       resets++;
 
-    sc = rtems_rate_monotonic_period( Period, 1 );
+    sc = rtems_periodic_period( Period, 1 );
     if ( sc == RTEMS_TIMEOUT )
       continue;
-    directive_failed( sc, "rtems_monotonic_period");
+    directive_failed( sc, "rtems_periodic_period");
   }
 
   if ( case_hit ) {
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/init.c rtems/testsuites/sptests/sprbtree01/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/sprbtree01/init.c	2010-07-20 17:49:15.000000000 -0400
@@ -0,0 +1,416 @@
+/*
+ * Copyright (c) 2010 Gedare Bloom.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <tmacros.h>
+#include <rtems/rbtree.h>
+
+int numbers[20] = {
+52, 99, 5, 85, 43, 44, 10, 60, 50, 19, 8, 68, 48, 57, 17, 67, 90, 12, 77, 71};
+
+int numbers_sorted[20] = {
+  5, 8, 10, 12, 17, 19, 43, 44, 48, 50, 52, 57, 60, 67, 68, 71, 77, 85, 90, 99};
+
+typedef struct {
+  int              id;
+  rtems_rbtree_node Node;
+} test_node;
+
+/* 
+ * recursively checks tree. if the tree is built properly it should only 
+ * be a depth of 7 function calls for 100 entries in the tree. 
+ */
+int rb_assert ( rtems_rbtree_node *root )
+{
+  int lh, rh;
+
+  if ( root == NULL )
+    return 1;
+  else {
+    rtems_rbtree_node *ln = rtems_rbtree_left(root);
+    rtems_rbtree_node *rn = rtems_rbtree_right(root);
+
+    /* Consecutive red links */
+    if ( root->color == RBT_RED ) {
+      if ((ln && ln->color == RBT_RED)  || (rn && rn->color == RBT_RED)) {
+        puts ( "Red violation" );
+        return -1;
+      }
+    }
+
+      lh = rb_assert ( ln );
+      rh = rb_assert ( rn );
+
+    /* Invalid binary search tree */
+    if ( ( ln != NULL && ln->value >= root->value )
+        || ( rn != NULL && rn->value <= root->value ) )
+    {
+      puts ( "Binary tree violation" );
+      return -1;
+    }
+
+    /* Black height mismatch */
+    if ( lh != -1 && rh != -1 && lh != rh ) {
+      puts ( "Black violation" );
+      return -1;
+    }
+
+    /* Only count black links */
+    if ( lh != -1 && rh != -1 )
+      return ( root->color == RBT_RED ) ? lh : lh + 1;
+    else
+      return -1;
+  }
+}
+
+
+
+rtems_task Init(
+    rtems_task_argument ignored
+    )
+{
+  rtems_rbtree_control  rbtree1;
+  rtems_rbtree_node    *p;
+  test_node            node1, node2;
+  test_node            node_array[100];
+  int                  id;
+  int i;
+
+  puts( "\n\n*** TEST OF RTEMS RBTREE API ***" );
+
+  puts( "Init - Initialize rbtree empty" );
+  rtems_rbtree_initialize_empty( &rbtree1 );
+  
+  /* verify that the rbtree insert work */
+  puts( "INIT - Verify rtems_rbtree_insert with two nodes" );
+  node1.id = 1;
+  node1.Node.value = 1;
+  node2.id = 2;
+  node2.Node.value = 2;
+  rtems_rbtree_insert( &rbtree1, &node1.Node );
+  rtems_rbtree_insert( &rbtree1, &node2.Node );
+
+  if (!rb_assert(rbtree1.root) )
+    puts( "INIT - FAILED TREE CHECK" );
+
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 1 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 2 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+  if (id < 2) {
+    puts("INIT - NOT ENOUGH NODES ON RBTREE");
+    rtems_test_exit(0);
+  }
+
+  puts("INIT - Verify rtems_rbtree_insert with the same value twice");
+  node2.Node.value = node1.Node.value;
+  rtems_rbtree_insert(&rbtree1, &node1.Node);
+  rtems_rbtree_insert(&rbtree1, &node2.Node);
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 1 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 1 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+  if (id < 1) {
+    puts("INIT - NOT ENOUGH NODES ON RBTREE");
+    rtems_test_exit(0);
+  }
+  node2.Node.value = 2;
+
+  /* verify that the rbtree is empty */
+  puts( "INIT - Verify rtems_rbtree_is_empty" );
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Verify rtems_XXX on an empty tree" );
+  if(rtems_rbtree_get_min(&rbtree1)) {
+    puts("INIT - get_min on empty returned non-NULL");
+    rtems_test_exit(0);
+  }
+  if(rtems_rbtree_get_max(&rbtree1)) {
+    puts("INIT - get_max on empty returned non-NULL");
+    rtems_test_exit(0);
+  }
+  if(rtems_rbtree_peek_min(&rbtree1)) {
+    puts("INIT - peek_min on empty returned non-NULL");
+    rtems_test_exit(0);
+  }
+  if(rtems_rbtree_peek_max(&rbtree1)) {
+    puts("INIT - peek_max on empty returned non-NULL");
+    rtems_test_exit(0);
+  }
+
+
+  /* verify that the rbtree insert works after a tree is emptied */
+  puts( "INIT - Verify rtems_rbtree_insert after empty tree" );
+  node1.id = 2;
+  node1.Node.value = 2;
+  node2.id = 1;
+  node2.Node.value = 1;
+  rtems_rbtree_insert( &rbtree1, &node1.Node );
+  rtems_rbtree_insert( &rbtree1, &node2.Node );
+
+  puts( "INIT - Verify rtems_rbtree_peek_max/min, rtems_rbtree_extract" );
+  if(rtems_rbtree_peek_max(&rbtree1)->value - 
+      rtems_rbtree_peek_min(&rbtree1)->value != 1) {
+    puts( "INIT - Peek Min - Max failed" );
+    rtems_test_exit(0);
+  }
+  p = rtems_rbtree_peek_max(&rbtree1);
+  rtems_rbtree_extract(&rbtree1, p);
+  if (p->value != 2) {
+    puts( "INIT - rtems_rbtree_extract failed");
+    rtems_test_exit(0);
+  }
+  rtems_rbtree_insert(&rbtree1, p);
+
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 1 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 2 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+  }
+  
+  puts( "INIT - Verify rtems_rbtree_insert with 100 nodes value [0,99]" );
+  for (i = 0; i < 100; i++) {
+    node_array[i].id = i;
+    node_array[i].Node.value = i;
+    rtems_rbtree_insert( &rbtree1, &node_array[i].Node );
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  puts( "INIT - Removing 100 nodes" );
+
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 0 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 99 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+  
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Verify rtems_rbtree_insert with 100 nodes value [99,0]" );
+  for (i = 0; i < 100; i++) {
+    node_array[i].id = 99-i;
+    node_array[i].Node.value = 99-i;
+    rtems_rbtree_insert( &rbtree1, &node_array[i].Node );
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  puts( "INIT - Removing 100 nodes" );
+
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 0 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 99 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Verify rtems_rbtree_get_max with 100 nodes value [99,0]" );
+  for (i = 0; i < 100; i++) {
+    node_array[i].id = 99-i;
+    node_array[i].Node.value = 99-i;
+    rtems_rbtree_insert( &rbtree1, &node_array[i].Node );
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  puts( "INIT - Removing 100 nodes" );
+
+  for ( p = rtems_rbtree_get_max(&rbtree1), id = 0 ; p ;
+      p = rtems_rbtree_get_max(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 99 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != 99-id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Verify rtems_rbtree_get_max with 100 nodes value [0,99]" );
+  for (i = 0; i < 100; i++) {
+    node_array[i].id = i;
+    node_array[i].Node.value = i;
+    rtems_rbtree_insert( &rbtree1, &node_array[i].Node );
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  puts( "INIT - Verify rtems_rbtree_find" );
+  p = rtems_rbtree_find(&rbtree1, 50);
+  if(rtems_rbtree_container_of(p,test_node,Node)->id != 50) {
+    puts ("INIT - ERROR ON RBTREE ID MISMATCH");
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Verify rtems_rbtree_predecessor/successor");
+  p = rtems_rbtree_predecessor(p);
+  if(p && rtems_rbtree_container_of(p,test_node,Node)->id > 50) {
+    puts ("INIT - ERROR ON RBTREE ID MISMATCH");
+    rtems_test_exit(0);
+  }
+  p = rtems_rbtree_find(&rbtree1, 50);
+  p = rtems_rbtree_successor(p);
+  if(p && rtems_rbtree_container_of(p,test_node,Node)->id < 50) {
+    puts ("INIT - ERROR ON RBTREE ID MISMATCH");
+    rtems_test_exit(0);
+  }
+
+  p = rtems_rbtree_find(&rbtree1, 50);
+  puts( "INIT - Verify rtems_rbtree_find_header" );
+  if (rtems_rbtree_find_header(p) != &rbtree1) {
+    puts ("INIT - ERROR ON RBTREE HEADER MISMATCH");
+    rtems_test_exit(0);
+  }
+
+  puts( "INIT - Removing 100 nodes" );
+
+  for ( p = rtems_rbtree_get_max(&rbtree1), id = 99 ; p ;
+      p = rtems_rbtree_get_max(&rbtree1) , id-- ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id < 0 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != id ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts("INIT - Insert 20 random numbers");
+  for (i = 0; i < 20; i++) {
+    node_array[i].id = numbers[i];
+    node_array[i].Node.value = numbers[i];
+    rtems_rbtree_insert( &rbtree1, &node_array[i].Node );
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  puts( "INIT - Removing 20 nodes" );
+
+  for ( p = rtems_rbtree_get_min(&rbtree1), id = 0 ; p ;
+      p = rtems_rbtree_get_min(&rbtree1) , id++ ) {
+    test_node *t = rtems_rbtree_container_of(p,test_node,Node);
+    if ( id > 19 ) {
+      puts( "INIT - TOO MANY NODES ON RBTREE" );
+      rtems_test_exit(0);
+    }
+    if ( t->id != numbers_sorted[id] ) {
+      puts( "INIT - ERROR ON RBTREE ID MISMATCH" );
+      rtems_test_exit(0);
+    }
+
+    if (!rb_assert(rbtree1.root) )
+      puts( "INIT - FAILED TREE CHECK" );
+  }
+
+  if(!rtems_rbtree_is_empty(&rbtree1)) {
+    puts( "INIT - TREE NOT EMPTY" );
+    rtems_test_exit(0);
+  }
+
+  puts( "*** END OF RTEMS RBTREE API TEST ***" );
+  rtems_test_exit(0);
+}
+
+/* configuration information */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+#define CONFIGURE_MAXIMUM_TASKS 1
+
+#define CONFIGURE_INIT
+#include <rtems/confdefs.h>
+
+/* global variables */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/Makefile.am rtems/testsuites/sptests/sprbtree01/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/sprbtree01/Makefile.am	2010-07-20 13:16:22.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id$
+##
+
+MANAGERS = all
+
+rtems_tests_PROGRAMS = sprbtree01
+sprbtree01_SOURCES = init.c
+
+dist_rtems_tests_DATA = sprbtree01.scn
+dist_rtems_tests_DATA += sprbtree01.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+sprbtree01_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(sprbtree01_OBJECTS) $(sprbtree01_LDADD)
+LINK_LIBS = $(sprbtree01_LDLIBS)
+
+sprbtree01$(EXEEXT): $(sprbtree01_OBJECTS) $(sprbtree01_DEPENDENCIES)
+	@rm -f sprbtree01$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/sprbtree01.doc rtems/testsuites/sptests/sprbtree01/sprbtree01.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/sprbtree01.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/sprbtree01/sprbtree01.doc	2010-07-20 13:16:03.000000000 -0400
@@ -0,0 +1,25 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-2009.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  sprbtree01
+
+directives:
+
+  rtems_rbtree_initialize_empty
+  rtems_rbtree_insert
+  rtems_rbtree_get
+  rtems_rbtree_peek
+
+concepts:
+
++ Ensure that the rbtree operations listed above behave as defined.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/sprbtree01.scn rtems/testsuites/sptests/sprbtree01/sprbtree01.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/sprbtree01/sprbtree01.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/sprbtree01/sprbtree01.scn	2010-07-20 13:15:40.000000000 -0400
@@ -0,0 +1,19 @@
+*** TEST OF RTEMS RBTREE API ***
+Init - Initialize rbtree empty
+INIT - Verify rtems_rbtree_insert with two nodes
+INIT - Verify rtems_rbtree_insert with the same value twice
+INIT - Verify rtems_rbtree_is_empty
+INIT - Verify rtems_XXX on an empty tree
+INIT - Verify rtems_rbtree_insert after empty tree
+INIT - Verify rtems_rbtree_peek_max/min, rtems_rbtree_extract
+INIT - Verify rtems_rbtree_insert with 100 nodes value [0,99]
+INIT - Removing 100 nodes
+INIT - Verify rtems_rbtree_insert with 100 nodes value [99,0]
+INIT - Removing 100 nodes
+INIT - Verify rtems_rbtree_get_max with 100 nodes value [99,0]
+INIT - Removing 100 nodes
+INIT - Verify rtems_rbtree_get_max with 100 nodes value [0,99]
+INIT - Verify rtems_rbtree_find
+INIT - Verify rtems_rbtree_find_header
+INIT - Removing 100 nodes
+*** END OF RTEMS RBTREE API TEST ***
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/init.c rtems/testsuites/sptests/spsched01/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/init.c	2010-07-12 15:38:04.000000000 -0400
@@ -0,0 +1,85 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is a user initialization task and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: init.c,v 1.11 2008/02/01 00:45:10 joel Exp $
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+
+rtems_task Init(
+  rtems_task_argument argument
+)
+{
+  rtems_time_of_day time;
+  rtems_status_code status;
+
+  puts( "\n\n*** SCHEDULER TEST 1 ***" );
+
+  build_time( &time, 12, 31, 1988, 9, 0, 0, 0 );
+  status = rtems_clock_set( &time );
+  directive_failed( status, "rtems_clock_set" );
+
+  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
+  Task_name[ 3 ] = rtems_build_name( 'T', 'A', '3', ' ' );
+
+  status = rtems_task_create(
+     Task_name[ 1 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 2,
+     RTEMS_INTERRUPT_LEVEL(31),
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 1 ]
+  );
+  directive_failed( status, "rtems_task_create of TA1" );
+
+  status = rtems_task_create(
+     Task_name[ 2 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 2,
+     RTEMS_DEFAULT_MODES,
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 2 ]
+  );
+  directive_failed( status, "rtems_task_create of TA2" );
+
+  status = rtems_task_create(
+     Task_name[ 3 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 3,
+     RTEMS_DEFAULT_MODES,
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 3 ]
+  );
+  directive_failed( status, "rtems_task_create of TA3" );
+
+  status = rtems_task_start( Task_id[ 1 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA1" );
+
+  status = rtems_task_start( Task_id[ 2 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA2" );
+
+  status = rtems_task_start( Task_id[ 3 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA3" );
+
+  status = rtems_task_delete( RTEMS_SELF );
+  directive_failed( status, "rtems_task_delete of RTEMS_SELF" );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/Makefile.am rtems/testsuites/sptests/spsched01/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/Makefile.am	2010-07-08 14:17:44.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id: Makefile.am,v 1.23 2009/04/03 12:48:12 ralf Exp $
+##
+
+MANAGERS = io semaphore clock
+
+rtems_tests_PROGRAMS = spsched01
+spsched01_SOURCES = init.c task1.c system.h
+
+dist_rtems_tests_DATA = spsched01.scn
+dist_rtems_tests_DATA += spsched01.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+spsched01_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(spsched01_OBJECTS) $(spsched01_LDADD)
+LINK_LIBS = $(spsched01_LDLIBS)
+
+spsched01$(EXEEXT): $(spsched01_OBJECTS) $(spsched01_DEPENDENCIES)
+	@rm -f spsched01$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/spsched01.doc rtems/testsuites/sptests/spsched01/spsched01.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/spsched01.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/spsched01.doc	2010-07-28 10:52:50.000000000 -0400
@@ -0,0 +1,47 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-1999.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  sched01
+
+directives:
+  ex_init, ex_start, t_create, t_start, tm_tick, i_return, t_ident,
+  tm_set, tm_get, tm_wkafter
+
+concepts:
+
+This test is identical to sp01 but for FIFO-based scheduling:
+
+  a.  Verifies system can create and start both the executive's system
+      initialization and idle task.
+
+  b.  Verifies executive can swap between three application tasks at the
+      same priority and the executive's internal idle task.
+
+  c.  Verifies can print strings to the CRT on port 2 of the mvme136 board
+      using Print and Println in the board support package.
+
+  d.  Verifies interrupt handler can handle a task switch from an interrupt
+      as specified with the i_return directive.
+
+  e.  Verifies executive initialization performed correctly.
+
+  f.  Verifies the executive trap handler except for the halt function.
+
+  g.  Verifies that a task can get the task identification number of itself.
+
+  h.  Verifies implementation of SuperCore TOD_MILLISECONDS_TO_TICKS.  Normal
+      computation in applications is via a macro at the Classic API level.
+
+output:
+ "TA1" is printed once every 5 seconds.  "TA2" is printed once
+ every 10 seconds.  "TA3" is printed once every 15 seconds.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/spsched01.scn rtems/testsuites/sptests/spsched01/spsched01.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/spsched01.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/spsched01.scn	2010-07-12 18:10:00.000000000 -0400
@@ -0,0 +1,18 @@
+*** SCHEDULER TEST 1 ***
+TA1  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:05   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:10   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:10   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:15   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:15   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:20   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:20   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:25   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:30   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:30   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:30   12/31/1988
+*** END OF SCHEDULER TEST 1 ***
+
+NOTE: The order of the prints at each time interval is irrelevant.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/system.h rtems/testsuites/sptests/spsched01/system.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/system.h	2010-07-16 17:26:53.000000000 -0400
@@ -0,0 +1,47 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: system.h,v 1.15 2004/04/01 15:16:29 ralf Exp $
+ */
+
+#include <tmacros.h>
+
+/* functions */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1_through_3(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+
+#define CONFIGURE_SCHEDULER_FIFO
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#define CONFIGURE_EXTRA_TASK_STACKS         (4 * RTEMS_MINIMUM_STACK_SIZE)
+#define CONFIGURE_MAXIMUM_TASKS             4
+
+#include <rtems/confdefs.h>
+
+/* global variables */
+
+TEST_EXTERN rtems_id   Task_id[ 4 ];         /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 4 ];       /* array of task names */
+
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/task1.c rtems/testsuites/sptests/spsched01/task1.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched01/task1.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched01/task1.c	2010-07-12 15:38:13.000000000 -0400
@@ -0,0 +1,57 @@
+/*  Task_1_through_3
+ *
+ *  This routine serves as a test task.  It verifies the basic task
+ *  switching capabilities of the executive.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: task1.c,v 1.12 2009/11/30 03:33:23 ralf Exp $
+ */
+
+#include "system.h"
+
+rtems_task Task_1_through_3(
+  rtems_task_argument argument
+)
+{
+  rtems_id          tid;
+  rtems_time_of_day time;
+  rtems_status_code status;
+  rtems_interval    ticks;
+
+  status = rtems_task_ident( RTEMS_SELF, RTEMS_SEARCH_ALL_NODES, &tid );
+  directive_failed( status, "rtems_task_ident" );
+
+  /*
+   * Use TOD_MILLISECONDS_TO_TICKS not RTEMS_MILLISECONDS_TO_TICKS to
+   * test C implementation in SuperCore -- not macro version used
+   * everywhere else.
+   */
+  ticks = TOD_MILLISECONDS_TO_TICKS( task_number( tid ) * 5 * 1000 );
+
+  while( FOREVER ) {
+    status = rtems_clock_get_tod( &time );
+    directive_failed( status, "rtems_clock_get_tod" );
+
+    if ( time.second >= 35 ) {
+      puts( "*** END OF SCHEDULER TEST 1 ***" );
+      rtems_test_exit( 0 );
+    }
+
+    put_name( Task_name[ task_number( tid ) ], FALSE );
+    print_time( " - rtems_clock_get_tod - ", &time, "\n" );
+
+    status = rtems_task_wake_after( ticks );
+    directive_failed( status, "rtems_task_wake_after" );
+  }
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/.cvsignore rtems/testsuites/sptests/spsched02/.cvsignore
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/.cvsignore	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched02/.cvsignore	2010-07-12 18:09:20.000000000 -0400
@@ -0,0 +1,2 @@
+Makefile
+Makefile.in
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/init.c rtems/testsuites/sptests/spsched02/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched02/init.c	2010-07-16 17:27:08.000000000 -0400
@@ -0,0 +1,207 @@
+/*
+ *  Exercise thread queue enqueue and dequeue priority
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: init.c,v 1.8 2009/11/30 03:33:24 ralf Exp $
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <bsp.h>
+
+#include "tmacros.h"
+
+#define MAX_TASKS 20
+
+rtems_task Init(rtems_task_argument argument);
+rtems_task Locker_task(rtems_task_argument unused);
+void do_test(
+  rtems_attribute attr,
+  bool            extract  /* TRUE if extract, not release */
+);
+
+/*
+ * Carefully chosen to exercise threadq enqueue/dequeue priority logic.
+ * Somewhat randomly sorted to ensure than if discipline is FIFO, run-time
+ * behavior won't be the same when released.
+ */
+rtems_task_priority Priorities_High[MAX_TASKS] = {
+  37, 37, 37, 37,       /* backward - more 2-n */
+  2, 2, 2, 2,           /* forward - multiple are on 2-n chain */
+  4, 3,                 /* forward - search forward arbitrary */
+  3, 3, 3, 3,           /* forward - more 2-n */
+  38, 37,               /* backward - search backward arbitrary */
+  34, 34, 34, 34,       /* backward - multple on 2-n chain */
+};
+
+rtems_task_priority Priorities_Low[MAX_TASKS] = {
+  13, 13, 13, 13,       /* backward - more 2-n */
+  2, 2, 2, 2,           /* forward - multiple are on 2-n chain */
+  4, 3,                 /* forward - search forward arbitrary */
+  3, 3, 3, 3,           /* forward - more 2-n */
+  14, 13,               /* backward - search backward arbitrary */
+  12, 12, 12, 12,       /* backward - multple on 2-n chain */
+};
+
+rtems_task_priority *Priorities;
+
+rtems_id   Semaphore;
+rtems_id   Task_id[ MAX_TASKS ];
+rtems_name Task_name[ MAX_TASKS ];
+
+rtems_task Locker_task(
+  rtems_task_argument unused
+)
+{
+  rtems_id          tid;
+  uint32_t          task_index;
+  rtems_status_code status;
+
+  status = rtems_task_ident( RTEMS_SELF, RTEMS_SEARCH_ALL_NODES, &tid );
+  directive_failed( status, "rtems_task_ident" );
+
+  task_index = task_number( tid ) - 1;
+
+  status = rtems_semaphore_obtain( Semaphore, RTEMS_DEFAULT_OPTIONS, 0 );
+  directive_failed( status, "rtems_semaphore_obtain" );
+
+  put_name( Task_name[ task_index ], FALSE );
+  puts( " - unblocked - OK" );
+
+  (void) rtems_task_delete( RTEMS_SELF );
+}
+
+void do_test(
+  rtems_attribute attr,
+  bool            extract  /* TRUE if extract, not release */
+)
+{
+  rtems_status_code status;
+  int               i;
+
+  status = rtems_semaphore_create(
+    rtems_build_name( 'S', 'E', 'M', '0' ),  /* name = SEM0 */
+    0,                                       /* unlocked */
+    RTEMS_BINARY_SEMAPHORE | attr,           /* mutex w/desired discipline */
+    0,                                       /* IGNORED */
+    &Semaphore
+  );
+  directive_failed( status, "rtems_semaphore_create" );
+
+  for (i=0 ; i< MAX_TASKS ; i++ ) {
+
+    Task_name[ i ] = rtems_build_name(
+       'T',
+       'A',
+       '0' + (char)(i/10),
+       '0' + (char)(i%10)
+    );
+
+    status = rtems_task_create(
+      Task_name[ i ],
+      Priorities[ i ],
+      RTEMS_MINIMUM_STACK_SIZE,
+      RTEMS_DEFAULT_MODES,
+      RTEMS_DEFAULT_ATTRIBUTES,
+      &Task_id[ i ]
+    );
+    directive_failed( status, "rtems_task_create" );
+
+    status = rtems_task_start(
+      Task_id[ i ], Locker_task, (rtems_task_argument)i );
+    directive_failed( status, "rtems_task_start" );
+
+    status = rtems_task_wake_after( 10 );
+    directive_failed( status, "rtems_task_wake_after" );
+  }
+
+  for (i=0 ; i< MAX_TASKS ; i++ ) {
+    if ( extract == FALSE ) {
+      status = rtems_semaphore_release( Semaphore );
+      directive_failed( status, "rtems_semaphore_release" );
+
+      status = rtems_task_wake_after( 100 );
+      directive_failed( status, "rtems_task_wake_after" );
+    } else {
+      status = rtems_task_delete( Task_id[ i ]  );
+      directive_failed( status, "rtems_task_delete" );
+    }
+  }
+
+  /* one extra release for the initial state */
+  status = rtems_semaphore_release( Semaphore );
+  directive_failed( status, "rtems_semaphore_release" );
+
+  /* now delete the semaphore since no one is waiting and it is unlocked */
+  status = rtems_semaphore_delete( Semaphore );
+  directive_failed( status, "rtems_semaphore_delete" );
+}
+
+rtems_task Init(
+  rtems_task_argument argument
+)
+{
+  puts( "\n\n*** START OF SCHEDULER TEST 2 ***" );
+
+  if (RTEMS_MAXIMUM_PRIORITY == 255)
+    Priorities = Priorities_High;
+  else if (RTEMS_MAXIMUM_PRIORITY == 15)
+    Priorities = Priorities_Low;
+  else {
+    puts( "Test only supports 256 or 16 configured priority levels" );
+    rtems_test_exit( 0 );
+  }
+
+  if ( sizeof(Priorities_Low) / sizeof(rtems_task_priority) != MAX_TASKS ) {
+    puts( "Priorities_Low table does not have right number of entries" );
+    rtems_test_exit( 0 );
+  }
+
+  if ( sizeof(Priorities_High) / sizeof(rtems_task_priority) != MAX_TASKS ) {
+    puts( "Priorities_High table does not have right number of entries" );
+    rtems_test_exit( 0 );
+  }
+
+  puts( "Exercising blocking discipline w/extract in FIFO order " );
+  do_test( RTEMS_FIFO, TRUE );
+
+  puts( "Exercising blocking discipline w/unblock in FIFO order" );
+  do_test( RTEMS_FIFO, FALSE );
+
+  rtems_test_pause_and_screen_number( 2 );
+
+  puts( "Exercising blocking discipline w/extract in priority order " );
+  do_test( RTEMS_PRIORITY, TRUE );
+
+  puts( "Exercising blocking discipline w/unblock in priority order" );
+  do_test( RTEMS_PRIORITY, FALSE );
+
+  puts( "*** END OF SCHEDULER TEST 2 ***" );
+  rtems_test_exit(0);
+}
+
+/**************** START OF CONFIGURATION INFORMATION ****************/
+
+#define CONFIGURE_INIT
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+
+#define CONFIGURE_MAXIMUM_TASKS             MAX_TASKS+1
+#define CONFIGURE_MAXIMUM_SEMAPHORES        1
+
+#define CONFIGURE_SCHEDULER_FIFO
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#include <rtems/confdefs.h>
+
+/****************  END OF CONFIGURATION INFORMATION  ****************/
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/Makefile.am rtems/testsuites/sptests/spsched02/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched02/Makefile.am	2010-07-12 18:13:21.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id: Makefile.am,v 1.3 2009/07/30 17:10:04 joel Exp $
+##
+
+MANAGERS = all
+
+rtems_tests_PROGRAMS = spsched02
+spsched02_SOURCES = init.c
+
+dist_rtems_tests_DATA = spsched02.scn
+dist_rtems_tests_DATA += spsched02.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+spsched02_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(spsched02_OBJECTS) $(spsched02_LDADD)
+LINK_LIBS = $(spsched02_LDLIBS)
+
+spsched02$(EXEEXT): $(spsched02_OBJECTS) $(spsched02_DEPENDENCIES)
+	@rm -f spsched02$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/spsched02.doc rtems/testsuites/sptests/spsched02/spsched02.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/spsched02.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched02/spsched02.doc	2010-07-12 18:12:02.000000000 -0400
@@ -0,0 +1,40 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-2009.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  spsched02
+
+This test is identical to sp42 but uses FIFO-based task scheduling.
+
+directives:
+
+  rtems_semaphore_create
+  rtems_semaphore_obtain
+  rtems_semaphore_release
+  rtems_semaphore_delete
+  rtems_task_create
+  rtems_task_delete
+  rtems_task_start
+  really exercising various Thread Queue capabilities:
+    _Thread_queue_Enqueue_FIFO
+    _Thread_queue_Enqueue_priority
+    _Thread_queue_Dequeue_FIFO
+    _Thread_queue_Dequeue_priority
+
+concepts:
+
++ This test is very carefully constructed to exercise the data structure
+  used to implement the priority blocking chains in the Thread Queue. The
+  task priorities used force forward and reverse searches and use of the
+  2-n chains
++ This test also ensures that the dequeues are performed in the correct
+  order.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/spsched02.scn rtems/testsuites/sptests/spsched02/spsched02.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched02/spsched02.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched02/spsched02.scn	2010-07-12 18:09:20.000000000 -0400
@@ -0,0 +1,47 @@
+*** START OF TEST 42 ***
+Exercising blocking discipline w/extract in FIFO order 
+Exercising blocking discipline w/unblock in FIFO order
+TA00 - unblocked - OK
+TA01 - unblocked - OK
+TA02 - unblocked - OK
+TA03 - unblocked - OK
+TA04 - unblocked - OK
+TA05 - unblocked - OK
+TA06 - unblocked - OK
+TA07 - unblocked - OK
+TA08 - unblocked - OK
+TA09 - unblocked - OK
+TA10 - unblocked - OK
+TA11 - unblocked - OK
+TA12 - unblocked - OK
+TA13 - unblocked - OK
+TA14 - unblocked - OK
+TA15 - unblocked - OK
+TA16 - unblocked - OK
+TA17 - unblocked - OK
+TA18 - unblocked - OK
+TA19 - unblocked - OK
+<pause - screen 2>
+Exercising blocking discipline w/extract in priority order 
+Exercising blocking discipline w/unblock in priority order
+TA04 - unblocked - OK
+TA05 - unblocked - OK
+TA06 - unblocked - OK
+TA07 - unblocked - OK
+TA09 - unblocked - OK
+TA10 - unblocked - OK
+TA11 - unblocked - OK
+TA12 - unblocked - OK
+TA13 - unblocked - OK
+TA08 - unblocked - OK
+TA16 - unblocked - OK
+TA17 - unblocked - OK
+TA18 - unblocked - OK
+TA19 - unblocked - OK
+TA00 - unblocked - OK
+TA01 - unblocked - OK
+TA02 - unblocked - OK
+TA03 - unblocked - OK
+TA15 - unblocked - OK
+TA14 - unblocked - OK
+*** END OF TEST 42 ***
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/init.c rtems/testsuites/sptests/spsched03/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/init.c	2010-07-29 19:17:25.000000000 -0400
@@ -0,0 +1,85 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is a user initialization task and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: init.c,v 1.11 2008/02/01 00:45:10 joel Exp $
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+
+rtems_task Init(
+  rtems_task_argument argument
+)
+{
+  rtems_time_of_day time;
+  rtems_status_code status;
+
+  puts( "\n\n*** SCHEDULER TEST 3 (EDF) ***" );
+
+  build_time( &time, 12, 31, 1988, 9, 0, 0, 0 );
+  status = rtems_clock_set( &time );
+  directive_failed( status, "rtems_clock_set" );
+
+  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
+  Task_name[ 3 ] = rtems_build_name( 'T', 'A', '3', ' ' );
+
+  status = rtems_task_create(
+     Task_name[ 1 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 2,
+     RTEMS_INTERRUPT_LEVEL(31),
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 1 ]
+  );
+  directive_failed( status, "rtems_task_create of TA1" );
+
+  status = rtems_task_create(
+     Task_name[ 2 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 2,
+     RTEMS_DEFAULT_MODES,
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 2 ]
+  );
+  directive_failed( status, "rtems_task_create of TA2" );
+
+  status = rtems_task_create(
+     Task_name[ 3 ],
+     1,
+     RTEMS_MINIMUM_STACK_SIZE * 3,
+     RTEMS_DEFAULT_MODES,
+     RTEMS_DEFAULT_ATTRIBUTES,
+     &Task_id[ 3 ]
+  );
+  directive_failed( status, "rtems_task_create of TA3" );
+
+  status = rtems_task_start( Task_id[ 1 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA1" );
+
+  status = rtems_task_start( Task_id[ 2 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA2" );
+
+  status = rtems_task_start( Task_id[ 3 ], Task_1_through_3, 0 );
+  directive_failed( status, "rtems_task_start of TA3" );
+
+  status = rtems_task_delete( RTEMS_SELF );
+  directive_failed( status, "rtems_task_delete of RTEMS_SELF" );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/Makefile.am rtems/testsuites/sptests/spsched03/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/Makefile.am	2010-07-29 15:12:15.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id: Makefile.am,v 1.23 2009/04/03 12:48:12 ralf Exp $
+##
+
+MANAGERS = io semaphore clock
+
+rtems_tests_PROGRAMS = spsched03
+spsched03_SOURCES = init.c task1.c system.h
+
+dist_rtems_tests_DATA = spsched03.scn
+dist_rtems_tests_DATA += spsched03.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+spsched03_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(spsched03_OBJECTS) $(spsched03_LDADD)
+LINK_LIBS = $(spsched03_LDLIBS)
+
+spsched03$(EXEEXT): $(spsched03_OBJECTS) $(spsched03_DEPENDENCIES)
+	@rm -f spsched03$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/spsched03.doc rtems/testsuites/sptests/spsched03/spsched03.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/spsched03.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/spsched03.doc	2010-07-29 15:11:49.000000000 -0400
@@ -0,0 +1,47 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-1999.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  sched03
+
+directives:
+  ex_init, ex_start, t_create, t_start, tm_tick, i_return, t_ident,
+  tm_set, tm_get, tm_wkafter
+
+concepts:
+
+This test is identical to sp01 but for EDF-based scheduling:
+
+  a.  Verifies system can create and start both the executive's system
+      initialization and idle task.
+
+  b.  Verifies executive can swap between three application tasks at the
+      same priority and the executive's internal idle task.
+
+  c.  Verifies can print strings to the CRT on port 2 of the mvme136 board
+      using Print and Println in the board support package.
+
+  d.  Verifies interrupt handler can handle a task switch from an interrupt
+      as specified with the i_return directive.
+
+  e.  Verifies executive initialization performed correctly.
+
+  f.  Verifies the executive trap handler except for the halt function.
+
+  g.  Verifies that a task can get the task identification number of itself.
+
+  h.  Verifies implementation of SuperCore TOD_MILLISECONDS_TO_TICKS.  Normal
+      computation in applications is via a macro at the Classic API level.
+
+output:
+ "TA1" is printed once every 5 seconds.  "TA2" is printed once
+ every 10 seconds.  "TA3" is printed once every 15 seconds.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/spsched03.scn rtems/testsuites/sptests/spsched03/spsched03.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/spsched03.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/spsched03.scn	2010-07-29 19:18:08.000000000 -0400
@@ -0,0 +1,16 @@
+*** SCHEDULER TEST 3 (EDF) ***
+TA1  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:00   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:05   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:10   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:10   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:15   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:15   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:20   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:20   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:25   12/31/1988
+TA3  - rtems_clock_get_tod - 09:00:30   12/31/1988
+TA1  - rtems_clock_get_tod - 09:00:30   12/31/1988
+TA2  - rtems_clock_get_tod - 09:00:30   12/31/1988
+*** END OF SCHEDULER TEST 3 (EDF) ***
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/system.h rtems/testsuites/sptests/spsched03/system.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/system.h	2010-07-29 15:13:31.000000000 -0400
@@ -0,0 +1,47 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: system.h,v 1.15 2004/04/01 15:16:29 ralf Exp $
+ */
+
+#include <tmacros.h>
+
+/* functions */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1_through_3(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+
+#define CONFIGURE_SCHEDULER_EDF
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#define CONFIGURE_EXTRA_TASK_STACKS         (4 * RTEMS_MINIMUM_STACK_SIZE)
+#define CONFIGURE_MAXIMUM_TASKS             4
+
+#include <rtems/confdefs.h>
+
+/* global variables */
+
+TEST_EXTERN rtems_id   Task_id[ 4 ];         /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 4 ];       /* array of task names */
+
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/task1.c rtems/testsuites/sptests/spsched03/task1.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched03/task1.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched03/task1.c	2010-07-29 19:17:36.000000000 -0400
@@ -0,0 +1,57 @@
+/*  Task_1_through_3
+ *
+ *  This routine serves as a test task.  It verifies the basic task
+ *  switching capabilities of the executive.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: task1.c,v 1.12 2009/11/30 03:33:23 ralf Exp $
+ */
+
+#include "system.h"
+
+rtems_task Task_1_through_3(
+  rtems_task_argument argument
+)
+{
+  rtems_id          tid;
+  rtems_time_of_day time;
+  rtems_status_code status;
+  rtems_interval    ticks;
+
+  status = rtems_task_ident( RTEMS_SELF, RTEMS_SEARCH_ALL_NODES, &tid );
+  directive_failed( status, "rtems_task_ident" );
+
+  /*
+   * Use TOD_MILLISECONDS_TO_TICKS not RTEMS_MILLISECONDS_TO_TICKS to
+   * test C implementation in SuperCore -- not macro version used
+   * everywhere else.
+   */
+  ticks = TOD_MILLISECONDS_TO_TICKS( task_number( tid ) * 5 * 1000 );
+
+  while( FOREVER ) {
+    status = rtems_clock_get_tod( &time );
+    directive_failed( status, "rtems_clock_get_tod" );
+
+    if ( time.second >= 35 ) {
+      puts( "*** END OF SCHEDULER TEST 3 (EDF) ***" );
+      rtems_test_exit( 0 );
+    }
+
+    put_name( Task_name[ task_number( tid ) ], FALSE );
+    print_time( " - rtems_clock_get_tod - ", &time, "\n" );
+
+    status = rtems_task_wake_after( ticks );
+    directive_failed( status, "rtems_task_wake_after" );
+  }
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/getall.c rtems/testsuites/sptests/spsched04/getall.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/getall.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/getall.c	2010-07-29 11:56:24.000000000 -0400
@@ -0,0 +1,43 @@
+/*  Get_all_counters
+ *
+ *  This routine allows TA5 to atomically obtain the iteration counters.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: getall.c,v 1.9 2003/09/04 18:53:48 joel Exp $
+ */
+
+#include "system.h"
+
+void Get_all_counters()
+{
+  rtems_mode        previous_mode;
+  rtems_status_code status;
+
+  status = rtems_task_mode(
+    RTEMS_NO_PREEMPT,
+    RTEMS_PREEMPT_MASK,
+    &previous_mode
+  );
+  directive_failed( status, "rtems_task_mode to RTEMS_NO_PREEMPT" );
+
+  Temporary_count = Count;
+  Count.count[ 1 ] = 0;
+  Count.count[ 2 ] = 0;
+  Count.count[ 3 ] = 0;
+  Count.count[ 4 ] = 0;
+  Count.count[ 5 ] = 0;
+  Count.count[ 6 ] = 0;
+
+  status = rtems_task_mode( RTEMS_PREEMPT, RTEMS_PREEMPT_MASK, &previous_mode );
+  directive_failed( status, "rtems_task_mode to RTEMS_PREEMPT" );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/init.c rtems/testsuites/sptests/spsched04/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/init.c	2010-07-29 15:10:46.000000000 -0400
@@ -0,0 +1,69 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is a user initialization task and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: init.c,v 1.14 2008/02/01 00:45:11 joel Exp $
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+
+rtems_task Init(
+  rtems_task_argument argument
+)
+{
+  uint32_t    index;
+  rtems_status_code status;
+
+  puts( "\n\n*** TEST Scheduler 4 (EDF) ***" );
+
+  Task_name[ 1 ] =  rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] =  rtems_build_name( 'T', 'A', '2', ' ' );
+  Task_name[ 3 ] =  rtems_build_name( 'T', 'A', '3', ' ' );
+  Task_name[ 4 ] =  rtems_build_name( 'T', 'A', '4', ' ' );
+  Task_name[ 5 ] =  rtems_build_name( 'T', 'A', '5', ' ' );
+  Task_name[ 6 ] =  rtems_build_name( 'T', 'A', '6', ' ' );
+
+  for ( index = 1 ; index <= 6 ; index++ ) {
+    status = rtems_task_create(
+      Task_name[ index ],
+      Priorities[ index ],
+      RTEMS_MINIMUM_STACK_SIZE * 4,
+      RTEMS_DEFAULT_MODES,
+      RTEMS_DEFAULT_ATTRIBUTES,
+      &Task_id[ index ]
+    );
+    directive_failed( status, "rtems_task_create loop" );
+  }
+
+  for ( index = 1 ; index <= 6 ; index++ ) {
+    status = rtems_task_start( Task_id[ index ], Task_1_through_6, index );
+    directive_failed( status, "rtems_task_start loop" );
+  }
+
+  Count.count[ 1 ] = 0;
+  Count.count[ 2 ] = 0;
+  Count.count[ 3 ] = 0;
+  Count.count[ 4 ] = 0;
+  Count.count[ 5 ] = 0;
+  Count.count[ 6 ] = 0;
+
+  status = rtems_task_delete( RTEMS_SELF );
+  directive_failed( status, "rtems_task_delete of RTEMS_SELF" );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/Makefile.am rtems/testsuites/sptests/spsched04/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/Makefile.am	2010-07-29 15:10:15.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id: Makefile.am,v 1.23 2009/04/03 12:48:12 ralf Exp $
+##
+
+MANAGERS = io rate_monotonic semaphore clock
+
+rtems_tests_PROGRAMS = spsched04
+spsched04_SOURCES = init.c getall.c task1.c system.h
+
+dist_rtems_tests_DATA = spsched04.scn
+dist_rtems_tests_DATA += spsched04.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+spsched04_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(spsched04_OBJECTS) $(spsched04_LDADD)
+LINK_LIBS = $(spsched04_LDLIBS)
+
+spsched04$(EXEEXT): $(spsched04_OBJECTS) $(spsched04_DEPENDENCIES)
+	@rm -f spsched04$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/spsched04.doc rtems/testsuites/sptests/spsched04/spsched04.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/spsched04.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/spsched04.doc	2010-07-29 11:57:40.000000000 -0400
@@ -0,0 +1,22 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-2010.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  spsched03
+
+directives:
+
+
+concepts:
+
+  a.  Verifies EDF Scheduling behavior.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/spsched04.scn rtems/testsuites/sptests/spsched04/spsched04.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/spsched04.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/spsched04.scn	2010-07-29 19:15:02.000000000 -0400
@@ -0,0 +1,43 @@
+*** TEST Scheduler 4 (EDF) ***
+TA1 - rtems_periodic_create id = 0x42010001
+TA1 - rtems_periodic_ident id = 0x42010001
+TA1 - (0x42010001) period 2
+TA2 - rtems_periodic_create id = 0x42010002
+TA2 - rtems_periodic_ident id = 0x42010002
+TA2 - (0x42010002) period 2
+TA3 - rtems_periodic_create id = 0x42010003
+TA3 - rtems_periodic_ident id = 0x42010003
+TA3 - (0x42010003) period 2
+TA4 - rtems_periodic_create id = 0x42010004
+TA4 - rtems_periodic_ident id = 0x42010004
+TA4 - (0x42010004) period 2
+TA5 - rtems_periodic_create id = 0x42010005
+TA5 - rtems_periodic_ident id = 0x42010005
+TA5 - (0x42010005) period 100
+TA6 - rtems_periodic_create id = 0x42010006
+TA6 - rtems_periodic_ident id = 0x42010006
+TA6 - (0x42010006) period 0
+FAIL -- TA2  Actual=51, Expected=50
+FAIL -- TA3  Actual=51, Expected=50
+FAIL -- TA4  Actual=51, Expected=50
+TA5 - PERIODS CHECK OK (1)
+TA5 - PERIODS CHECK OK (2)
+TA5 - PERIODS CHECK OK (3)
+TA5 - PERIODS CHECK OK (4)
+TA5 - PERIODS CHECK OK (5)
+TA6 - Actual: 10 Expected: 10 - OK
+TA6 - Actual: 20 Expected: 20 - OK
+TA6 - Actual: 30 Expected: 30 - OK
+TA6 - Actual: 40 Expected: 40 - OK
+TA6 - Actual: 50 Expected: 50 - OK
+TA6 - Actual: 60 Expected: 60 - OK
+TA6 - Actual: 70 Expected: 70 - OK
+TA6 - Actual: 80 Expected: 80 - OK
+TA6 - Actual: 90 Expected: 90 - OK
+TA6 - Actual: 100 Expected: 100 - OK
+TA5 - PERIODS CHECK OK (6)
+TA5 - PERIODS CHECK OK (7)
+TA5 - PERIODS CHECK OK (8)
+TA5 - PERIODS CHECK OK (9)
+TA5 - PERIODS CHECK OK (10)
+*** END OF TEST SCHEDULER 4 (EDF) ***
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/system.h rtems/testsuites/sptests/spsched04/system.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/system.h	2010-07-29 18:43:08.000000000 -0400
@@ -0,0 +1,65 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: system.h,v 1.22 2009/10/05 15:01:59 joel Exp $
+ */
+
+#include <tmacros.h>
+
+/* types */
+
+struct counters {
+  uint32_t   count[7];
+};
+
+/* functions */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1_through_6(
+  rtems_task_argument argument
+);
+
+void Get_all_counters( void );
+
+/* configuration information */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+
+#define CONFIGURE_MICROSECONDS_PER_TICK 100000
+
+#define CONFIGURE_MAXIMUM_TASKS               7
+#define CONFIGURE_MAXIMUM_PERIODS             10
+
+#define CONFIGURE_INIT_TASK_PRIORITY          10
+#define CONFIGURE_INIT_TASK_INITIAL_MODES     RTEMS_DEFAULT_MODES
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#define CONFIGURE_EXTRA_TASK_STACKS         (6 * 4 * RTEMS_MINIMUM_STACK_SIZE)
+
+#define CONFIGURE_SCHEDULER_EDF
+
+#include <rtems/confdefs.h>
+
+/* global variables */
+
+TEST_EXTERN rtems_id   Task_id[ 7 ];     /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 7 ];   /* array of task names */
+
+TEST_EXTERN struct counters Count;       /* iteration counters */
+TEST_EXTERN struct counters Temporary_count;
+extern rtems_task_priority Priorities[ 7 ];
+
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/task1.c rtems/testsuites/sptests/spsched04/task1.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched04/task1.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched04/task1.c	2010-07-29 15:10:53.000000000 -0400
@@ -0,0 +1,153 @@
+/*  Task_1_through_6
+ *
+ *  This routine serves as a test task for the EDF scheduling 
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: task1.c,v 1.16 2009/10/26 17:04:39 ralf Exp $
+ */
+
+#include "system.h"
+
+/*
+ runtime of TA6 should be shorter than TA5
+ */
+#define TA6_ITERATIONS 10
+#define TA6_PERIOD_FACTOR 10
+
+uint32_t      Periods[7]    = { 0,   2,   2,   2,   2, 100, 0 };
+uint32_t      Iterations[7] = { 0,  50,  50,  50,  50,   1, TA6_ITERATIONS };
+rtems_task_priority Priorities[7] = { 0,   1,   1,   3,   4,   5, 1 };
+
+rtems_task Task_1_through_6(
+  rtems_task_argument argument
+)
+{
+  rtems_id          rmid;
+  rtems_id          test_rmid;
+  int               index;
+  int               pass;
+  uint32_t          failed;
+  rtems_status_code status;
+
+  status = rtems_periodic_create( argument, &rmid );
+  directive_failed( status, "rtems_periodic_create" );
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- rtems_periodic_create id = 0x%08" PRIxrtems_id "\n", rmid );
+
+  status = rtems_periodic_ident( argument, &test_rmid );
+  directive_failed( status, "rtems_periodic_ident" );
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- rtems_periodic_ident id = 0x%08" PRIxrtems_id "\n", test_rmid );
+
+  if ( rmid != test_rmid ) {
+     printf( "RMID's DO NOT MATCH (0x%" PRIxrtems_id " and 0x%" PRIxrtems_id ")\n", rmid, test_rmid );
+     rtems_test_exit( 0 );
+  }
+
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- (0x%08" PRIxrtems_id ") period %" PRIu32 "\n", rmid, Periods[ argument ] );
+
+  status = rtems_task_wake_after( 2 );
+  directive_failed( status, "rtems_task_wake_after" );
+
+  switch ( argument ) {
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+      while ( FOREVER ) {
+        status = rtems_periodic_period( rmid, Periods[ argument ] );
+        directive_failed( status, "rtems_periodic_period" );
+
+        Count.count[ argument ]++;
+      }
+      break;
+    case 5:
+      pass   = 0;
+      failed = 0;
+
+      status = rtems_periodic_period( rmid, Periods[ argument ] );
+      directive_failed( status, "rtems_periodic_period 1 of TA5" );
+
+      Get_all_counters();
+
+      while ( FOREVER ) {
+
+        status = rtems_periodic_period( rmid, Periods[ argument ] );
+        directive_failed( status, "rtems_periodic_period 2 of TA5" );
+
+        Get_all_counters();
+
+        for( index = 1 ; index <= 4 ; index++ ) {
+          if ( Temporary_count.count[ index ] != Iterations[ index ] ) {
+            puts_nocr( "FAIL -- " );
+            put_name ( Task_name[ index ], FALSE );
+            printf   ( " Actual=%" PRIu32 ", Expected=%" PRIu32 "\n",
+                       Temporary_count.count[ index ],
+                       Iterations[ index ]
+                     );
+            failed += 1;
+          }
+        }
+
+        if ( failed == 5 )
+          rtems_test_exit( 0 );
+
+        pass += 1;
+
+        printf( "TA5 - PERIODS CHECK OK (%d)\n", pass );
+
+        fflush( stdout );
+
+        if ( pass == 10 ) {
+          puts( "*** END OF TEST SCHEDULER 4 (EDF) ***" );
+          rtems_test_exit( 0 );
+        }
+
+      }
+      break;
+    case 6:
+      /* test changing periods */
+      {
+        uint32_t   time[TA6_ITERATIONS+1];
+        rtems_interval period;
+
+        period = 1*TA6_PERIOD_FACTOR;
+        status = rtems_periodic_period( rmid, period);
+        directive_failed( status, "rtems_periodic_period of TA6" );
+        time[0] = _Watchdog_Ticks_since_boot; /* timestamp */
+        /*printf("%d - %d\n", period, time[0]);*/
+
+        for (index = 1; index <= TA6_ITERATIONS; index++)
+        {
+          period = (index+1)*TA6_PERIOD_FACTOR;
+          status = rtems_periodic_period( rmid,  period);
+          directive_failed( status, "rtems_periodic_period of TA6" );
+          time[index] = _Watchdog_Ticks_since_boot; /* timestamp */
+          /*printf("%d - %d\n", period, time[index]);*/
+        }
+
+        for (index = 1; index <= TA6_ITERATIONS; index++)
+        {
+          rtems_interval meas = time[index] - time[index-1];
+          period = index*TA6_PERIOD_FACTOR;
+          printf("TA6 - Actual: %" PRIdrtems_interval " Expected: %" PRIdrtems_interval, meas, period);
+          if (period == meas) printf(" - OK\n");
+          else printf(" - FAILED\n");
+        }
+      }
+      rtems_task_suspend(RTEMS_SELF);
+      break;
+  }
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfmacros.h rtems/testsuites/sptests/spsched05/edfmacros.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfmacros.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/edfmacros.h	2010-07-29 18:43:51.000000000 -0400
@@ -0,0 +1,19 @@
+/* edfmacros.h
+ *
+ * This is a generated file.
+ * Use the gen-headers.lua script to create this file.
+ */
+
+/* This file was generated with the following parameters: 
+-T 3,1,0 -T 4,1,0 -T 5,1,0 -T 7,1,0 -A 1,100,7 -A 100,5,4
+*/
+
+#ifndef __EDFMACROS_H_
+#define __EDFMACROS_H_
+
+#define  JOBS_PER_HP                (389)
+#define  HP_LENGTH                  (420)
+#define  NUM_PERIODIC_TASKS         (4)
+#define  NUM_APERIODIC_TASKS        (2)
+#define  NUM_TASKS                  ( NUM_PERIODIC_TASKS + NUM_APERIODIC_TASKS )
+#endif
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfparams.h rtems/testsuites/sptests/spsched05/edfparams.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfparams.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/edfparams.h	2010-07-29 18:43:51.000000000 -0400
@@ -0,0 +1,66 @@
+/* edfparams.h
+ *
+ * This is a generated file.
+ * Use the gen-headers.lua script to create this file.
+ */
+
+/* This file was generated with the following parameters: 
+-T 3,1,0 -T 4,1,0 -T 5,1,0 -T 7,1,0 -A 1,100,7 -A 100,5,4
+*/
+
+#ifndef __EDFPARAMS_H_
+#define __EDFPARAMS_H_
+
+#define  JOBS_PER_HP                (389)
+#define  HP_LENGTH                  (420)
+#define  NUM_PERIODIC_TASKS         (4)
+#define  NUM_APERIODIC_TASKS        (2)
+#define  NUM_TASKS                  ( NUM_PERIODIC_TASKS + NUM_APERIODIC_TASKS )
+
+uint32_t  jobs_per_hyperperiod      = JOBS_PER_HP;
+uint32_t  periodic_tasks            = NUM_PERIODIC_TASKS;
+
+rtems_task_priority Priorities[1+NUM_TASKS]= { 0, 3, 4, 5, 7, 254, 254 };
+
+uint32_t  Periods[1+NUM_PERIODIC_TASKS]    = { 0, 3, 4, 5, 7 };
+uint32_t  Periods_us[1+NUM_PERIODIC_TASKS] = {
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             3*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             4*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             5*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             7*CONFIGURE_MICROSECONDS_PER_TICK
+                                             };
+
+uint32_t  Tick_Count[1+NUM_TASKS]           = { 0, 1, 1, 1, 1, 100, 5 };
+uint32_t  Execution[1+NUM_TASKS]           = { 0, 1, 1, 1, 1, 100, 5 };
+uint32_t  Execution_us[1+NUM_TASKS]        = {
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             1*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             1*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             1*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             1*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             100*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             5*CONFIGURE_MICROSECONDS_PER_TICK
+                                             };
+
+uint32_t  Phases[1+NUM_TASKS]           = { 0, 0, 0, 0, 0, 7, 4 };
+uint32_t  Phases_us[1+NUM_TASKS]        = {
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             0*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             7*CONFIGURE_MICROSECONDS_PER_TICK,
+                                             4*CONFIGURE_MICROSECONDS_PER_TICK
+                                             };
+
+#define build_task_name() do { \
+Task_name[ 1 ] =  rtems_build_name( 'P', 'T', '1', ' ' );\
+Task_name[ 2 ] =  rtems_build_name( 'P', 'T', '2', ' ' );\
+Task_name[ 3 ] =  rtems_build_name( 'P', 'T', '3', ' ' );\
+Task_name[ 4 ] =  rtems_build_name( 'P', 'T', '4', ' ' );\
+Task_name[ 5 ] =  rtems_build_name( 'A', 'T', '5', ' ' );\
+Task_name[ 6 ] =  rtems_build_name( 'A', 'T', '6', ' ' );\
+} while(0)
+
+#endif
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfsupport.c rtems/testsuites/sptests/spsched05/edfsupport.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/edfsupport.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/edfsupport.c	2010-07-29 18:43:51.000000000 -0400
@@ -0,0 +1,24 @@
+/*
+ * edfsupport.c
+ *
+ * see system.h for license
+ */
+
+#include "system.h"
+
+#define MS_PER_S (1000)
+#define US_PER_MS (1000)
+#define NS_PER_US (1000)
+
+#define US_PER_S (MS_PER_S * US_PER_MS)
+#define NS_PER_S (US_PER_MS * NS_PER_US)
+
+void set_timespec_from_us( struct timespec *ts, uint32_t time_us )
+{
+  uint32_t time_ns = time_us * NS_PER_US;
+  uint32_t time_s = time_us / US_PER_S;
+  time_ns = time_ns - time_s * NS_PER_S;
+
+  _Timespec_Set( ts, time_s, time_ns );
+}
+
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/init.c rtems/testsuites/sptests/spsched05/init.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/init.c	2010-07-29 18:44:59.000000000 -0400
@@ -0,0 +1,61 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is a user initialization task and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+
+#include "edfparams.h"
+
+rtems_task Init(
+  rtems_task_argument argument
+)
+{
+  uint32_t    index;
+  rtems_status_code status;
+
+  puts( "\n\n*** TEST SCHEDULER 5 (EDF) ***" );
+
+  build_task_name();
+
+  for ( index = 1 ; index <= NUM_TASKS ; index++ ) {
+    status = rtems_task_create(
+      Task_name[ index ],
+      Priorities[ index ],
+      RTEMS_MINIMUM_STACK_SIZE * 4,
+      RTEMS_DEFAULT_MODES,
+      RTEMS_DEFAULT_ATTRIBUTES,
+      &Task_id[ index ]
+    );
+    directive_failed( status, "rtems_task_create loop" );
+  }
+
+  for ( index = 1 ; index <= NUM_PERIODIC_TASKS ; index++ ) {
+    status = rtems_task_start( Task_id[ index ], Tasks_Periodic, index );
+    directive_failed( status, "rtems_task_start loop" );
+  }
+
+  for ( index = NUM_PERIODIC_TASKS+1 ; index <= NUM_TASKS ; index++ ) {
+    status = rtems_task_start( Task_id[ index ], Tasks_Aperiodic, index );
+    directive_failed( status, "rtems_task_start loop" );
+  }
+
+  status = rtems_task_delete( RTEMS_SELF );
+  directive_failed( status, "rtems_task_delete of RTEMS_SELF" );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/Makefile.am rtems/testsuites/sptests/spsched05/Makefile.am
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/Makefile.am	2010-07-29 18:44:23.000000000 -0400
@@ -0,0 +1,28 @@
+##
+## $Id: Makefile.am,v 1.23 2009/04/03 12:48:12 ralf Exp $
+##
+
+MANAGERS = io rate_monotonic semaphore clock
+
+rtems_tests_PROGRAMS = spsched05
+spsched05_SOURCES = init.c tasks_periodic.c tasks_aperiodic.c edfsupport.c system.h edfparams.h edfmacros.h
+
+dist_rtems_tests_DATA = spsched05.scn
+dist_rtems_tests_DATA += spsched05.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+spsched05_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(spsched05_OBJECTS) $(spsched05_LDADD)
+LINK_LIBS = $(spsched05_LDLIBS)
+
+spsched05$(EXEEXT): $(spsched05_OBJECTS) $(spsched05_DEPENDENCIES)
+	@rm -f spsched05$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/spsched05.doc rtems/testsuites/sptests/spsched05/spsched05.doc
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/spsched05.doc	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/spsched05.doc	2010-07-29 18:42:24.000000000 -0400
@@ -0,0 +1,22 @@
+#
+#  $Id$
+#
+#  COPYRIGHT (c) 1989-1999.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.com/license/LICENSE.
+#
+
+
+This file describes the directives and concepts tested by this test set.
+
+test set name:  spsched05
+
+directives:
+
+
+concepts:
+
+  a.  Verifies EDF Scheduling behavior.
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/spsched05.scn rtems/testsuites/sptests/spsched05/spsched05.scn
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/spsched05.scn	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/spsched05.scn	2010-07-29 19:10:49.000000000 -0400
@@ -0,0 +1,1573 @@
+*** TEST SCHEDULER 5 (EDF) ***
+PT1 - rtems_periodic_create id = 0x42010001
+PT1 - rtems_periodic_ident id = 0x42010001
+PT1 - (0x42010001) period 3
+PT2 - rtems_periodic_create id = 0x42010002
+PT2 - rtems_periodic_ident id = 0x42010002
+PT2 - (0x42010002) period 4
+PT3 - rtems_periodic_create id = 0x42010003
+PT3 - rtems_periodic_ident id = 0x42010003
+PT3 - (0x42010003) period 5
+PT4 - rtems_periodic_create id = 0x42010004
+PT4 - rtems_periodic_ident id = 0x42010004
+PT4 - (0x42010004) period 7
+AT5 AT6 P1-S ticks:2
+P1-F ticks:2
+P4-S ticks:2
+P4-F ticks:3
+P3-S ticks:3
+P3-F ticks:4
+P2-S ticks:4
+P2-F ticks:5
+P1-S ticks:5
+P1-F ticks:5
+AT6-S ticks:6
+P1-S ticks:8
+P1-F ticks:8
+P2-S ticks:8
+P2-F ticks:9
+P3-S ticks:9
+P3-F ticks:10
+P4-S ticks:10
+P1-S ticks:11
+P1-F ticks:11
+P4-F ticks:11
+P2-S ticks:12
+P2-F ticks:12
+P3-S ticks:13
+P3-F ticks:13
+P1-S ticks:14
+P1-F ticks:14
+P2-S ticks:16
+P2-F ticks:16
+P4-S ticks:16
+P1-S ticks:17
+P1-F ticks:17
+P4-F ticks:18
+P3-S ticks:18
+P3-F ticks:19
+P6-F ticks:19
+Killing task 6AT5-S ticks:19
+P1-S ticks:20
+P1-F ticks:20
+P2-S ticks:20
+P2-F ticks:21
+P1-S ticks:23
+P1-F ticks:23
+P3-S ticks:23
+P3-F ticks:24
+P2-S ticks:24
+P2-F ticks:25
+P4-S ticks:25
+P1-S ticks:26
+P1-F ticks:26
+P4-F ticks:26
+P2-S ticks:28
+P2-F ticks:28
+P3-S ticks:28
+P1-S ticks:29
+P1-F ticks:29
+P3-F ticks:30
+P4-S ticks:30
+P4-F ticks:31
+P1-S ticks:32
+P1-F ticks:32
+P2-S ticks:32
+P2-F ticks:33
+P3-S ticks:33
+P3-F ticks:34
+P1-S ticks:35
+P1-F ticks:35
+P2-S ticks:36
+P2-F ticks:36
+P4-S ticks:37
+P4-F ticks:37
+P1-S ticks:38
+P1-F ticks:38
+P3-S ticks:38
+P3-F ticks:39
+P2-S ticks:40
+P2-F ticks:40
+P1-S ticks:41
+P1-F ticks:41
+P3-S ticks:43
+P3-F ticks:43
+P1-S ticks:44
+P1-F ticks:44
+P2-S ticks:44
+P2-F ticks:45
+P4-S ticks:45
+P4-F ticks:46
+P1-S ticks:47
+P1-F ticks:47
+P2-S ticks:48
+P2-F ticks:48
+P3-S ticks:48
+P3-F ticks:49
+P1-S ticks:50
+P1-F ticks:50
+P4-S ticks:51
+P4-F ticks:51
+P2-S ticks:52
+P2-F ticks:52
+P1-S ticks:53
+P1-F ticks:53
+P3-S ticks:53
+P3-F ticks:54
+P1-S ticks:56
+P1-F ticks:56
+P2-S ticks:56
+P2-F ticks:57
+P3-S ticks:58
+P3-F ticks:58
+P4-S ticks:58
+P1-S ticks:59
+P1-F ticks:59
+P2-S ticks:60
+P2-F ticks:60
+P4-F ticks:61
+P1-S ticks:62
+P1-F ticks:62
+P3-S ticks:63
+P3-F ticks:63
+P2-S ticks:64
+P2-F ticks:64
+P1-S ticks:65
+P1-F ticks:65
+P4-S ticks:65
+P4-F ticks:66
+P1-S ticks:68
+P1-F ticks:68
+P2-S ticks:68
+P2-F ticks:69
+P3-S ticks:69
+P3-F ticks:70
+P1-S ticks:71
+P1-F ticks:71
+P2-S ticks:72
+P2-F ticks:72
+P4-S ticks:72
+P3-S ticks:73
+P3-F ticks:73
+P1-S ticks:74
+P1-F ticks:74
+P4-F ticks:75
+P2-S ticks:76
+P2-F ticks:76
+P1-S ticks:77
+P1-F ticks:77
+P3-S ticks:78
+P3-F ticks:78
+P4-S ticks:79
+P4-F ticks:79
+P1-S ticks:80
+P1-F ticks:80
+P2-S ticks:80
+P2-F ticks:81
+P1-S ticks:83
+P1-F ticks:83
+P3-S ticks:83
+P3-F ticks:84
+P2-S ticks:84
+P2-F ticks:85
+P1-S ticks:86
+P1-F ticks:86
+P4-S ticks:86
+P4-F ticks:87
+P2-S ticks:88
+P2-F ticks:88
+P3-S ticks:88
+P1-S ticks:89
+P1-F ticks:89
+P3-F ticks:90
+P1-S ticks:92
+P1-F ticks:92
+P2-S ticks:92
+P2-F ticks:93
+P3-S ticks:93
+P3-F ticks:94
+P4-S ticks:94
+P1-S ticks:95
+P1-F ticks:95
+P4-F ticks:95
+P2-S ticks:96
+P2-F ticks:96
+P1-S ticks:98
+P1-F ticks:98
+P3-S ticks:98
+P3-F ticks:99
+P2-S ticks:100
+P2-F ticks:100
+P4-S ticks:100
+P1-S ticks:101
+P1-F ticks:101
+P4-F ticks:102
+P3-S ticks:103
+P3-F ticks:103
+P1-S ticks:104
+P1-F ticks:104
+P2-S ticks:104
+P2-F ticks:105
+P1-S ticks:107
+P1-F ticks:107
+P4-S ticks:107
+P2-S ticks:108
+P2-F ticks:108
+P3-S ticks:108
+P3-F ticks:109
+P1-S ticks:110
+P1-F ticks:110
+P4-F ticks:110
+P2-S ticks:112
+P2-F ticks:112
+P1-S ticks:113
+P1-F ticks:113
+P3-S ticks:113
+P3-F ticks:114
+P4-S ticks:114
+P4-F ticks:115
+P1-S ticks:116
+P1-F ticks:116
+P2-S ticks:116
+P2-F ticks:117
+P3-S ticks:118
+P3-F ticks:118
+P1-S ticks:119
+P1-F ticks:119
+P2-S ticks:120
+P2-F ticks:120
+P4-S ticks:121
+P4-F ticks:121
+P1-S ticks:122
+P1-F ticks:122
+P3-S ticks:123
+P3-F ticks:123
+P2-S ticks:124
+P2-F ticks:124
+P1-S ticks:125
+P1-F ticks:125
+P1-S ticks:128
+P1-F ticks:128
+P2-S ticks:128
+P2-F ticks:129
+P3-S ticks:129
+P3-F ticks:130
+P4-S ticks:130
+P1-S ticks:131
+P1-F ticks:131
+P4-F ticks:131
+P2-S ticks:132
+P2-F ticks:132
+P3-S ticks:133
+P3-F ticks:133
+P1-S ticks:134
+P1-F ticks:134
+P4-S ticks:135
+P4-F ticks:135
+P2-S ticks:136
+P2-F ticks:136
+P1-S ticks:137
+P1-F ticks:137
+P3-S ticks:138
+P3-F ticks:138
+P1-S ticks:140
+P1-F ticks:140
+P2-S ticks:140
+P2-F ticks:141
+P4-S ticks:142
+P4-F ticks:142
+P1-S ticks:143
+P1-F ticks:143
+P3-S ticks:143
+P3-F ticks:144
+P2-S ticks:144
+P2-F ticks:145
+P1-S ticks:146
+P1-F ticks:146
+P2-S ticks:148
+P2-F ticks:148
+P3-S ticks:148
+P1-S ticks:149
+P1-F ticks:149
+P3-F ticks:150
+P4-S ticks:150
+P4-F ticks:151
+P1-S ticks:152
+P1-F ticks:152
+P2-S ticks:152
+P2-F ticks:153
+P3-S ticks:153
+P3-F ticks:154
+P1-S ticks:155
+P1-F ticks:155
+P2-S ticks:156
+P2-F ticks:156
+P4-S ticks:156
+P4-F ticks:157
+P1-S ticks:158
+P1-F ticks:158
+P3-S ticks:158
+P3-F ticks:159
+P2-S ticks:160
+P2-F ticks:160
+P1-S ticks:161
+P1-F ticks:161
+P3-S ticks:163
+P3-F ticks:163
+P4-S ticks:163
+P1-S ticks:164
+P1-F ticks:164
+P2-S ticks:164
+P2-F ticks:165
+P4-F ticks:166
+P1-S ticks:167
+P1-F ticks:167
+P2-S ticks:168
+P2-F ticks:168
+P3-S ticks:168
+P3-F ticks:169
+P1-S ticks:170
+P1-F ticks:170
+P4-S ticks:170
+P4-F ticks:171
+P2-S ticks:172
+P2-F ticks:172
+P1-S ticks:173
+P1-F ticks:173
+P3-S ticks:173
+P3-F ticks:174
+P1-S ticks:176
+P1-F ticks:176
+P2-S ticks:176
+P2-F ticks:177
+P4-S ticks:177
+P3-S ticks:178
+P3-F ticks:178
+P1-S ticks:179
+P1-F ticks:179
+P4-F ticks:179
+P2-S ticks:180
+P2-F ticks:180
+P1-S ticks:182
+P1-F ticks:182
+P3-S ticks:183
+P3-F ticks:183
+P2-S ticks:184
+P2-F ticks:184
+P4-S ticks:184
+P1-S ticks:185
+P1-F ticks:185
+P4-F ticks:186
+P1-S ticks:188
+P1-F ticks:188
+P2-S ticks:188
+P2-F ticks:189
+P3-S ticks:189
+P3-F ticks:190
+P1-S ticks:191
+P1-F ticks:191
+P4-S ticks:191
+P2-S ticks:192
+P2-F ticks:192
+P4-F ticks:193
+P3-S ticks:193
+P1-S ticks:194
+P1-F ticks:194
+P3-F ticks:194
+P2-S ticks:196
+P2-F ticks:196
+P1-S ticks:197
+P1-F ticks:197
+P3-S ticks:198
+P3-F ticks:198
+P4-S ticks:198
+P4-F ticks:199
+P1-S ticks:200
+P1-F ticks:200
+P2-S ticks:200
+P2-F ticks:201
+P1-S ticks:203
+P1-F ticks:203
+P3-S ticks:203
+P3-F ticks:204
+P2-S ticks:204
+P2-F ticks:205
+P4-S ticks:205
+P1-S ticks:206
+P1-F ticks:206
+P4-F ticks:206
+P2-S ticks:208
+P2-F ticks:208
+P3-S ticks:208
+P1-S ticks:209
+P1-F ticks:209
+P3-F ticks:210
+P1-S ticks:212
+P1-F ticks:212
+P2-S ticks:212
+P2-F ticks:213
+P3-S ticks:213
+P3-F ticks:214
+P4-S ticks:214
+P1-S ticks:215
+P1-F ticks:215
+P4-F ticks:215
+P2-S ticks:216
+P2-F ticks:216
+P1-S ticks:218
+P1-F ticks:218
+P3-S ticks:218
+P3-F ticks:219
+P4-S ticks:219
+P2-S ticks:220
+P2-F ticks:220
+P1-S ticks:221
+P1-F ticks:221
+P4-F ticks:221
+P3-S ticks:223
+P3-F ticks:223
+P1-S ticks:224
+P1-F ticks:224
+P2-S ticks:224
+P2-F ticks:225
+P4-S ticks:226
+P4-F ticks:226
+P1-S ticks:227
+P1-F ticks:227
+P2-S ticks:228
+P2-F ticks:228
+P3-S ticks:228
+P3-F ticks:229
+P1-S ticks:230
+P1-F ticks:230
+P2-S ticks:232
+P2-F ticks:232
+P1-S ticks:233
+P1-F ticks:233
+P3-S ticks:233
+P3-F ticks:234
+P4-S ticks:234
+P4-F ticks:235
+P1-S ticks:236
+P1-F ticks:236
+P2-S ticks:236
+P2-F ticks:237
+P3-S ticks:238
+P3-F ticks:238
+P1-S ticks:239
+P1-F ticks:239
+P2-S ticks:240
+P2-F ticks:240
+P4-S ticks:240
+P4-F ticks:241
+P1-S ticks:242
+P1-F ticks:242
+P3-S ticks:243
+P3-F ticks:243
+P2-S ticks:244
+P2-F ticks:244
+P1-S ticks:245
+P1-F ticks:245
+P4-S ticks:247
+P4-F ticks:247
+P1-S ticks:248
+P1-F ticks:248
+P2-S ticks:248
+P2-F ticks:249
+P3-S ticks:249
+P3-F ticks:250
+P1-S ticks:251
+P1-F ticks:251
+P2-S ticks:252
+P2-F ticks:252
+P3-S ticks:253
+P3-F ticks:253
+P1-S ticks:254
+P1-F ticks:254
+P4-S ticks:254
+P4-F ticks:255
+P2-S ticks:256
+P2-F ticks:256
+P1-S ticks:257
+P1-F ticks:257
+P3-S ticks:258
+P3-F ticks:258
+P1-S ticks:260
+P1-F ticks:260
+P2-S ticks:260
+P2-F ticks:261
+P4-S ticks:261
+P4-F ticks:262
+P1-S ticks:263
+P1-F ticks:263
+P3-S ticks:263
+P3-F ticks:264
+P2-S ticks:264
+P2-F ticks:265
+P1-S ticks:266
+P1-F ticks:266
+P2-S ticks:268
+P2-F ticks:268
+P3-S ticks:268
+P1-S ticks:269
+P1-F ticks:269
+P3-F ticks:270
+P4-S ticks:270
+P4-F ticks:271
+P1-S ticks:272
+P1-F ticks:272
+P2-S ticks:272
+P2-F ticks:273
+P3-S ticks:273
+P3-F ticks:274
+P1-S ticks:275
+P1-F ticks:275
+P4-S ticks:275
+P2-S ticks:276
+P2-F ticks:276
+P4-F ticks:277
+P1-S ticks:278
+P1-F ticks:278
+P3-S ticks:278
+P3-F ticks:279
+P2-S ticks:280
+P2-F ticks:280
+P1-S ticks:281
+P1-F ticks:281
+P4-S ticks:282
+P4-F ticks:282
+P3-S ticks:283
+P3-F ticks:283
+P1-S ticks:284
+P1-F ticks:284
+P2-S ticks:284
+P2-F ticks:285
+P1-S ticks:287
+P1-F ticks:287
+P2-S ticks:288
+P2-F ticks:288
+P3-S ticks:288
+P3-F ticks:289
+P4-S ticks:289
+P1-S ticks:290
+P1-F ticks:290
+P4-F ticks:291
+P2-S ticks:292
+P2-F ticks:292
+P1-S ticks:293
+P1-F ticks:293
+P3-S ticks:293
+P3-F ticks:294
+P1-S ticks:296
+P1-F ticks:296
+P2-S ticks:296
+P2-F ticks:297
+P4-S ticks:297
+P4-F ticks:298
+P3-S ticks:298
+P1-S ticks:299
+P1-F ticks:299
+P3-F ticks:299
+P2-S ticks:300
+P2-F ticks:300
+P1-S ticks:302
+P1-F ticks:302
+P3-S ticks:303
+P3-F ticks:303
+P4-S ticks:303
+P2-S ticks:304
+P2-F ticks:304
+P1-S ticks:305
+P1-F ticks:305
+P4-F ticks:306
+P1-S ticks:308
+P1-F ticks:308
+P2-S ticks:308
+P2-F ticks:309
+P3-S ticks:309
+P3-F ticks:310
+P4-S ticks:310
+P1-S ticks:311
+P1-F ticks:311
+P4-F ticks:311
+P2-S ticks:312
+P2-F ticks:312
+P3-S ticks:313
+P3-F ticks:313
+P1-S ticks:314
+P1-F ticks:314
+P2-S ticks:316
+P2-F ticks:316
+P1-S ticks:317
+P1-F ticks:317
+P4-S ticks:317
+P3-S ticks:318
+P3-F ticks:318
+P4-F ticks:319
+P1-S ticks:320
+P1-F ticks:320
+P2-S ticks:320
+P2-F ticks:321
+P1-S ticks:323
+P1-F ticks:323
+P3-S ticks:323
+P3-F ticks:324
+P2-S ticks:324
+P2-F ticks:325
+P4-S ticks:325
+P1-S ticks:326
+P1-F ticks:326
+P4-F ticks:326
+P2-S ticks:328
+P2-F ticks:328
+P3-S ticks:328
+P1-S ticks:329
+P1-F ticks:329
+P3-F ticks:330
+P4-S ticks:331
+P4-F ticks:331
+P1-S ticks:332
+P1-F ticks:332
+P2-S ticks:332
+P2-F ticks:333
+P3-S ticks:333
+P3-F ticks:334
+P1-S ticks:335
+P1-F ticks:335
+P2-S ticks:336
+P2-F ticks:336
+P1-S ticks:338
+P1-F ticks:338
+P3-S ticks:338
+P3-F ticks:339
+P4-S ticks:339
+P2-S ticks:340
+P2-F ticks:340
+P1-S ticks:341
+P1-F ticks:341
+P4-F ticks:341
+P3-S ticks:343
+P3-F ticks:343
+P1-S ticks:344
+P1-F ticks:344
+P2-S ticks:344
+P2-F ticks:345
+P4-S ticks:345
+P4-F ticks:346
+P1-S ticks:347
+P1-F ticks:347
+P2-S ticks:348
+P2-F ticks:348
+P3-S ticks:348
+P3-F ticks:349
+P1-S ticks:350
+P1-F ticks:350
+P2-S ticks:352
+P2-F ticks:352
+P4-S ticks:352
+P1-S ticks:353
+P1-F ticks:353
+P3-S ticks:353
+P3-F ticks:354
+P4-F ticks:355
+P1-S ticks:356
+P1-F ticks:356
+P2-S ticks:356
+P2-F ticks:357
+P3-S ticks:358
+P3-F ticks:358
+P1-S ticks:359
+P1-F ticks:359
+P4-S ticks:359
+P2-S ticks:360
+P2-F ticks:360
+P4-F ticks:361
+P1-S ticks:362
+P1-F ticks:362
+P3-S ticks:363
+P3-F ticks:363
+P2-S ticks:364
+P2-F ticks:364
+P1-S ticks:365
+P1-F ticks:365
+P4-S ticks:366
+P4-F ticks:366
+P1-S ticks:368
+P1-F ticks:368
+P2-S ticks:368
+P2-F ticks:369
+P3-S ticks:369
+P3-F ticks:370
+P1-S ticks:371
+P1-F ticks:371
+P2-S ticks:372
+P2-F ticks:372
+P3-S ticks:373
+P3-F ticks:373
+P4-S ticks:373
+P1-S ticks:374
+P1-F ticks:374
+P4-F ticks:375
+P2-S ticks:376
+P2-F ticks:376
+P1-S ticks:377
+P1-F ticks:377
+P3-S ticks:378
+P3-F ticks:378
+P1-S ticks:380
+P1-F ticks:380
+P2-S ticks:380
+P2-F ticks:381
+P4-S ticks:381
+P4-F ticks:382
+P5-F ticks:382
+Killing task 5P1-S ticks:383
+P1-F ticks:383
+P3-S ticks:383
+P3-F ticks:384
+P2-S ticks:384
+P2-F ticks:385
+P1-S ticks:386
+P1-F ticks:386
+P4-S ticks:387
+P4-F ticks:387
+P2-S ticks:388
+P2-F ticks:388
+P3-S ticks:388
+P1-S ticks:389
+P1-F ticks:389
+P3-F ticks:390
+P1-S ticks:392
+P1-F ticks:392
+P2-S ticks:392
+P2-F ticks:393
+P3-S ticks:393
+P3-F ticks:394
+P4-S ticks:394
+P1-S ticks:395
+P1-F ticks:395
+P4-F ticks:395
+P2-S ticks:396
+P2-F ticks:396
+P1-S ticks:398
+P1-F ticks:398
+P3-S ticks:398
+P3-F ticks:399
+P2-S ticks:400
+P2-F ticks:400
+P1-S ticks:401
+P1-F ticks:401
+P4-S ticks:401
+P4-F ticks:402
+P3-S ticks:403
+P3-F ticks:403
+P1-S ticks:404
+P1-F ticks:404
+P2-S ticks:404
+P2-F ticks:405
+P1-S ticks:407
+P1-F ticks:407
+P2-S ticks:408
+P2-F ticks:408
+P3-S ticks:408
+P3-F ticks:409
+P4-S ticks:409
+P1-S ticks:410
+P1-F ticks:410
+P4-F ticks:411
+P2-S ticks:412
+P2-F ticks:412
+P1-S ticks:413
+P1-F ticks:413
+P3-S ticks:413
+P3-F ticks:414
+P4-S ticks:415
+P4-F ticks:415
+P1-S ticks:416
+P1-F ticks:416
+P2-S ticks:416
+P2-F ticks:417
+P3-S ticks:418
+P3-F ticks:418
+P1-S ticks:419
+P1-F ticks:419
+P2-S ticks:420
+P2-F ticks:420
+P1-S ticks:422
+P1-F ticks:422
+P4-S ticks:422
+P3-S ticks:423
+P3-F ticks:423
+P2-S ticks:424
+P2-F ticks:424
+P1-S ticks:425
+P1-F ticks:425
+P4-F ticks:425
+P1-S ticks:428
+P1-F ticks:428
+P2-S ticks:428
+P2-F ticks:429
+P3-S ticks:429
+P3-F ticks:430
+P4-S ticks:430
+P1-S ticks:431
+P1-F ticks:431
+P4-F ticks:431
+P2-S ticks:432
+P2-F ticks:432
+P3-S ticks:433
+P3-F ticks:433
+P1-S ticks:434
+P1-F ticks:434
+P2-S ticks:436
+P2-F ticks:436
+P4-S ticks:436
+P1-S ticks:437
+P1-F ticks:437
+P4-F ticks:438
+P3-S ticks:438
+P3-F ticks:439
+P1-S ticks:440
+P1-F ticks:440
+P2-S ticks:440
+P2-F ticks:441
+P1-S ticks:443
+P1-F ticks:443
+P3-S ticks:443
+P3-F ticks:444
+P2-S ticks:444
+P2-F ticks:445
+P4-S ticks:445
+P1-S ticks:446
+P1-F ticks:446
+P4-F ticks:446
+P2-S ticks:448
+P2-F ticks:448
+P3-S ticks:448
+P1-S ticks:449
+P1-F ticks:449
+P3-F ticks:450
+P4-S ticks:450
+P4-F ticks:451
+P1-S ticks:452
+P1-F ticks:452
+P2-S ticks:452
+P2-F ticks:453
+P3-S ticks:453
+P3-F ticks:454
+P1-S ticks:455
+P1-F ticks:455
+P2-S ticks:456
+P2-F ticks:456
+P4-S ticks:457
+P4-F ticks:457
+P1-S ticks:458
+P1-F ticks:458
+P3-S ticks:458
+P3-F ticks:459
+P2-S ticks:460
+P2-F ticks:460
+P1-S ticks:461
+P1-F ticks:461
+P3-S ticks:463
+P3-F ticks:463
+P1-S ticks:464
+P1-F ticks:464
+P2-S ticks:464
+P2-F ticks:465
+P4-S ticks:465
+P4-F ticks:466
+P1-S ticks:467
+P1-F ticks:467
+P2-S ticks:468
+P2-F ticks:468
+P3-S ticks:468
+P3-F ticks:469
+P1-S ticks:470
+P1-F ticks:470
+P4-S ticks:471
+P4-F ticks:471
+P2-S ticks:472
+P2-F ticks:472
+P1-S ticks:473
+P1-F ticks:473
+P3-S ticks:473
+P3-F ticks:474
+P1-S ticks:476
+P1-F ticks:476
+P2-S ticks:476
+P2-F ticks:477
+P3-S ticks:478
+P3-F ticks:478
+P4-S ticks:478
+P1-S ticks:479
+P1-F ticks:479
+P2-S ticks:480
+P2-F ticks:480
+P4-F ticks:481
+P1-S ticks:482
+P1-F ticks:482
+P3-S ticks:483
+P3-F ticks:483
+P2-S ticks:484
+P2-F ticks:484
+P1-S ticks:485
+P1-F ticks:485
+P4-S ticks:485
+P4-F ticks:486
+P1-S ticks:488
+P1-F ticks:488
+P2-S ticks:488
+P2-F ticks:489
+P3-S ticks:489
+P3-F ticks:490
+P1-S ticks:491
+P1-F ticks:491
+P2-S ticks:492
+P2-F ticks:492
+P4-S ticks:492
+P3-S ticks:493
+P3-F ticks:493
+P1-S ticks:494
+P1-F ticks:494
+P4-F ticks:495
+P2-S ticks:496
+P2-F ticks:496
+P1-S ticks:497
+P1-F ticks:497
+P3-S ticks:498
+P3-F ticks:498
+P4-S ticks:499
+P4-F ticks:499
+P1-S ticks:500
+P1-F ticks:500
+P2-S ticks:500
+P2-F ticks:501
+P1-S ticks:503
+P1-F ticks:503
+P3-S ticks:503
+P3-F ticks:504
+P2-S ticks:504
+P2-F ticks:505
+P1-S ticks:506
+P1-F ticks:506
+P4-S ticks:506
+P4-F ticks:507
+P2-S ticks:508
+P2-F ticks:508
+P3-S ticks:508
+P1-S ticks:509
+P1-F ticks:509
+P3-F ticks:510
+P1-S ticks:512
+P1-F ticks:512
+P2-S ticks:512
+P2-F ticks:513
+P3-S ticks:513
+P3-F ticks:514
+P4-S ticks:514
+P1-S ticks:515
+P1-F ticks:515
+P4-F ticks:515
+P2-S ticks:516
+P2-F ticks:516
+P1-S ticks:518
+P1-F ticks:518
+P3-S ticks:518
+P3-F ticks:519
+P2-S ticks:520
+P2-F ticks:520
+P4-S ticks:520
+P1-S ticks:521
+P1-F ticks:521
+P4-F ticks:522
+P3-S ticks:523
+P3-F ticks:523
+P1-S ticks:524
+P1-F ticks:524
+P2-S ticks:524
+P2-F ticks:525
+P1-S ticks:527
+P1-F ticks:527
+P4-S ticks:527
+P2-S ticks:528
+P2-F ticks:528
+P3-S ticks:528
+P3-F ticks:529
+P1-S ticks:530
+P1-F ticks:530
+P4-F ticks:530
+P2-S ticks:532
+P2-F ticks:532
+P1-S ticks:533
+P1-F ticks:533
+P3-S ticks:533
+P3-F ticks:534
+P4-S ticks:534
+P4-F ticks:535
+P1-S ticks:536
+P1-F ticks:536
+P2-S ticks:536
+P2-F ticks:537
+P3-S ticks:538
+P3-F ticks:538
+P1-S ticks:539
+P1-F ticks:539
+P2-S ticks:540
+P2-F ticks:540
+P4-S ticks:541
+P4-F ticks:541
+P1-S ticks:542
+P1-F ticks:542
+P3-S ticks:543
+P3-F ticks:543
+P2-S ticks:544
+P2-F ticks:544
+P1-S ticks:545
+P1-F ticks:545
+P1-S ticks:548
+P1-F ticks:548
+P2-S ticks:548
+P2-F ticks:549
+P3-S ticks:549
+P3-F ticks:550
+P4-S ticks:550
+P1-S ticks:551
+P1-F ticks:551
+P4-F ticks:551
+P2-S ticks:552
+P2-F ticks:552
+P3-S ticks:553
+P3-F ticks:553
+P1-S ticks:554
+P1-F ticks:554
+P4-S ticks:555
+P4-F ticks:555
+P2-S ticks:556
+P2-F ticks:556
+P1-S ticks:557
+P1-F ticks:557
+P3-S ticks:558
+P3-F ticks:558
+P1-S ticks:560
+P1-F ticks:560
+P2-S ticks:560
+P2-F ticks:561
+P4-S ticks:562
+P4-F ticks:562
+P1-S ticks:563
+P1-F ticks:563
+P3-S ticks:563
+P3-F ticks:564
+P2-S ticks:564
+P2-F ticks:565
+P1-S ticks:566
+P1-F ticks:566
+P2-S ticks:568
+P2-F ticks:568
+P3-S ticks:568
+P1-S ticks:569
+P1-F ticks:569
+P3-F ticks:570
+P4-S ticks:570
+P4-F ticks:571
+P1-S ticks:572
+P1-F ticks:572
+P2-S ticks:572
+P2-F ticks:573
+P3-S ticks:573
+P3-F ticks:574
+P1-S ticks:575
+P1-F ticks:575
+P2-S ticks:576
+P2-F ticks:576
+P4-S ticks:576
+P4-F ticks:577
+P1-S ticks:578
+P1-F ticks:578
+P3-S ticks:578
+P3-F ticks:579
+P2-S ticks:580
+P2-F ticks:580
+P1-S ticks:581
+P1-F ticks:581
+P3-S ticks:583
+P3-F ticks:583
+P4-S ticks:583
+P1-S ticks:584
+P1-F ticks:584
+P2-S ticks:584
+P2-F ticks:585
+P4-F ticks:586
+P1-S ticks:587
+P1-F ticks:587
+P2-S ticks:588
+P2-F ticks:588
+P3-S ticks:588
+P3-F ticks:589
+P1-S ticks:590
+P1-F ticks:590
+P4-S ticks:590
+P4-F ticks:591
+P2-S ticks:592
+P2-F ticks:592
+P1-S ticks:593
+P1-F ticks:593
+P3-S ticks:593
+P3-F ticks:594
+P1-S ticks:596
+P1-F ticks:596
+P2-S ticks:596
+P2-F ticks:597
+P4-S ticks:597
+P3-S ticks:598
+P3-F ticks:598
+P1-S ticks:599
+P1-F ticks:599
+P4-F ticks:599
+P2-S ticks:600
+P2-F ticks:600
+P1-S ticks:602
+P1-F ticks:602
+P3-S ticks:603
+P3-F ticks:603
+P2-S ticks:604
+P2-F ticks:604
+P4-S ticks:604
+P1-S ticks:605
+P1-F ticks:605
+P4-F ticks:606
+P1-S ticks:608
+P1-F ticks:608
+P2-S ticks:608
+P2-F ticks:609
+P3-S ticks:609
+P3-F ticks:610
+P1-S ticks:611
+P1-F ticks:611
+P4-S ticks:611
+P2-S ticks:612
+P2-F ticks:612
+P4-F ticks:613
+P3-S ticks:613
+P1-S ticks:614
+P1-F ticks:614
+P3-F ticks:614
+P2-S ticks:616
+P2-F ticks:616
+P1-S ticks:617
+P1-F ticks:617
+P3-S ticks:618
+P3-F ticks:618
+P4-S ticks:618
+P4-F ticks:619
+P1-S ticks:620
+P1-F ticks:620
+P2-S ticks:620
+P2-F ticks:621
+P1-S ticks:623
+P1-F ticks:623
+P3-S ticks:623
+P3-F ticks:624
+P2-S ticks:624
+P2-F ticks:625
+P4-S ticks:625
+P1-S ticks:626
+P1-F ticks:626
+P4-F ticks:626
+P2-S ticks:628
+P2-F ticks:628
+P3-S ticks:628
+P1-S ticks:629
+P1-F ticks:629
+P3-F ticks:630
+P1-S ticks:632
+P1-F ticks:632
+P2-S ticks:632
+P2-F ticks:633
+P3-S ticks:633
+P3-F ticks:634
+P4-S ticks:634
+P1-S ticks:635
+P1-F ticks:635
+P4-F ticks:635
+P2-S ticks:636
+P2-F ticks:636
+P1-S ticks:638
+P1-F ticks:638
+P3-S ticks:638
+P3-F ticks:639
+P4-S ticks:639
+P2-S ticks:640
+P2-F ticks:640
+P1-S ticks:641
+P1-F ticks:641
+P4-F ticks:641
+P3-S ticks:643
+P3-F ticks:643
+P1-S ticks:644
+P1-F ticks:644
+P2-S ticks:644
+P2-F ticks:645
+P4-S ticks:646
+P4-F ticks:646
+P1-S ticks:647
+P1-F ticks:647
+P2-S ticks:648
+P2-F ticks:648
+P3-S ticks:648
+P3-F ticks:649
+P1-S ticks:650
+P1-F ticks:650
+P2-S ticks:652
+P2-F ticks:652
+P1-S ticks:653
+P1-F ticks:653
+P3-S ticks:653
+P3-F ticks:654
+P4-S ticks:654
+P4-F ticks:655
+P1-S ticks:656
+P1-F ticks:656
+P2-S ticks:656
+P2-F ticks:657
+P3-S ticks:658
+P3-F ticks:658
+P1-S ticks:659
+P1-F ticks:659
+P2-S ticks:660
+P2-F ticks:660
+P4-S ticks:660
+P4-F ticks:661
+P1-S ticks:662
+P1-F ticks:662
+P3-S ticks:663
+P3-F ticks:663
+P2-S ticks:664
+P2-F ticks:664
+P1-S ticks:665
+P1-F ticks:665
+P4-S ticks:667
+P4-F ticks:667
+P1-S ticks:668
+P1-F ticks:668
+P2-S ticks:668
+P2-F ticks:669
+P3-S ticks:669
+P3-F ticks:670
+P1-S ticks:671
+P1-F ticks:671
+P2-S ticks:672
+P2-F ticks:672
+P3-S ticks:673
+P3-F ticks:673
+P1-S ticks:674
+P1-F ticks:674
+P4-S ticks:674
+P4-F ticks:675
+P2-S ticks:676
+P2-F ticks:676
+P1-S ticks:677
+P1-F ticks:677
+P3-S ticks:678
+P3-F ticks:678
+P1-S ticks:680
+P1-F ticks:680
+P2-S ticks:680
+P2-F ticks:681
+P4-S ticks:681
+P4-F ticks:682
+P1-S ticks:683
+P1-F ticks:683
+P3-S ticks:683
+P3-F ticks:684
+P2-S ticks:684
+P2-F ticks:685
+P1-S ticks:686
+P1-F ticks:686
+P2-S ticks:688
+P2-F ticks:688
+P3-S ticks:688
+P1-S ticks:689
+P1-F ticks:689
+P3-F ticks:690
+P4-S ticks:690
+P4-F ticks:691
+P1-S ticks:692
+P1-F ticks:692
+P2-S ticks:692
+P2-F ticks:693
+P3-S ticks:693
+P3-F ticks:694
+P1-S ticks:695
+P1-F ticks:695
+P4-S ticks:695
+P2-S ticks:696
+P2-F ticks:696
+P4-F ticks:697
+P1-S ticks:698
+P1-F ticks:698
+P3-S ticks:698
+P3-F ticks:699
+P2-S ticks:700
+P2-F ticks:700
+P1-S ticks:701
+P1-F ticks:701
+P4-S ticks:702
+P4-F ticks:702
+P3-S ticks:703
+P3-F ticks:703
+P1-S ticks:704
+P1-F ticks:704
+P2-S ticks:704
+P2-F ticks:705
+P1-S ticks:707
+P1-F ticks:707
+P2-S ticks:708
+P2-F ticks:708
+P3-S ticks:708
+P3-F ticks:709
+P4-S ticks:709
+P1-S ticks:710
+P1-F ticks:710
+P4-F ticks:711
+P2-S ticks:712
+P2-F ticks:712
+P1-S ticks:713
+P1-F ticks:713
+P3-S ticks:713
+P3-F ticks:714
+P1-S ticks:716
+P1-F ticks:716
+P2-S ticks:716
+P2-F ticks:717
+P4-S ticks:717
+P4-F ticks:718
+P3-S ticks:718
+P1-S ticks:719
+P1-F ticks:719
+P3-F ticks:719
+P2-S ticks:720
+P2-F ticks:720
+P1-S ticks:722
+P1-F ticks:722
+P3-S ticks:723
+P3-F ticks:723
+P4-S ticks:723
+P2-S ticks:724
+P2-F ticks:724
+P1-S ticks:725
+P1-F ticks:725
+P4-F ticks:726
+P1-S ticks:728
+P1-F ticks:728
+P2-S ticks:728
+P2-F ticks:729
+P3-S ticks:729
+P3-F ticks:730
+P4-S ticks:730
+P1-S ticks:731
+P1-F ticks:731
+P4-F ticks:731
+P2-S ticks:732
+P2-F ticks:732
+P3-S ticks:733
+P3-F ticks:733
+P1-S ticks:734
+P1-F ticks:734
+P2-S ticks:736
+P2-F ticks:736
+P1-S ticks:737
+P1-F ticks:737
+P4-S ticks:737
+P3-S ticks:738
+P3-F ticks:738
+P4-F ticks:739
+P1-S ticks:740
+P1-F ticks:740
+P2-S ticks:740
+P2-F ticks:741
+P1-S ticks:743
+P1-F ticks:743
+P3-S ticks:743
+P3-F ticks:744
+P2-S ticks:744
+P2-F ticks:745
+P4-S ticks:745
+P1-S ticks:746
+P1-F ticks:746
+P4-F ticks:746
+P2-S ticks:748
+P2-F ticks:748
+P3-S ticks:748
+P1-S ticks:749
+P1-F ticks:749
+P3-F ticks:750
+P4-S ticks:751
+P4-F ticks:751
+P1-S ticks:752
+P1-F ticks:752
+P2-S ticks:752
+P2-F ticks:753
+P3-S ticks:753
+P3-F ticks:754
+P1-S ticks:755
+P1-F ticks:755
+P2-S ticks:756
+P2-F ticks:756
+P1-S ticks:758
+P1-F ticks:758
+P3-S ticks:758
+P3-F ticks:759
+P4-S ticks:759
+P2-S ticks:760
+P2-F ticks:760
+P1-S ticks:761
+P1-F ticks:761
+P4-F ticks:761
+P3-S ticks:763
+P3-F ticks:763
+P1-S ticks:764
+P1-F ticks:764
+P2-S ticks:764
+P2-F ticks:765
+P4-S ticks:765
+P4-F ticks:766
+P1-S ticks:767
+P1-F ticks:767
+P2-S ticks:768
+P2-F ticks:768
+P3-S ticks:768
+P3-F ticks:769
+P1-S ticks:770
+P1-F ticks:770
+P2-S ticks:772
+P2-F ticks:772
+P4-S ticks:772
+P1-S ticks:773
+P1-F ticks:773
+P3-S ticks:773
+P3-F ticks:774
+P4-F ticks:775
+P1-S ticks:776
+P1-F ticks:776
+P2-S ticks:776
+P2-F ticks:777
+P3-S ticks:778
+P3-F ticks:778
+P1-S ticks:779
+P1-F ticks:779
+P4-S ticks:779
+P2-S ticks:780
+P2-F ticks:780
+P4-F ticks:781
+P1-S ticks:782
+P1-F ticks:782
+P3-S ticks:783
+P3-F ticks:783
+P2-S ticks:784
+P2-F ticks:784
+P1-S ticks:785
+P1-F ticks:785
+P4-S ticks:786
+P4-F ticks:786
+P1-S ticks:788
+P1-F ticks:788
+P2-S ticks:788
+P2-F ticks:789
+P3-S ticks:789
+P3-F ticks:790
+P1-S ticks:791
+P1-F ticks:791
+P2-S ticks:792
+P2-F ticks:792
+P3-S ticks:793
+P3-F ticks:793
+P4-S ticks:793
+P1-S ticks:794
+P1-F ticks:794
+P4-F ticks:795
+P2-S ticks:796
+P2-F ticks:796
+P1-S ticks:797
+P1-F ticks:797
+P3-S ticks:798
+P3-F ticks:798
+P1-S ticks:800
+P1-F ticks:800
+P2-S ticks:800
+P2-F ticks:801
+P4-S ticks:801
+P4-F ticks:802
+P1-S ticks:803
+P1-F ticks:803
+P3-S ticks:803
+P3-F ticks:804
+P2-S ticks:804
+P2-F ticks:805
+P1-S ticks:806
+P1-F ticks:806
+P4-S ticks:807
+P4-F ticks:807
+P2-S ticks:808
+P2-F ticks:808
+P3-S ticks:808
+P1-S ticks:809
+P1-F ticks:809
+P3-F ticks:810
+P1-S ticks:812
+P1-F ticks:812
+P2-S ticks:812
+P2-F ticks:813
+P3-S ticks:813
+P3-F ticks:814
+P4-S ticks:814
+P1-S ticks:815
+P1-F ticks:815
+P4-F ticks:815
+P2-S ticks:816
+P2-F ticks:816
+P1-S ticks:818
+P1-F ticks:818
+P3-S ticks:818
+P3-F ticks:819
+P2-S ticks:820
+P2-F ticks:820
+P1-S ticks:821
+P1-F ticks:821
+P4-S ticks:821
+P4-F ticks:822
+P3-S ticks:823
+P3-F ticks:823
+P1-S ticks:824
+P1-F ticks:824
+P2-S ticks:824
+P2-F ticks:825
+P1-S ticks:827
+P1-F ticks:827
+P2-S ticks:828
+P2-F ticks:828
+P3-S ticks:828
+P3-F ticks:829
+P4-S ticks:829
+P1-S ticks:830
+P1-F ticks:830
+P4-F ticks:831
+P2-S ticks:832
+P2-F ticks:832
+P1-S ticks:833
+P1-F ticks:833
+P3-S ticks:833
+P3-F ticks:834
+P4-S ticks:835
+P4-F ticks:835
+P1-S ticks:836
+P1-F ticks:836
+P2-S ticks:836
+P2-F ticks:837
+P3-S ticks:838
+P3-F ticks:838
+P1-S ticks:839
+P1-F ticks:839
+P2-S ticks:840
+*** END OF TEST SCHEDULER 5 (EDF) ***
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/system.h rtems/testsuites/sptests/spsched05/system.h
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/system.h	2010-07-29 18:46:40.000000000 -0400
@@ -0,0 +1,76 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: system.h,v 1.22 2009/10/05 15:01:59 joel Exp $
+ */
+
+#include <tmacros.h>
+
+/* functions */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Tasks_Periodic(
+  rtems_task_argument argument
+);
+
+rtems_task Tasks_Aperiodic(
+  rtems_task_argument argument
+);
+
+void set_timespec_from_us( 
+    struct timespec *ts, 
+    uint32_t time_us 
+);
+
+/* configuration information */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+
+#define CONFIGURE_MICROSECONDS_PER_TICK 100000
+
+#define CONFIGURE_MAXIMUM_TASKS               7
+#define CONFIGURE_MAXIMUM_PERIODS             10
+
+#define CONFIGURE_INIT_TASK_PRIORITY          100
+#define CONFIGURE_INIT_TASK_INITIAL_MODES     RTEMS_DEFAULT_MODES
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#define CONFIGURE_EXTRA_TASK_STACKS         (6 * 4 * RTEMS_MINIMUM_STACK_SIZE)
+
+#define CONFIGURE_SCHEDULER_EDF
+
+#include <rtems/confdefs.h>
+
+#include <rtems/rtems/clock.h>
+#include <rtems/score/isr.h>
+#include <rtems/rtems/intr.h>
+
+/* global variables */
+#include "edfmacros.h"
+TEST_EXTERN rtems_id   Task_id[ 1+NUM_TASKS ];     /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 1+NUM_TASKS ];   /* array of task names */
+extern rtems_task_priority Priorities[ 1+NUM_TASKS ];
+extern uint32_t  Periods[ 1 + NUM_PERIODIC_TASKS ];
+extern uint32_t  Periods_us[1 + NUM_PERIODIC_TASKS ];
+extern uint32_t  Phases[1 + NUM_TASKS];
+extern uint32_t  Phases_us[1 + NUM_TASKS];
+extern uint32_t  Execution[1 + NUM_TASKS];
+extern uint32_t  Execution_us[1 + NUM_TASKS];
+extern uint32_t  Tick_Count[1 + NUM_TASKS];
+
+/* extern bool _EDF_hack_started; */
+
+/* end of include file */
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/tasks_aperiodic.c rtems/testsuites/sptests/spsched05/tasks_aperiodic.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/tasks_aperiodic.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/tasks_aperiodic.c	2010-07-29 18:45:48.000000000 -0400
@@ -0,0 +1,93 @@
+/*  Tasks_Aperiodic
+ *
+ *  This routine serves as a test task for the slack stealing scheduler 
+ *  implementation. This is for aperiodic task execution.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include "system.h"
+
+rtems_task Tasks_Aperiodic(
+  rtems_task_argument argument
+)
+{
+  int               index;
+  rtems_status_code status;
+
+  int start, stop;
+  rtems_interrupt_level level;
+
+  struct timespec start_ts, stop_ts, diff_ts;
+  Thread_CPU_usage_t initial_usage;
+  Thread_CPU_usage_t used;
+  Thread_CPU_usage_t thread_usage;
+
+  put_name( Task_name[ argument ], FALSE );
+
+  status = rtems_task_wake_after( 2 + Phases[argument] );
+  directive_failed( status, "rtems_task_wake_after" );
+
+  rtems_clock_get(RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &start);
+  printf("AT%d-S ticks:%d\n", argument, start);
+  /* active computing */
+
+  _Timespec_From_ticks(1, &diff_ts);
+  diff_ts.tv_sec = diff_ts.tv_sec / 4; /* probably 0 anyway */
+  diff_ts.tv_nsec = diff_ts.tv_nsec / 4; /* this is now 1/4 of a tick */
+
+  set_timespec_from_us( &stop_ts, Execution_us[argument] );
+  
+  initial_usage = _Thread_Executing->cpu_time_used;
+
+  while(FOREVER) { 
+    used = _Thread_Executing->cpu_time_used;
+
+#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+    Thread_CPU_usage_t ran;
+    Timestamp_Control        uptime;
+  
+
+    _TOD_Get_uptime( &uptime );
+    /* ran = time since last context switch */
+    _Timestamp_Subtract(
+      &_Thread_Time_of_last_context_switch, &uptime, &ran
+    );
+
+    /* used += ran */
+    _Timestamp_Add_to( &used, &ran );
+
+    /* thread_usage = used - initial cpu usage */
+    _Timestamp_Subtract(
+        &initial_usage,
+        &used,
+        &thread_usage
+     );
+
+    _Timespec_Add_to(&thread_usage, &diff_ts); /* add 1/4 of a tick */
+    if (_Timespec_Equal_to(&thread_usage, &stop_ts) ||
+        _Timespec_Greater_than(&thread_usage, &stop_ts)) break;
+#else
+    used = _Thread_Executing->cpu_time_used;
+    
+    if (used - initial_usage >= Tick_Count[argument]) break;
+#endif
+  }
+  rtems_clock_get(RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &stop);
+  printf("P%d-F ticks:%d\n", argument, stop);
+
+  /* delete SELF */
+  fflush(stdout);
+  printf( "Killing task %d", argument);
+  status = rtems_task_delete(RTEMS_SELF);
+  directive_failed(status, "rtems_task_delete of RTEMS_SELF");
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/tasks_periodic.c rtems/testsuites/sptests/spsched05/tasks_periodic.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsched05/tasks_periodic.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems/testsuites/sptests/spsched05/tasks_periodic.c	2010-07-29 18:46:17.000000000 -0400
@@ -0,0 +1,102 @@
+/*  Tasks_Periodic
+ *
+ *  This routine serves as a test task for the slack stealing scheduler 
+ *  implementation.
+ *
+ *  Input parameters:
+ *    argument - task argument
+ *
+ *  Output parameters:  NONE
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include "system.h"
+
+rtems_task Tasks_Periodic(
+  rtems_task_argument argument
+)
+{
+  rtems_id          rmid;
+  rtems_id          test_rmid;
+  int               index;
+  int               pass;
+  uint32_t          failed;
+  rtems_status_code status;
+
+  int start, stop;
+  int i, j, k;
+  rtems_interrupt_level level;
+
+  rtems_periodic_period_status period_stats;
+  Thread_CPU_usage_t period_usage;
+
+  struct timespec start_ts, stop_ts, diff_ts;
+
+  status = rtems_periodic_create( argument, &rmid );
+  directive_failed( status, "rtems_periodic_create" );
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- rtems_periodic_create id = 0x%08" PRIxrtems_id "\n", rmid );
+
+  status = rtems_periodic_ident( argument, &test_rmid );
+  directive_failed( status, "rtems_periodic_ident" );
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- rtems_periodic_ident id = 0x%08" PRIxrtems_id "\n", test_rmid );
+
+  if ( rmid != test_rmid ) {
+     printf( "RMID's DO NOT MATCH (0x%" PRIxrtems_id " and 0x%" PRIxrtems_id ")\n", rmid, test_rmid );
+     rtems_test_exit( 0 );
+  }
+
+  put_name( Task_name[ argument ], FALSE );
+  printf( "- (0x%08" PRIxrtems_id ") period %" PRIu32 "\n", rmid, Periods[ argument ] );
+
+  status = rtems_task_wake_after( 2 + Phases[argument] );
+  directive_failed( status, "rtems_task_wake_after" );
+
+  while (FOREVER) {
+    if (rtems_periodic_period(rmid, Periods[argument])==RTEMS_TIMEOUT)
+      printf("P%d - Deadline miss\n", argument);
+
+    rtems_clock_get(RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &start);
+    printf("P%d-S ticks:%d\n", argument, start);
+    if ( start >= 2*HP_LENGTH ) break; /* stop */
+    /* active computing */
+    
+    _Timespec_From_ticks(1, &diff_ts);
+    diff_ts.tv_sec = diff_ts.tv_sec / 4; /* probably 0 anyway */
+    diff_ts.tv_nsec = diff_ts.tv_nsec / 4; /* this is now 1/4 of a tick */
+
+    set_timespec_from_us( &stop_ts, Execution_us[argument] );
+
+    /* using periodic statistics */
+    while(FOREVER) {
+      rtems_periodic_get_status(rmid, &period_stats);
+      period_usage = period_stats.executed_since_last_period;
+
+      #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
+        _Timespec_Add_to(&period_usage, &diff_ts); /* add 1/4 of a tick */
+        if (_Timespec_Equal_to(&period_usage, &stop_ts) ||
+            _Timespec_Greater_than(&period_usage, &stop_ts)) break;
+      #else
+        if (period_usage >= Tick_Count[argument]) break;
+      #endif
+    }
+    rtems_clock_get(RTEMS_CLOCK_GET_TICKS_SINCE_BOOT, &stop);
+    printf("P%d-F ticks:%d\n", argument, stop);
+  }
+
+  /* delete period and SELF */
+  status = rtems_periodic_delete( rmid );
+  if ( status != RTEMS_SUCCESSFUL ) {
+    printf("rtems_periodic_delete failed with status of %d.\n",status);
+    rtems_test_exit( 0 );
+  }
+  fflush(stdout);
+  puts( "*** END OF TEST SCHEDULER 5 (EDF) ***" );
+  rtems_test_exit( 0 );
+}
diff -X dontdiff -uprN /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsize/size.c rtems/testsuites/sptests/spsize/size.c
--- /home/gedare/work/rtems/rtems/rtems/testsuites/sptests/spsize/size.c	2010-08-11 14:25:11.000000000 -0400
+++ rtems/testsuites/sptests/spsize/size.c	2010-08-13 11:44:31.000000000 -0400
@@ -33,7 +33,8 @@
 #endif
 #include <rtems/rtems/part.h>
 #include <rtems/score/priority.h>
-#include <rtems/rtems/ratemon.h>
+#include <rtems/score/periodic.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/region.h>
 #include <rtems/rtems/sem.h>
 #include <rtems/rtems/signal.h>
@@ -81,7 +82,7 @@ void print_formula(void);
 #define PER_PART      \
      (long) (sizeof (Partition_Control) + NAME_PTR_SIZE)
 #define PER_PERIOD      \
-     (long) (sizeof (Rate_monotonic_Control) + NAME_PTR_SIZE)
+     (long) (sizeof (Periodic_Control) + NAME_PTR_SIZE)
 #define PER_PORT      \
      (long) (sizeof (Dual_ported_memory_Control) + NAME_PTR_SIZE)
 #define PER_EXTENSION     \
@@ -311,11 +312,11 @@ uninitialized =
 
 /*percpu.h*/    (sizeof _Per_CPU_Information)             +
 
+/*periodic.h*/  (sizeof _Periodic_Information)            +
+
 /*priority.h*/  (sizeof _Priority_Major_bit_map)          +
                 (sizeof _Priority_Bit_map)                +
 
-/*ratemon.h*/   (sizeof _Rate_monotonic_Information)      +
-
 /*region.h*/    (sizeof _Region_Information)              +
 
 #if defined(RTEMS_MULTIPROCESSING)
@@ -355,7 +356,6 @@ uninitialized =
                 (sizeof _Thread_Dispatch_disable_level)   +
                 (sizeof _Thread_Maximum_extensions)       +
                 (sizeof _Thread_Ticks_per_timeslice)      +
-                (sizeof _Thread_Ready_chain)              +
                 (sizeof _Thread_Executing)                +
                 (sizeof _Thread_Heir)                     +
 #if (CPU_HARDWARE_FP == 1) || (CPU_SOFTWARE_FP == 1)
