Index: cpukit/rtems/Makefile.am
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/Makefile.am,v
retrieving revision 1.51
diff -u -p -r1.51 Makefile.am
--- cpukit/rtems/Makefile.am	23 Jun 2010 03:10:34 -0000	1.51
+++ cpukit/rtems/Makefile.am	27 Jul 2010 16:13:57 -0000
@@ -25,6 +25,7 @@ include_rtems_rtems_HEADERS = include/rt
     include/rtems/rtems/intr.h include/rtems/rtems/message.h \
     include/rtems/rtems/modes.h include/rtems/rtems/object.h \
     include/rtems/rtems/options.h include/rtems/rtems/part.h \
+		include/rtems/rtems/periodic.h \
     include/rtems/rtems/ratemon.h include/rtems/rtems/region.h \
     include/rtems/rtems/rtemsapi.h include/rtems/rtems/sem.h \
     include/rtems/rtems/signal.h include/rtems/rtems/status.h \
@@ -70,12 +71,19 @@ librtems_a_SOURCES += src/tasks.c src/ta
     src/taskvariableadd.c src/taskvariabledelete.c src/taskvariableget.c \
     src/taskvariable_invoke_dtor.c src/taskdata.c
 
+## PERIODIC_C_FILES
+librtems_a_SOURCES += src/periodiccancel.c src/periodicident.c \
+		src/periodiccreate.c src/periodicperiod.c src/periodicdelete.c \
+		src/periodicreportstatistics.c src/periodicgetstatistics.c \
+		src/periodicresetall.c src/periodicgetstatus.c \
+		src/periodicresetstatistics.c
+
 ## RATEMON_C_FILES
 librtems_a_SOURCES += src/ratemon.c src/ratemoncancel.c src/ratemoncreate.c \
     src/ratemondelete.c src/ratemongetstatus.c src/ratemongetstatistics.c \
     src/ratemonresetstatistics.c src/ratemonresetall.c \
     src/ratemonreportstatistics.c src/ratemonident.c \
-    src/ratemonperiod.c src/ratemontimeout.c src/ratemondata.c
+    src/ratemonperiod.c src/ratemondata.c
 
 ## INTR_C_FILES
 librtems_a_SOURCES += src/intrbody.c src/intrcatch.c
Index: cpukit/rtems/preinstall.am
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/preinstall.am,v
retrieving revision 1.13
diff -u -p -r1.13 preinstall.am
--- cpukit/rtems/preinstall.am	12 Aug 2009 14:20:20 -0000	1.13
+++ cpukit/rtems/preinstall.am	27 Jul 2010 16:13:57 -0000
@@ -87,6 +87,10 @@ $(PROJECT_INCLUDE)/rtems/rtems/part.h: i
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/part.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/part.h
 
+$(PROJECT_INCLUDE)/rtems/rtems/periodic.h: include/rtems/rtems/periodic.h $(PROJECT_INCLUDE)/rtems/rtems/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/periodic.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/periodic.h
+
 $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h: include/rtems/rtems/ratemon.h $(PROJECT_INCLUDE)/rtems/rtems/$(dirstamp)
 	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h
 PREINSTALL_FILES += $(PROJECT_INCLUDE)/rtems/rtems/ratemon.h
Index: cpukit/rtems/include/rtems/rtems/ratemon.h
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/include/rtems/rtems/ratemon.h,v
retrieving revision 1.42
diff -u -p -r1.42 ratemon.h
--- cpukit/rtems/include/rtems/rtems/ratemon.h	15 Dec 2009 18:26:41 -0000	1.42
+++ cpukit/rtems/include/rtems/rtems/ratemon.h	27 Jul 2010 16:13:57 -0000
@@ -28,16 +28,6 @@
 #ifndef _RTEMS_RTEMS_RATEMON_H
 #define _RTEMS_RTEMS_RATEMON_H
 
-/**
- *  This constant is defined to extern most of the time when using
- *  this header file.  However by defining it to nothing, the data
- *  declared in this header file can be instantiated.  This is done
- *  in a single per manager file.
- */
-#ifndef RTEMS_RATEMON_EXTERN
-#define RTEMS_RATEMON_EXTERN extern
-#endif
-
 #include <rtems/bspIo.h>
 
 /**
@@ -59,220 +49,21 @@
 extern "C" {
 #endif
 
-/**
- *  This is the public type used for the rate monotonic timing
- *  statistics.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #include <rtems/score/timespec.h>
-
-  typedef struct timespec rtems_rate_monotonic_period_time_t;
-#else
-  typedef uint32_t rtems_rate_monotonic_period_time_t;
-#endif
-
-/**
- *  This is the internal type used for the rate monotonic timing
- *  statistics.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #include <rtems/score/timestamp.h>
-
-  typedef Timestamp_Control Rate_monotonic_Period_time_t;
-#else
-  typedef uint32_t Rate_monotonic_Period_time_t;
-#endif
-
-#include <rtems/score/object.h>
-#include <rtems/score/thread.h>
-#include <rtems/score/watchdog.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/status.h>
 #include <rtems/rtems/support.h>
 
+#include <rtems/score/periodic.h>
+
 #include <string.h>
 
+typedef rtems_periodic_period_states rtems_rate_monotonic_period_states; 
 
-/**
- *  The following enumerated type defines the states in which a
- *  period may be.
- */
-typedef enum {
-  /**
-   * This value indicates the period is off the watchdog chain,
-   * and has never been initialized.
-   */
-  RATE_MONOTONIC_INACTIVE,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * the owner is blocked waiting on it.
-   */
-  RATE_MONOTONIC_OWNER_IS_BLOCKING,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * running.  The owner should be executed or blocked waiting on
-   * another object.
-   */
-  RATE_MONOTONIC_ACTIVE,
-
-  /**
-   * This value indicates the period is on the watchdog chain, and
-   * has expired.  The owner should be blocked waiting for the next period.
-   */
-  RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING,
-
-  /**
-   * This value indicates the period is off the watchdog chain, and
-   * has expired.  The owner is still executing and has taken too much
-   * all time to complete this iteration of the period.
-   */
-  RATE_MONOTONIC_EXPIRED
-}   rtems_rate_monotonic_period_states;
-
-/**
- *  The following constant is the interval passed to the rate_monontonic_period
- *  directive to obtain status information.
- */
-#define RTEMS_PERIOD_STATUS       WATCHDOG_NO_TIMEOUT
-
-/**
- *  The following defines the PUBLIC data structure that has the
- *  statistics kept on each period instance.
- *
- *  @note The public structure uses struct timespec while the
- *        internal one uses Timestamp_Control.
- */
-typedef struct {
-  /** This field contains the number of periods executed. */
-  uint32_t     count;
-  /** This field contains the number of periods missed. */
-  uint32_t     missed_count;
-
-  /** This field contains the least amount of CPU time used in a period. */
-  rtems_thread_cpu_usage_t             min_cpu_time;
-  /** This field contains the highest amount of CPU time used in a period. */
-  rtems_thread_cpu_usage_t             max_cpu_time;
-  /** This field contains the total amount of wall time used in a period. */
-  rtems_thread_cpu_usage_t             total_cpu_time;
-
-  /** This field contains the least amount of wall time used in a period. */
-  rtems_rate_monotonic_period_time_t   min_wall_time;
-  /** This field contains the highest amount of wall time used in a period. */
-  rtems_rate_monotonic_period_time_t   max_wall_time;
-  /** This field contains the total amount of CPU time used in a period. */
-  rtems_rate_monotonic_period_time_t   total_wall_time;
-}  rtems_rate_monotonic_period_statistics;
-
-/**
- *  The following defines the INTERNAL data structure that has the
- *  statistics kept on each period instance.
- */
-typedef struct {
-  /** This field contains the number of periods executed. */
-  uint32_t     count;
-  /** This field contains the number of periods missed. */
-  uint32_t     missed_count;
-
-  /** This field contains the least amount of CPU time used in a period. */
-  Thread_CPU_usage_t                   min_cpu_time;
-  /** This field contains the highest amount of CPU time used in a period. */
-  Thread_CPU_usage_t                   max_cpu_time;
-  /** This field contains the total amount of wall time used in a period. */
-  Thread_CPU_usage_t                   total_cpu_time;
-
-  /** This field contains the least amount of wall time used in a period. */
-  Rate_monotonic_Period_time_t         min_wall_time;
-  /** This field contains the highest amount of wall time used in a period. */
-  Rate_monotonic_Period_time_t         max_wall_time;
-  /** This field contains the total amount of CPU time used in a period. */
-  Rate_monotonic_Period_time_t         total_wall_time;
-}  Rate_monotonic_Statistics;
-
-/**
- *  The following defines the period status structure.
- */
-typedef struct {
-  /** This is the Id of the thread using this period. */
-  rtems_id                             owner;
-
-  /** This is the current state of this period. */
-  rtems_rate_monotonic_period_states   state;
-
-  /**
-   *  This is the length of wall time that has passed since this period
-   *  was last initiated.  If the period is expired or has not been initiated,
-   *  then this field has no meaning.
-   */
-  rtems_rate_monotonic_period_time_t   since_last_period;
-
-  /**
-   *  This is the amount of CPU time that has been used since this period
-   *  was last initiated.  If the period is expired or has not been initiated,
-   *  then this field has no meaning.
-   */
-  rtems_thread_cpu_usage_t             executed_since_last_period;
-}  rtems_rate_monotonic_period_status;
-
-/**
- *  The following structure defines the control block used to manage
- *  each period.
- */
-typedef struct {
-  /** This field is the object management portion of a Period instance. */
-  Objects_Control                         Object;
-
-  /** This is the timer used to provide the unblocking mechanism. */
-  Watchdog_Control                        Timer;
-
-  /** This field indicates the current state of the period. */
-  rtems_rate_monotonic_period_states      state;
-
-  /**
-   * This field contains the length of the next period to be
-   * executed.
-   */
-  uint32_t                                next_length;
-
-  /**
-   * This field contains a pointer to the TCB for the thread
-   * which owns and uses this period instance.
-   */
-  Thread_Control                         *owner;
-
-  /**
-   * This field contains the cpu usage value of the owning thread when
-   * the period was initiated.  It is used to compute the period's
-   * statistics.
-   */
-  Thread_CPU_usage_t                      cpu_usage_period_initiated;
-
-  /**
-   * This field contains the wall time value when the period
-   * was initiated.  It is used to compute the period's statistics.
-   */
-  Rate_monotonic_Period_time_t            time_period_initiated;
-
-  /**
-   * This field contains the statistics maintained for the period.
-   */
-  Rate_monotonic_Statistics               Statistics;
-}   Rate_monotonic_Control;
+typedef rtems_periodic_period_statistics rtems_rate_monotonic_period_statistics;
 
-/**
- *  @brief Rate Monotonic Period Class Management Structure
- *
- *  This instance of Objects_Information is used to manage the
- *  set of rate monotonic period instances.
- */
-RTEMS_RATEMON_EXTERN Objects_Information _Rate_monotonic_Information;
+typedef rtems_periodic_period_status rtems_rate_monotonic_period_status; 
 
-/**
- *  @brief Rate Monotonic Manager Initialization
- *
- *  This routine performs the initialization necessary for this manager.
- */
-void _Rate_monotonic_Manager_initialization(void);
+typedef Periodic_Control Rate_monotonic_Control;
 
 /**
  *  @brief rtems_rate_monotonic_create
@@ -393,115 +184,12 @@ rtems_status_code rtems_rate_monotonic_p
 );
 
 /**
- *  @brief _Rate_monotonic_Timeout
- *
- *  This routine is invoked when the period represented
- *  by ID expires.  If the thread which owns this period is blocked
- *  waiting for the period to expire, then it is readied and the
- *  period is restarted.  If the owning thread is not waiting for the
- *  period to expire, then the period is placed in the EXPIRED
- *  state and not restarted.
- */
-void _Rate_monotonic_Timeout(
-  rtems_id    id,
-  void       *ignored
-);
-
-/**
- *  @brief _Rate_monotonic_Get_status(
- *
- *  This routine is invoked to compute the elapsed wall time and cpu
- *  time for a period.
- *
- *  @param[in] the_period points to the period being operated upon.
- *  @param[out] wall_since_last_period is set to the wall time elapsed
- *              since the period was initiated.
- *  @param[out] cpu_since_last_period is set to the cpu time used by the
- *              owning thread since the period was initiated.
- *
- *  @return This routine returns true if the status can be determined
- *          and false otherwise.
- */
-bool _Rate_monotonic_Get_status(
-  Rate_monotonic_Control        *the_period,
-  Rate_monotonic_Period_time_t  *wall_since_last_period,
-  Thread_CPU_usage_t            *cpu_since_last_period
-);
-
-/**
- *  @brief _Rate_monotonic_Initiate_statistics(
- *
- *  This routine is invoked when a period is initiated via an explicit
- *  call to rtems_rate_monotonic_period for the period's first iteration
- *  or from _Rate_monotonic_Timeout for period iterations 2-n.
- *
- *  @param[in] the_period points to the period being operated upon.
- */
-void _Rate_monotonic_Initiate_statistics(
-  Rate_monotonic_Control *the_period
-);
-
-/**
- *  @brief _Rate_monotonic_Reset_wall_time_statistics
- *
- *  This method resets the statistics information for a period instance.
- */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #define _Rate_monotonic_Reset_wall_time_statistics( _the_period ) \
-     do { \
-        /* set the minimums to a large value */ \
-        _Timestamp_Set( \
-          &(_the_period)->Statistics.min_wall_time, \
-          0x7fffffff, \
-          0x7fffffff \
-        ); \
-     } while (0)
-#else
-  #define _Rate_monotonic_Reset_wall_time_statistics( _the_period ) \
-     do { \
-        /* set the minimum to a large value */ \
-        (_the_period)->Statistics.min_wall_time = 0xffffffff; \
-     } while (0)
-#endif
-
-/**
- *  @brief Rate_monotonic_Reset_cpu_use_statistics
+ *  @brief Rate Monotonic Manager Initialization
  *
- *  This helper method resets the period CPU usage statistics structure.
+ *  This routine performs the initialization necessary for this manager.
  */
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  #define _Rate_monotonic_Reset_cpu_use_statistics( _the_period ) \
-     do { \
-        /* set the minimums to a large value */ \
-        _Timestamp_Set( \
-          &(_the_period)->Statistics.min_cpu_time, \
-          0x7fffffff, \
-          0x7fffffff \
-        ); \
-     } while (0)
-#else
-  #define _Rate_monotonic_Reset_cpu_use_statistics( _the_period ) \
-     do { \
-        /* set the minimum to a large value */ \
-        (_the_period)->Statistics.min_cpu_time = 0xffffffff; \
-     } while (0)
-#endif
+void _Rate_monotonic_Manager_initialization(void);
 
-/**
- *  @brief Rate_monotonic_Reset_statistics
- *
- *  This helper method resets the period wall time statistics structure.
- */
-#define _Rate_monotonic_Reset_statistics( _the_period ) \
-  do { \
-    memset( \
-      &(_the_period)->Statistics, \
-      0, \
-      sizeof( rtems_rate_monotonic_period_statistics ) \
-    ); \
-    _Rate_monotonic_Reset_cpu_use_statistics( _the_period ); \
-    _Rate_monotonic_Reset_wall_time_statistics( _the_period ); \
-  } while (0)
 
 #ifndef __RTEMS_APPLICATION__
 #include <rtems/rtems/ratemon.inl>
Index: cpukit/rtems/inline/rtems/rtems/ratemon.inl
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/inline/rtems/rtems/ratemon.inl,v
retrieving revision 1.16
diff -u -p -r1.16 ratemon.inl
--- cpukit/rtems/inline/rtems/rtems/ratemon.inl	4 Sep 2008 17:43:18 -0000	1.16
+++ cpukit/rtems/inline/rtems/rtems/ratemon.inl	27 Jul 2010 16:13:57 -0000
@@ -27,99 +27,7 @@
  *  @{
  */
 
-/**
- *  @brief Rate_monotonic_Allocate
- *
- *  This function allocates a period control block from
- *  the inactive chain of free period control blocks.
- */
-RTEMS_INLINE_ROUTINE Rate_monotonic_Control *_Rate_monotonic_Allocate( void )
-{
-  return (Rate_monotonic_Control *)
-    _Objects_Allocate( &_Rate_monotonic_Information );
-}
 
-/**
- *  @brief Rate_monotonic_Free
- *
- *  This routine allocates a period control block from
- *  the inactive chain of free period control blocks.
- */
-RTEMS_INLINE_ROUTINE void _Rate_monotonic_Free (
-  Rate_monotonic_Control *the_period
-)
-{
-  _Objects_Free( &_Rate_monotonic_Information, &the_period->Object );
-}
-
-/**
- *  @brief Rate_monotonic_Get
- *
- *  This function maps period IDs to period control blocks.
- *  If ID corresponds to a local period, then it returns
- *  the_period control pointer which maps to ID and location
- *  is set to OBJECTS_LOCAL.  Otherwise, location is set
- *  to OBJECTS_ERROR and the_period is undefined.
- */
-RTEMS_INLINE_ROUTINE Rate_monotonic_Control *_Rate_monotonic_Get (
-  Objects_Id         id,
-  Objects_Locations *location
-)
-{
-  return (Rate_monotonic_Control *)
-    _Objects_Get( &_Rate_monotonic_Information, id, location );
-}
-
-/**
- *  @brief Rate_monotonic_Is_active
- *
- *  This function returns TRUE if the_period is in the ACTIVE state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_active (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_ACTIVE);
-}
-
-/**
- *  @brief Rate_monotonic_Is_inactive
- *
- *  This function returns TRUE if the_period is in the ACTIVE state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_inactive (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_INACTIVE);
-}
-
-/**
- *  @brief Rate_monotonic_Is_expired
- *
- *  This function returns TRUE if the_period is in the EXPIRED state,
- *  and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_expired (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period->state == RATE_MONOTONIC_EXPIRED);
-}
-
-/**
- *  @brief Rate_monotonic_Is_null
- *
- *  This function returns TRUE if the_period is NULL and FALSE otherwise.
- */
-RTEMS_INLINE_ROUTINE bool _Rate_monotonic_Is_null (
-  Rate_monotonic_Control *the_period
-)
-{
-  return (the_period == NULL);
-}
 
 /**@}*/
 
Index: cpukit/rtems/src/ratemon.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemon.c,v
retrieving revision 1.24
diff -u -p -r1.24 ratemon.c
--- cpukit/rtems/src/ratemon.c	6 Jan 2009 05:02:25 -0000	1.24
+++ cpukit/rtems/src/ratemon.c	27 Jul 2010 16:13:57 -0000
@@ -22,6 +22,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -42,19 +43,5 @@
 
 void _Rate_monotonic_Manager_initialization(void)
 {
-  _Objects_Initialize_information(
-    &_Rate_monotonic_Information,    /* object information table */
-    OBJECTS_CLASSIC_API,             /* object API */
-    OBJECTS_RTEMS_PERIODS,           /* object class */
-    Configuration_RTEMS_API.maximum_periods,
-                                     /* maximum objects of this class */
-    sizeof( Rate_monotonic_Control ),/* size of this object's control block */
-    false,                           /* true if the name is a string */
-    RTEMS_MAXIMUM_NAME_LENGTH        /* maximum length of an object name */
-#if defined(RTEMS_MULTIPROCESSING)
-    ,
-    false,                           /* true if this is a global object class */
-    NULL                             /* Proxy extraction support callout */
-#endif
-  );
+  _Periodic_Manager_initialization();
 }
Index: cpukit/rtems/src/ratemoncancel.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemoncancel.c,v
retrieving revision 1.10
diff -u -p -r1.10 ratemoncancel.c
--- cpukit/rtems/src/ratemoncancel.c	15 Dec 2009 18:26:41 -0000	1.10
+++ cpukit/rtems/src/ratemoncancel.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -41,28 +42,5 @@ rtems_status_code rtems_rate_monotonic_c
   rtems_id id
 )
 {
-  Rate_monotonic_Control *the_period;
-  Objects_Locations       location;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      if ( !_Thread_Is_executing( the_period->owner ) ) {
-        _Thread_Enable_dispatch();
-        return RTEMS_NOT_OWNER_OF_RESOURCE;
-      }
-      (void) _Watchdog_Remove( &the_period->Timer );
-      the_period->state = RATE_MONOTONIC_INACTIVE;
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_cancel(id));
 }
Index: cpukit/rtems/src/ratemoncreate.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemoncreate.c,v
retrieving revision 1.10
diff -u -p -r1.10 ratemoncreate.c
--- cpukit/rtems/src/ratemoncreate.c	15 Dec 2009 18:26:41 -0000	1.10
+++ cpukit/rtems/src/ratemoncreate.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,37 +46,5 @@ rtems_status_code rtems_rate_monotonic_c
   rtems_id   *id
 )
 {
-  Rate_monotonic_Control *the_period;
-
-  if ( !rtems_is_name_valid( name ) )
-    return RTEMS_INVALID_NAME;
-
-  if ( !id )
-    return RTEMS_INVALID_ADDRESS;
-
-  _Thread_Disable_dispatch();            /* to prevent deletion */
-
-  the_period = _Rate_monotonic_Allocate();
-
-  if ( !the_period ) {
-    _Thread_Enable_dispatch();
-    return RTEMS_TOO_MANY;
-  }
-
-  the_period->owner = _Thread_Executing;
-  the_period->state = RATE_MONOTONIC_INACTIVE;
-
-  _Watchdog_Initialize( &the_period->Timer, NULL, 0, NULL );
-
-  _Rate_monotonic_Reset_statistics( the_period );
-
-  _Objects_Open(
-    &_Rate_monotonic_Information,
-    &the_period->Object,
-    (Objects_Name) name
-  );
-
-  *id = the_period->Object.id;
-  _Thread_Enable_dispatch();
-  return RTEMS_SUCCESSFUL;
+  return (rtems_periodic_create( name, id ));
 }
Index: cpukit/rtems/src/ratemondata.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemondata.c,v
retrieving revision 1.1
diff -u -p -r1.1 ratemondata.c
--- cpukit/rtems/src/ratemondata.c	21 May 2007 23:19:20 -0000	1.1
+++ cpukit/rtems/src/ratemondata.c	27 Jul 2010 16:13:57 -0000
@@ -9,6 +9,8 @@
  *  http://www.rtems.com/license/LICENSE.
  *
  *  $Id: ratemondata.c,v 1.1 2007/05/21 23:19:20 joel Exp $
+ *
+ *  Note: this file is deprecated.
  */
 
 #if HAVE_CONFIG_H
Index: cpukit/rtems/src/ratemondelete.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemondelete.c,v
retrieving revision 1.9
diff -u -p -r1.9 ratemondelete.c
--- cpukit/rtems/src/ratemondelete.c	15 Dec 2009 18:26:41 -0000	1.9
+++ cpukit/rtems/src/ratemondelete.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -41,26 +42,5 @@ rtems_status_code rtems_rate_monotonic_d
   rtems_id id
 )
 {
-  Rate_monotonic_Control *the_period;
-  Objects_Locations       location;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      _Objects_Close( &_Rate_monotonic_Information, &the_period->Object );
-      (void) _Watchdog_Remove( &the_period->Timer );
-      the_period->state = RATE_MONOTONIC_INACTIVE;
-      _Rate_monotonic_Free( the_period );
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return(rtems_periodic_delete(id));
 }
Index: cpukit/rtems/src/ratemongetstatistics.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemongetstatistics.c,v
retrieving revision 1.7
diff -u -p -r1.7 ratemongetstatistics.c
--- cpukit/rtems/src/ratemongetstatistics.c	15 Dec 2009 18:26:41 -0000	1.7
+++ cpukit/rtems/src/ratemongetstatistics.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,47 +46,5 @@ rtems_status_code rtems_rate_monotonic_g
   rtems_rate_monotonic_period_statistics *statistics
 )
 {
-  Objects_Locations                        location;
-  Rate_monotonic_Control                  *the_period;
-  rtems_rate_monotonic_period_statistics  *dst;
-  Rate_monotonic_Statistics               *src;
-
-  if ( !statistics )
-    return RTEMS_INVALID_ADDRESS;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      dst = statistics;
-      src = &the_period->Statistics;
-      dst->count        = src->count;
-      dst->missed_count = src->missed_count;
-      #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-        _Timestamp_To_timespec( &src->min_cpu_time,   &dst->min_cpu_time );
-        _Timestamp_To_timespec( &src->max_cpu_time,   &dst->max_cpu_time );
-        _Timestamp_To_timespec( &src->total_cpu_time, &dst->total_cpu_time );
-        _Timestamp_To_timespec( &src->min_wall_time,   &dst->min_wall_time );
-        _Timestamp_To_timespec( &src->max_wall_time,   &dst->max_wall_time );
-        _Timestamp_To_timespec( &src->total_wall_time, &dst->total_wall_time );
-      #else
-        dst->min_cpu_time    = src->min_cpu_time;
-        dst->max_cpu_time    = src->max_cpu_time;
-        dst->total_cpu_time  = src->total_cpu_time;
-        dst->min_wall_time   = src->min_wall_time;
-        dst->max_wall_time   = src->max_wall_time;
-        dst->total_wall_time = src->total_wall_time;
-      #endif
-
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return(rtems_periodic_get_statistics( id, statistics ));
 }
Index: cpukit/rtems/src/ratemongetstatus.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemongetstatus.c,v
retrieving revision 1.18
diff -u -p -r1.18 ratemongetstatus.c
--- cpukit/rtems/src/ratemongetstatus.c	15 Dec 2009 18:26:41 -0000	1.18
+++ cpukit/rtems/src/ratemongetstatus.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -49,70 +50,5 @@ rtems_status_code rtems_rate_monotonic_g
   rtems_rate_monotonic_period_status *status
 )
 {
-  Thread_CPU_usage_t             executed;
-  Objects_Locations              location;
-  Rate_monotonic_Period_time_t   since_last_period;
-  Rate_monotonic_Control        *the_period;
-  bool                           valid_status;
-
-  if ( !status )
-    return RTEMS_INVALID_ADDRESS;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      status->owner = the_period->owner->Object.id;
-      status->state = the_period->state;
-
-      /*
-       *  If the period is inactive, there is no information.
-       */
-      if ( status->state == RATE_MONOTONIC_INACTIVE ) {
-        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          _Timespec_Set_to_zero( &status->since_last_period );
-          _Timespec_Set_to_zero( &status->executed_since_last_period );
-        #else
-          status->since_last_period = 0;
-          status->executed_since_last_period = 0;
-        #endif
-
-      } else {
-
-        /*
-         *  Grab the current status.
-         */
-        valid_status =
-          _Rate_monotonic_Get_status(
-            the_period, &since_last_period, &executed
-          );
-        if (!valid_status) {
-          _Thread_Enable_dispatch();
-          return RTEMS_NOT_DEFINED;
-        }
-
-        #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          _Timestamp_To_timespec(
-            &since_last_period, &status->since_last_period
-          );
-          _Timestamp_To_timespec(
-            &executed, &status->executed_since_last_period
-          );
-        #else
-          status->since_last_period = since_last_period;
-          status->executed_since_last_period = executed;
-        #endif
-      }
-
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_get_status( id, status ));
 }
Index: cpukit/rtems/src/ratemonident.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemonident.c,v
retrieving revision 1.11
diff -u -p -r1.11 ratemonident.c
--- cpukit/rtems/src/ratemonident.c	15 Dec 2009 18:26:41 -0000	1.11
+++ cpukit/rtems/src/ratemonident.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -45,14 +46,5 @@ rtems_status_code rtems_rate_monotonic_i
   rtems_id   *id
 )
 {
-  Objects_Name_or_id_lookup_errors  status;
-
-  status = _Objects_Name_to_id_u32(
-    &_Rate_monotonic_Information,
-    name,
-    OBJECTS_SEARCH_LOCAL_NODE,
-    id
-  );
-
-  return _Status_Object_name_errors_to_status[ status ];
+  return (rtems_periodic_ident( name, id ));
 }
Index: cpukit/rtems/src/ratemonperiod.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemonperiod.c,v
retrieving revision 1.29
diff -u -p -r1.29 ratemonperiod.c
--- cpukit/rtems/src/ratemonperiod.c	26 Jul 2010 20:27:04 -0000	1.29
+++ cpukit/rtems/src/ratemonperiod.c	27 Jul 2010 16:13:57 -0000
@@ -1,5 +1,5 @@
 /*
- *  Rate Monotonic Manager - Period Blocking and Status
+ *  Rate Monotonic Manager - Period Blocking
  *
  *  COPYRIGHT (c) 1989-2010.
  *  On-Line Applications Research Corporation (OAR).
@@ -20,212 +20,10 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
-bool _Rate_monotonic_Get_status(
-  Rate_monotonic_Control        *the_period,
-  Rate_monotonic_Period_time_t  *wall_since_last_period,
-  Thread_CPU_usage_t            *cpu_since_last_period
-)
-{
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    Timestamp_Control        uptime;
-  #endif
-    Thread_Control          *owning_thread = the_period->owner;
-    Thread_CPU_usage_t       used;
-
-  /*
-   *  Determine elapsed wall time since period initiated.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _TOD_Get_uptime( &uptime );
-    _Timestamp_Subtract(
-      &the_period->time_period_initiated, &uptime, wall_since_last_period
-    );
-  #else
-    *wall_since_last_period =
-      _Watchdog_Ticks_since_boot - the_period->time_period_initiated;
-  #endif
-
-  /*
-   *  Determine cpu usage since period initiated.
-   */
-  used = owning_thread->cpu_time_used;
-
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    if (owning_thread == _Thread_Executing) {
-
-      Thread_CPU_usage_t ran;
-
-      /* How much time time since last context switch */
-      _Timestamp_Subtract(
-        &_Thread_Time_of_last_context_switch, &uptime, &ran
-      );
-
-      /* cpu usage += ran */
-      _Timestamp_Add_to( &used, &ran );
-
-      /*
-       *  The cpu usage info was reset while executing.  Can't
-       *  determine a status.
-       */
-      if (_Timestamp_Less_than(&used, &the_period->cpu_usage_period_initiated))
-        return false;
-
-       /* used = current cpu usage - cpu usage at start of period */
-      _Timestamp_Subtract(
-         &the_period->cpu_usage_period_initiated,
-         &used,
-         cpu_since_last_period
-      );
-    }
-  #else
-      /*
-       *  The cpu usage info was reset while executing.  Can't
-       *  determine a status.
-       */
-      if (used < the_period->cpu_usage_period_initiated)
-        return false;
-
-      *cpu_since_last_period = used - the_period->cpu_usage_period_initiated;
-  #endif
-  return true;
-}
-
-void _Rate_monotonic_Initiate_statistics(
-  Rate_monotonic_Control *the_period
-)
-{
-  Thread_Control *owning_thread = the_period->owner;
-
-  /*
-   *  If using nanosecond statistics, we need to obtain the uptime.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    Timestamp_Control  uptime;
-
-    _TOD_Get_uptime( &uptime );
-  #endif
-
-  /*
-   *  Set the starting point and the CPU time used for the statistics.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    the_period->time_period_initiated = uptime;
-  #else
-    the_period->time_period_initiated = _Watchdog_Ticks_since_boot;
-  #endif
-
-  the_period->cpu_usage_period_initiated = owning_thread->cpu_time_used;
-
-  /*
-   *  If using nanosecond statistics and the period's thread is currently
-   *  executing, then we need to take into account how much time the
-   *  executing thread has run since the last context switch.  When this
-   *  routine is invoked from rtems_rate_monotonic_period, the owner will
-   *  be the executing thread.  When this routine is invoked from
-   *  _Rate_monotonic_Timeout, it will not.
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    if (owning_thread == _Thread_Executing) {
-
-      rtems_thread_cpu_usage_t ran;
-
-      /*
-       *  Adjust the CPU time used to account for the time since last
-       *  context switch.
-       */
-      _Timespec_Subtract(
-        &_Thread_Time_of_last_context_switch, &uptime, &ran
-      );
-
-      _Timespec_Add_to( &the_period->cpu_usage_period_initiated, &ran );
-    }
-  #endif
-}
-
-void _Rate_monotonic_Update_statistics(
-  Rate_monotonic_Control    *the_period
-)
-{
-  Thread_CPU_usage_t              executed;
-  Rate_monotonic_Period_time_t    since_last_period;
-  Rate_monotonic_Statistics      *stats;
-  bool                            valid_status;
-
-  /*
-   *  Assume we are only called in states where it is appropriate
-   *  to update the statistics.  This should only be RATE_MONOTONIC_ACTIVE
-   *  and RATE_MONOTONIC_EXPIRED.
-   */
-
-  /*
-   *  Update the counts.
-   */
-  stats = &the_period->Statistics;
-  stats->count++;
-
-  if ( the_period->state == RATE_MONOTONIC_EXPIRED )
-    stats->missed_count++;
-
-  /*
-   *  Grab status for time statistics.
-   */
-  valid_status =
-    _Rate_monotonic_Get_status( the_period, &since_last_period, &executed );
-  if (!valid_status)
-    return;
-
-  /*
-   *  Update CPU time
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _Timestamp_Add_to( &stats->total_cpu_time, &executed );
-
-    if ( _Timestamp_Less_than( &executed, &stats->min_cpu_time ) )
-      stats->min_cpu_time = executed;
-
-    if ( _Timestamp_Greater_than( &executed, &stats->max_cpu_time ) )
-      stats->max_cpu_time = executed;
-  #else
-    stats->total_cpu_time  += executed;
-
-    if ( executed < stats->min_cpu_time )
-      stats->min_cpu_time = executed;
-
-    if ( executed > stats->max_cpu_time )
-      stats->max_cpu_time = executed;
-  #endif
-
-  /*
-   *  Update Wall time
-   */
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    _Timestamp_Add_to( &stats->total_wall_time, &since_last_period );
-
-    if ( _Timestamp_Less_than( &since_last_period, &stats->min_wall_time ) )
-      stats->min_wall_time = since_last_period;
-
-    if ( _Timestamp_Greater_than( &since_last_period, &stats->max_wall_time ) )
-      stats->max_wall_time = since_last_period;
-  #else
-
-    /* Sanity check wall time */
-    if ( since_last_period < executed )
-      since_last_period = executed;
-
-    stats->total_wall_time += since_last_period;
-
-    if ( since_last_period < stats->min_wall_time )
-      stats->min_wall_time = since_last_period;
-
-    if ( since_last_period > stats->max_wall_time )
-      stats->max_wall_time = since_last_period;
-  #endif
-}
-
-
 /*PAGE
  *
  *  rtems_rate_monotonic_period
@@ -246,129 +44,5 @@ rtems_status_code rtems_rate_monotonic_p
   rtems_interval length
 )
 {
-  Rate_monotonic_Control              *the_period;
-  Objects_Locations                    location;
-  rtems_status_code                    return_value;
-  rtems_rate_monotonic_period_states   local_state;
-  ISR_Level                            level;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-
-  switch ( location ) {
-    case OBJECTS_LOCAL:
-      if ( !_Thread_Is_executing( the_period->owner ) ) {
-        _Thread_Enable_dispatch();
-        return RTEMS_NOT_OWNER_OF_RESOURCE;
-      }
-
-      if ( length == RTEMS_PERIOD_STATUS ) {
-        switch ( the_period->state ) {
-          case RATE_MONOTONIC_INACTIVE:
-            return_value = RTEMS_NOT_DEFINED;
-            break;
-          case RATE_MONOTONIC_EXPIRED:
-          case RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING:
-            return_value = RTEMS_TIMEOUT;
-            break;
-          case RATE_MONOTONIC_ACTIVE:
-          default:              /* unreached -- only to remove warnings */
-            return_value = RTEMS_SUCCESSFUL;
-            break;
-        }
-        _Thread_Enable_dispatch();
-        return( return_value );
-      }
-
-      _ISR_Disable( level );
-      if ( the_period->state == RATE_MONOTONIC_INACTIVE ) {
-        _ISR_Enable( level );
-
-        /*
-         *  Baseline statistics information for the beginning of a period.
-         */
-        _Rate_monotonic_Initiate_statistics( the_period );
-
-        the_period->state = RATE_MONOTONIC_ACTIVE;
-        _Watchdog_Initialize(
-          &the_period->Timer,
-          _Rate_monotonic_Timeout,
-          id,
-          NULL
-        );
-
-        the_period->next_length = length;
-
-        _Watchdog_Insert_ticks( &the_period->Timer, length );
-        _Thread_Enable_dispatch();
-        return RTEMS_SUCCESSFUL;
-      }
-
-      if ( the_period->state == RATE_MONOTONIC_ACTIVE ) {
-        /*
-         *  Update statistics from the concluding period.
-         */
-        _Rate_monotonic_Update_statistics( the_period );
-
-        /*
-         *  This tells the _Rate_monotonic_Timeout that this task is
-         *  in the process of blocking on the period and that we
-         *  may be changing the length of the next period.
-         */
-        the_period->state = RATE_MONOTONIC_OWNER_IS_BLOCKING;
-        the_period->next_length = length;
-
-        _ISR_Enable( level );
-
-        _Thread_Executing->Wait.id = the_period->Object.id;
-        _Thread_Set_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
-
-        /*
-         *  Did the watchdog timer expire while we were actually blocking
-         *  on it?
-         */
-        _ISR_Disable( level );
-          local_state = the_period->state;
-          the_period->state = RATE_MONOTONIC_ACTIVE;
-        _ISR_Enable( level );
-
-        /*
-         *  If it did, then we want to unblock ourself and continue as
-         *  if nothing happen.  The period was reset in the timeout routine.
-         */
-        if ( local_state == RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING )
-          _Thread_Clear_state( _Thread_Executing, STATES_WAITING_FOR_PERIOD );
-
-        _Thread_Enable_dispatch();
-        return RTEMS_SUCCESSFUL;
-      }
-
-      if ( the_period->state == RATE_MONOTONIC_EXPIRED ) {
-        /*
-         *  Update statistics from the concluding period
-         */
-        _Rate_monotonic_Update_statistics( the_period );
-
-        _ISR_Enable( level );
-
-        the_period->state = RATE_MONOTONIC_ACTIVE;
-        the_period->next_length = length;
-
-        _Watchdog_Insert_ticks( &the_period->Timer, length );
-        _Thread_Enable_dispatch();
-        return RTEMS_TIMEOUT;
-      }
-
-      /*
-       *  These should never happen so just return invalid Id.
-       *    - RATE_MONOTONIC_OWNER_IS_BLOCKING:
-       *    - RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING:
-       */
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_period( id, length ));
 }
Index: cpukit/rtems/src/ratemonreportstatistics.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemonreportstatistics.c,v
retrieving revision 1.12
diff -u -p -r1.12 ratemonreportstatistics.c
--- cpukit/rtems/src/ratemonreportstatistics.c	2 Dec 2009 18:22:18 -0000	1.12
+++ cpukit/rtems/src/ratemonreportstatistics.c	27 Jul 2010 16:13:57 -0000
@@ -20,16 +20,11 @@
 #include <ctype.h>
 #include <inttypes.h>
 
+#include <rtems/rtems/periodic.h>
+
 #include <rtems/bspIo.h>
 #include <rtems/score/timespec.h>
 
-#ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-  /* We print to 1/10's of milliseconds */
-  #define NANOSECONDS_DIVIDER 1000
-  #define PERCENT_FMT     "%04" PRId32
-  #define NANOSECONDS_FMT "%06" PRId32
-#endif
-
 /*
  *  This directive allows a thread to print the statistics information
  *  on ALL period instances which have non-zero counts using printk.
@@ -43,165 +38,10 @@ void rtems_rate_monotonic_report_statist
   rtems_printk_plugin_t  print
 )
 {
-  rtems_status_code                      status;
-  rtems_id                               id;
-  rtems_rate_monotonic_period_statistics the_stats;
-  rtems_rate_monotonic_period_status     the_status;
-  char                                   name[5];
-
-  if ( !print )
-    return;
-
-  (*print)( context, "Period information by period\n" );
-  #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-    (*print)( context, "--- CPU times are in seconds ---\n" );
-    (*print)( context, "--- Wall times are in seconds ---\n" );
-  #endif
-/*
-Layout by columns -- in memory of Hollerith :)
-
-1234567890123456789012345678901234567890123456789012345678901234567890123456789\
-   ID     OWNER COUNT MISSED X
-ididididid NNNN ccccc mmmmmm X
-
-  Uncomment the following if you are tinkering with the formatting.
-  Be sure to test the various cases.
-  (*print)( context,"\
-1234567890123456789012345678901234567890123456789012345678901234567890123456789\
-\n");
-*/
-  (*print)( context, "   ID     OWNER COUNT MISSED     "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "     "
-       #endif
-          "CPU TIME     "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "          "
-       #endif
-          "   WALL TIME\n"
-  );
-  (*print)( context, "                               "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "     "
-       #endif
-          "MIN/MAX/AVG    "
-       #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-          "          "
-       #endif
-          "  MIN/MAX/AVG\n"
-  );
-
-  /*
-   * Cycle through all possible ids and try to report on each one.  If it
-   * is a period that is inactive, we just get an error back.  No big deal.
-   */
-  for ( id=_Rate_monotonic_Information.minimum_id ;
-        id <= _Rate_monotonic_Information.maximum_id ;
-        id++ ) {
-    status = rtems_rate_monotonic_get_statistics( id, &the_stats );
-    if ( status != RTEMS_SUCCESSFUL )
-      continue;
-
-    /* If the above passed, so should this but check it anyway */
-    status = rtems_rate_monotonic_get_status( id, &the_status );
-    #if defined(RTEMS_DEBUG)
-      if ( status != RTEMS_SUCCESSFUL )
-        continue;
-    #endif
-
-    rtems_object_get_name( the_status.owner, sizeof(name), name );
-
-    /*
-     *  Print part of report line that is not dependent on granularity
-     */
-    (*print)( context,
-      "0x%08" PRIx32 " %4s %5" PRId32 " %6" PRId32 " ",
-      id, name,
-      the_stats.count, the_stats.missed_count
-    );
-
-    /*
-     *  If the count is zero, don't print statistics
-     */
-    if (the_stats.count == 0) {
-      (*print)( context, "\n" );
-      continue;
-    }
-
-    /*
-     *  print CPU Usage part of statistics
-     */
-    {
-    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-      struct timespec  cpu_average;
-      struct timespec *min_cpu = &the_stats.min_cpu_time;
-      struct timespec *max_cpu = &the_stats.max_cpu_time;
-      struct timespec *total_cpu = &the_stats.total_cpu_time;
-
-      _Timespec_Divide_by_integer( total_cpu, the_stats.count, &cpu_average );
-      (*print)( context,
-        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* min cpu time */
-        "%" PRId32 "."  NANOSECONDS_FMT "/"        /* max cpu time */
-        "%" PRId32 "."  NANOSECONDS_FMT " ",       /* avg cpu time */
-        _Timespec_Get_seconds( min_cpu ),
-	  _Timespec_Get_nanoseconds( min_cpu ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( max_cpu ),
-	  _Timespec_Get_nanoseconds( max_cpu ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( &cpu_average ),
-	  _Timespec_Get_nanoseconds( &cpu_average ) / NANOSECONDS_DIVIDER
-       );
-    #else
-      uint32_t ival_cpu, fval_cpu;
-
-      ival_cpu = the_stats.total_cpu_time * 100 / the_stats.count;
-      fval_cpu = ival_cpu % 100;
-      ival_cpu /= 100;
-
-      (*print)( context,
-        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 " ",
-        the_stats.min_cpu_time, the_stats.max_cpu_time, ival_cpu, fval_cpu
-      );
-    #endif
-    }
-
-    /*
-     *  print wall time part of statistics
-     */
-    {
-    #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
-      struct timespec  wall_average;
-      struct timespec *min_wall = &the_stats.min_wall_time;
-      struct timespec *max_wall = &the_stats.max_wall_time;
-      struct timespec *total_wall = &the_stats.total_wall_time;
-
-      _Timespec_Divide_by_integer(total_wall, the_stats.count, &wall_average);
-      (*print)( context,
-        "%" PRId32 "." NANOSECONDS_FMT "/"        /* min wall time */
-        "%" PRId32 "." NANOSECONDS_FMT "/"        /* max wall time */
-        "%" PRId32 "." NANOSECONDS_FMT "\n",      /* avg wall time */
-        _Timespec_Get_seconds( min_wall ),
-          _Timespec_Get_nanoseconds( min_wall ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( max_wall ),
-          _Timespec_Get_nanoseconds( max_wall ) / NANOSECONDS_DIVIDER,
-        _Timespec_Get_seconds( &wall_average ),
-          _Timespec_Get_nanoseconds( &wall_average ) / NANOSECONDS_DIVIDER
-      );
-    #else
-      uint32_t  ival_wall, fval_wall;
-
-      ival_wall = the_stats.total_wall_time * 100 / the_stats.count;
-      fval_wall = ival_wall % 100;
-      ival_wall /= 100;
-      (*print)( context,
-        "%3" PRId32 "/%4" PRId32 "/%3" PRId32 ".%02" PRId32 "\n",
-        the_stats.min_wall_time, the_stats.max_wall_time, ival_wall, fval_wall
-      );
-    #endif
-    }
-  }
+  rtems_periodic_report_statistics_with_plugin( context, print );
 }
 
 void rtems_rate_monotonic_report_statistics( void )
 {
-  rtems_rate_monotonic_report_statistics_with_plugin( NULL, printk_plugin );
+  rtems_periodic_report_statistics_with_plugin( NULL, printk_plugin );
 }
Index: cpukit/rtems/src/ratemonresetall.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemonresetall.c,v
retrieving revision 1.2
diff -u -p -r1.2 ratemonresetall.c
--- cpukit/rtems/src/ratemonresetall.c	17 May 2007 22:46:45 -0000	1.2
+++ cpukit/rtems/src/ratemonresetall.c	27 Jul 2010 16:13:57 -0000
@@ -19,6 +19,7 @@
 #include <rtems/rtems/status.h>
 #include <rtems/rtems/support.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -27,30 +28,5 @@
  */
 void rtems_rate_monotonic_reset_all_statistics( void )
 {
-  Objects_Id        id;
-  rtems_status_code status;
-
-   /*
-    *  Prevent allocation or deallocation of any of the periods while
-    *  we are cycling.  Also this is an optimization which ensures that
-    *  we only disable/enable once.  The call to
-    *  rtems_rate_monotonic_reset_statistics will be in a nested dispatch
-    *  disabled critical section.
-    */
-  _Thread_Disable_dispatch();
-
-    /*
-     * Cycle through all possible ids and try to reset each one.  If it
-     * is a period that is inactive, we just get an error back.  No big deal.
-     */
-    for ( id=_Rate_monotonic_Information.minimum_id ;
-          id <= _Rate_monotonic_Information.maximum_id ;
-          id++ ) {
-      status = rtems_rate_monotonic_reset_statistics( id );
-    }
-
-  /*
-   *  Done so exit thread dispatching disabled critical section.
-   */
-  _Thread_Enable_dispatch();
+  rtems_periodic_reset_all_statistics();
 }
Index: cpukit/rtems/src/ratemonresetstatistics.c
===================================================================
RCS file: /usr1/CVS/rtems/cpukit/rtems/src/ratemonresetstatistics.c,v
retrieving revision 1.4
diff -u -p -r1.4 ratemonresetstatistics.c
--- cpukit/rtems/src/ratemonresetstatistics.c	15 Dec 2009 18:26:41 -0000	1.4
+++ cpukit/rtems/src/ratemonresetstatistics.c	27 Jul 2010 16:13:57 -0000
@@ -20,6 +20,7 @@
 #include <rtems/rtems/support.h>
 #include <rtems/score/isr.h>
 #include <rtems/score/object.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/ratemon.h>
 #include <rtems/score/thread.h>
 
@@ -43,23 +44,5 @@ rtems_status_code rtems_rate_monotonic_r
   rtems_id id
 )
 {
-  Objects_Locations              location;
-  Rate_monotonic_Control        *the_period;
-
-  the_period = _Rate_monotonic_Get( id, &location );
-  switch ( location ) {
-
-    case OBJECTS_LOCAL:
-      _Rate_monotonic_Reset_statistics( the_period );
-      _Thread_Enable_dispatch();
-      return RTEMS_SUCCESSFUL;
-
-#if defined(RTEMS_MULTIPROCESSING)
-    case OBJECTS_REMOTE:            /* should never return this */
-#endif
-    case OBJECTS_ERROR:
-      break;
-  }
-
-  return RTEMS_INVALID_ID;
+  return (rtems_periodic_reset_statistics( id ));
 }
Index: testsuites/sptests/sp69/init.c
===================================================================
RCS file: /usr1/CVS/rtems/testsuites/sptests/sp69/init.c,v
retrieving revision 1.3
diff -u -p -r1.3 init.c
--- testsuites/sptests/sp69/init.c	15 Dec 2009 18:24:12 -0000	1.3
+++ testsuites/sptests/sp69/init.c	27 Jul 2010 16:13:59 -0000
@@ -47,7 +47,7 @@ rtems_task Init(
 
   /* Check status values. */
   rtems_test_assert( period_status.owner == rtems_task_self() );
-  rtems_test_assert( period_status.state == RATE_MONOTONIC_INACTIVE );
+  rtems_test_assert( period_status.state == PERIODIC_INACTIVE );
   #ifndef __RTEMS_USE_TICKS_FOR_STATISTICS__
     rtems_test_assert( period_status.since_last_period.tv_sec == 0 );
     rtems_test_assert( period_status.since_last_period.tv_nsec == 0 );
Index: testsuites/sptests/spintrcritical08/init.c
===================================================================
RCS file: /usr1/CVS/rtems/testsuites/sptests/spintrcritical08/init.c,v
retrieving revision 1.4
diff -u -p -r1.4 init.c
--- testsuites/sptests/spintrcritical08/init.c	30 Nov 2009 03:33:25 -0000	1.4
+++ testsuites/sptests/spintrcritical08/init.c	27 Jul 2010 16:13:59 -0000
@@ -17,13 +17,13 @@ rtems_id Main_task;
 rtems_id Period;
 volatile bool case_hit;
 
-rtems_rate_monotonic_period_states getState(void)
+rtems_periodic_period_states getState(void)
 {
   Objects_Locations       location;
-  Rate_monotonic_Control *period;
+  Periodic_Control *period;
 
-  period = (Rate_monotonic_Control *)_Objects_Get(
-    &_Rate_monotonic_Information, Period, &location );
+  period = (Periodic_Control *)_Objects_Get(
+    &_Periodic_Information, Period, &location );
   if ( location != OBJECTS_LOCAL ) {
     puts( "Bad object lookup" );
     rtems_test_exit(0);
@@ -38,7 +38,7 @@ rtems_timer_service_routine test_release
   void     *arg
 )
 {
-  if ( getState() == RATE_MONOTONIC_EXPIRED_WHILE_BLOCKING )
+  if ( getState() == PERIODIC_EXPIRED_WHILE_BLOCKING )
     case_hit = true;
 }
 
@@ -53,12 +53,12 @@ rtems_task Init(
 
   puts( "Init - Trying to generate period ending while blocking" );
 
-  puts( "Init - rtems_rate_monotonic_create - OK" );
-  sc = rtems_rate_monotonic_create(
+  puts( "Init - rtems_periodic_create - OK" );
+  sc = rtems_periodic_create(
     rtems_build_name( 'P', 'E', 'R', '1' ),
     &Period
   );
-  directive_failed( sc, "rtems_rate_monotonic_create" );
+  directive_failed( sc, "rtems_periodic_create" );
 
   Main_task = rtems_task_self();
 
@@ -70,10 +70,10 @@ rtems_task Init(
     if ( interrupt_critical_section_test_support_delay() )
       resets++;
 
-    sc = rtems_rate_monotonic_period( Period, 1 );
+    sc = rtems_periodic_period( Period, 1 );
     if ( sc == RTEMS_TIMEOUT )
       continue;
-    directive_failed( sc, "rtems_monotonic_period");
+    directive_failed( sc, "rtems_periodic_period");
   }
 
   if ( case_hit ) {
Index: testsuites/sptests/spsize/size.c
===================================================================
RCS file: /usr1/CVS/rtems/testsuites/sptests/spsize/size.c,v
retrieving revision 1.65
diff -u -p -r1.65 size.c
--- testsuites/sptests/spsize/size.c	29 Jun 2010 00:40:29 -0000	1.65
+++ testsuites/sptests/spsize/size.c	27 Jul 2010 16:13:59 -0000
@@ -33,7 +33,8 @@
 #endif
 #include <rtems/rtems/part.h>
 #include <rtems/score/priority.h>
-#include <rtems/rtems/ratemon.h>
+#include <rtems/score/periodic.h>
+#include <rtems/rtems/periodic.h>
 #include <rtems/rtems/region.h>
 #include <rtems/rtems/sem.h>
 #include <rtems/rtems/signal.h>
@@ -81,7 +82,7 @@ void print_formula(void);
 #define PER_PART      \
      (long) (sizeof (Partition_Control) + NAME_PTR_SIZE)
 #define PER_PERIOD      \
-     (long) (sizeof (Rate_monotonic_Control) + NAME_PTR_SIZE)
+     (long) (sizeof (Periodic_Control) + NAME_PTR_SIZE)
 #define PER_PORT      \
      (long) (sizeof (Dual_ported_memory_Control) + NAME_PTR_SIZE)
 #define PER_EXTENSION     \
@@ -228,7 +229,7 @@ uninitialized =
                 (sizeof _Configuration_MP_table)          +
         #endif
 
-/*context.h*/   (sizeof _Context_Switch_necessary)        +
+/*context.h*/   (sizeof _Thread_Dispatch_necessary)        +
 
 /*copyrt.h*/    0                                         +
 
@@ -311,11 +312,11 @@ uninitialized =
 
 /*percpu.h*/    (sizeof _Per_CPU_Information)             +
 
+/*periodic.h*/  (sizeof _Periodic_Information)            +
+
 /*priority.h*/  (sizeof _Priority_Major_bit_map)          +
                 (sizeof _Priority_Bit_map)                +
 
-/*ratemon.h*/   (sizeof _Rate_monotonic_Information)      +
-
 /*region.h*/    (sizeof _Region_Information)              +
 
 #if defined(RTEMS_MULTIPROCESSING)
@@ -355,7 +356,6 @@ uninitialized =
                 (sizeof _Thread_Dispatch_disable_level)   +
                 (sizeof _Thread_Maximum_extensions)       +
                 (sizeof _Thread_Ticks_per_timeslice)      +
-                (sizeof _Thread_Ready_chain)              +
                 (sizeof _Thread_Executing)                +
                 (sizeof _Thread_Heir)                     +
 #if (CPU_HARDWARE_FP == 1) || (CPU_SOFTWARE_FP == 1)

